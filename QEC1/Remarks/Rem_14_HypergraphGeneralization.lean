import QEC1.Theorems.Thm_1_GaugingMeasurement
import Mathlib.Data.Matrix.Basic

/-!
# Hypergraph Generalization (Remark 14)

## Statement
The gauging measurement procedure generalizes from graphs to hypergraphs:

**Hypergraph gauging**: Replace the graph G with a hypergraph H = (V, E) where E is a
collection of hyperedges (subsets of V of arbitrary size).

**Generalized Gauss's law**: For each vertex v, define:
  A_v = X_v ∏_{e ∈ E : v ∈ e} X_e

**What can be measured**: The hypergraph gauging measures the group of operators:
  {P ∈ ⟨X_v : v ∈ V⟩ : [P, B_e] = 0 for all e ∈ E}
where B_e = ∏_{v ∈ e} Z_v are Z-type hyperedge checks.

This is equivalent to ker(H^T) where H is the incidence matrix of the hypergraph over F_2.

**Application**: Measure multiple commuting logical operators simultaneously by choosing a
hypergraph whose kernel is exactly the group generated by those logicals.

## Main Results
**Main Structure** (`Hypergraph`): A hypergraph with vertices and hyperedges
**Incidence Matrix** (`incidenceMatrix`): The vertex-edge incidence matrix over ZMod 2
**Generalized Gauss Law** (`hypergraphGaussLaw`): A_v operators for hypergraphs
**Commutativity** (`hypergraph_gaussLaw_commute`): All A_v commute (X-type)
**Measurable Group** (`measurableGroup`): ker(H^T) characterization
**Commutation Theorem** (`commutes_iff_in_kernel`): P commutes with all B_e iff in ker(H^T)

## File Structure
1. Hypergraph Definition: Vertices and hyperedges
2. Incidence Matrix: H[v,e] = 1 if v ∈ e
3. Generalized Gauss Law Operators: A_v = X_v ∏_{e ∋ v} X_e
4. Z-type Hyperedge Checks: B_e = ∏_{v ∈ e} Z_v
5. Kernel Characterization: Measurable operators = ker(H^T)
6. Application: Simultaneous measurement of logicals
-/

namespace QEC

open scoped BigOperators Matrix

/-! ## Section 1: Hypergraph Definition -/

/-- A hypergraph H = (V, E) consists of a finite vertex set V and a collection of
    hyperedges, where each hyperedge is a non-empty subset of V.

    This generalizes simple graphs where each edge has exactly 2 vertices. -/
structure Hypergraph where
  /-- The vertex type -/
  Vertex : Type
  /-- The hyperedge index type -/
  EdgeIdx : Type
  /-- Vertices are finite -/
  vertexFintype : Fintype Vertex
  /-- Edges are finite -/
  edgeFintype : Fintype EdgeIdx
  /-- Vertices have decidable equality -/
  vertexDecEq : DecidableEq Vertex
  /-- Edges have decidable equality -/
  edgeDecEq : DecidableEq EdgeIdx
  /-- Each hyperedge is a subset of vertices -/
  hyperedge : EdgeIdx → Finset Vertex
  /-- Each hyperedge is non-empty -/
  hyperedge_nonempty : ∀ e, (hyperedge e).Nonempty

attribute [instance] Hypergraph.vertexFintype Hypergraph.edgeFintype
  Hypergraph.vertexDecEq Hypergraph.edgeDecEq

namespace Hypergraph

variable (H : Hypergraph)

/-- Number of vertices -/
def numVertices : ℕ := Fintype.card H.Vertex

/-- Number of hyperedges -/
def numEdges : ℕ := Fintype.card H.EdgeIdx

/-- Check if a vertex is in a hyperedge -/
def vertexInEdge (v : H.Vertex) (e : H.EdgeIdx) : Bool :=
  v ∈ H.hyperedge e

/-- The degree of a vertex: number of hyperedges containing it -/
def vertexDegree (v : H.Vertex) : ℕ :=
  (Finset.filter (fun e => v ∈ H.hyperedge e) Finset.univ).card

/-- The size of a hyperedge: number of vertices in it -/
def edgeSize (e : H.EdgeIdx) : ℕ := (H.hyperedge e).card

end Hypergraph

/-! ## Section 2: Incidence Matrix -/

/-- The incidence matrix H of a hypergraph over ZMod 2.
    H[v, e] = 1 if vertex v is in hyperedge e, 0 otherwise.

    This is a |V| × |E| matrix. -/
def incidenceMatrix (H : Hypergraph) : Matrix H.Vertex H.EdgeIdx (ZMod 2) :=
  fun v e => if v ∈ H.hyperedge e then 1 else 0

/-- The transpose incidence matrix H^T: |E| × |V| matrix -/
def incidenceMatrixTranspose (H : Hypergraph) : Matrix H.EdgeIdx H.Vertex (ZMod 2) :=
  (incidenceMatrix H)ᵀ

/-- Incidence matrix entry characterization -/
@[simp]
theorem incidenceMatrix_apply (H : Hypergraph) (v : H.Vertex) (e : H.EdgeIdx) :
    incidenceMatrix H v e = if v ∈ H.hyperedge e then 1 else 0 := rfl

/-- Transpose entry characterization -/
@[simp]
theorem incidenceMatrixTranspose_apply (H : Hypergraph) (e : H.EdgeIdx) (v : H.Vertex) :
    incidenceMatrixTranspose H e v = if v ∈ H.hyperedge e then 1 else 0 := rfl

/-- Row sum of incidence matrix = vertex degree mod 2 -/
theorem incidenceMatrix_row_sum (H : Hypergraph) (v : H.Vertex) :
    Finset.sum Finset.univ (fun e => incidenceMatrix H v e) =
    (H.vertexDegree v : ZMod 2) := by
  unfold incidenceMatrix Hypergraph.vertexDegree
  simp only [Finset.sum_ite, Finset.sum_const_zero, add_zero]
  simp only [Finset.sum_const, Nat.smul_one_eq_cast]

/-- Column sum of incidence matrix = hyperedge size mod 2 -/
theorem incidenceMatrix_col_sum (H : Hypergraph) (e : H.EdgeIdx) :
    Finset.sum Finset.univ (fun v => incidenceMatrix H v e) =
    (H.edgeSize e : ZMod 2) := by
  unfold incidenceMatrix Hypergraph.edgeSize
  simp only [Finset.sum_ite, Finset.sum_const_zero, add_zero]
  simp only [Finset.sum_const, Nat.smul_one_eq_cast]
  simp only [Finset.filter_mem_eq_inter, Finset.univ_inter]

/-! ## Section 3: Generalized Gauss Law Operators -/

/-- A Gauss law operator for hypergraph vertex v.
    A_v = X_v ∏_{e : v ∈ e} X_e

    Represented by its X-support on vertices and hyperedges. -/
structure HypergraphGaussLaw (H : Hypergraph) where
  /-- The center vertex -/
  vertex : H.Vertex
  /-- Support on vertex qubits -/
  vertexSupport : H.Vertex → ZMod 2
  /-- Support on hyperedge qubits -/
  edgeSupport : H.EdgeIdx → ZMod 2
  /-- Vertex support is 1 at center -/
  vertex_at_center : vertexSupport vertex = 1
  /-- Vertex support is 0 elsewhere -/
  vertex_off_center : ∀ w, w ≠ vertex → vertexSupport w = 0
  /-- Edge support is 1 iff edge contains center -/
  edge_support_spec : ∀ e, edgeSupport e = if vertex ∈ H.hyperedge e then 1 else 0

/-- Construct the canonical Gauss law operator A_v for hypergraph vertex v -/
def mkHypergraphGaussLaw (H : Hypergraph) (v : H.Vertex) : HypergraphGaussLaw H where
  vertex := v
  vertexSupport := fun w => if w = v then 1 else 0
  edgeSupport := fun e => if v ∈ H.hyperedge e then 1 else 0
  vertex_at_center := by simp
  vertex_off_center := fun w hw => by simp [hw]
  edge_support_spec := fun _ => rfl

/-- Collection of all hypergraph Gauss law operators -/
def hypergraphGaussLawOperators (H : Hypergraph) : H.Vertex → HypergraphGaussLaw H :=
  mkHypergraphGaussLaw H

/-! ## Section 4: Commutativity of Hypergraph Gauss Law Operators -/

/-- Z-support of a hypergraph Gauss law operator is empty (X-type operators) -/
def hypergraph_ZSupport (H : Hypergraph) (_v : H.Vertex) : Finset H.Vertex := ∅

/-- Z-support on edges is also empty -/
def hypergraph_ZSupport_edges (H : Hypergraph) (_v : H.Vertex) : Finset H.EdgeIdx := ∅

/-- Symplectic form for hypergraph Gauss law operators.
    Since they are X-type, the symplectic form is 0. -/
def hypergraph_symplectic_form (H : Hypergraph) (v w : H.Vertex) : ℕ :=
  (hypergraph_ZSupport H w).card + (hypergraph_ZSupport H v).card

/-- The symplectic form is zero for X-type operators -/
theorem hypergraph_symplectic_eq_zero (H : Hypergraph) (v w : H.Vertex) :
    hypergraph_symplectic_form H v w = 0 := by
  unfold hypergraph_symplectic_form hypergraph_ZSupport
  simp only [Finset.card_empty, add_zero]

/-- **Commutativity**: All hypergraph Gauss law operators commute.
    This follows from them being purely X-type (no Z component). -/
theorem hypergraph_gaussLaw_commute (H : Hypergraph) (v w : H.Vertex) :
    hypergraph_symplectic_form H v w % 2 = 0 := by
  simp only [hypergraph_symplectic_eq_zero, Nat.zero_mod]

/-! ## Section 5: Z-type Hyperedge Checks (B_e operators) -/

/-- A Z-type hyperedge check B_e = ∏_{v ∈ e} Z_v.
    Represented by its Z-support. -/
structure HyperedgeCheck (H : Hypergraph) where
  /-- The hyperedge index -/
  edge : H.EdgeIdx
  /-- Z-support on vertices -/
  zSupport : H.Vertex → ZMod 2
  /-- X-support is empty -/
  xSupport : H.Vertex → ZMod 2
  /-- X-support is zero everywhere -/
  x_support_zero : ∀ v, xSupport v = 0
  /-- Z-support is 1 on vertices in the hyperedge -/
  z_support_spec : ∀ v, zSupport v = if v ∈ H.hyperedge edge then 1 else 0

/-- Construct the Z-type hyperedge check B_e -/
def mkHyperedgeCheck (H : Hypergraph) (e : H.EdgeIdx) : HyperedgeCheck H where
  edge := e
  zSupport := fun v => if v ∈ H.hyperedge e then 1 else 0
  xSupport := fun _ => 0
  x_support_zero := fun _ => rfl
  z_support_spec := fun _ => rfl

/-- Collection of all hyperedge checks -/
def hyperedgeChecks (H : Hypergraph) : H.EdgeIdx → HyperedgeCheck H :=
  mkHyperedgeCheck H

/-! ## Section 6: Commutation with Hyperedge Checks -/

/-- An X-type vertex operator P = ∏_{v ∈ S} X_v, represented by its support S. -/
abbrev XOperatorSupport (H : Hypergraph) := H.Vertex → ZMod 2

/-- Symplectic form between X-type operator P and Z-type check B_e.
    ω(P, B_e) = |supp_X(P) ∩ supp_Z(B_e)| = |S ∩ e| -/
def symplectic_XZ (H : Hypergraph) (P : XOperatorSupport H) (e : H.EdgeIdx) : ℕ :=
  (Finset.filter (fun v => P v = 1 ∧ v ∈ H.hyperedge e) Finset.univ).card

/-- P commutes with B_e iff symplectic form is even -/
def commutesWithCheck (H : Hypergraph) (P : XOperatorSupport H) (e : H.EdgeIdx) : Prop :=
  symplectic_XZ H P e % 2 = 0

/-- P commutes with all B_e -/
def commutesWithAllChecks (H : Hypergraph) (P : XOperatorSupport H) : Prop :=
  ∀ e, commutesWithCheck H P e

/-! ## Section 7: Kernel Characterization -/

/-- The support of an X-operator as a column vector over ZMod 2 -/
def supportVector (H : Hypergraph) (P : XOperatorSupport H) : H.Vertex → ZMod 2 := P

/-- Matrix-vector product H^T · P gives overlap counts mod 2.
    (H^T · P)_e = ∑_v H[v,e] · P[v] = |P ∩ e| mod 2 -/
def matrixVectorProduct (H : Hypergraph) (P : XOperatorSupport H) : H.EdgeIdx → ZMod 2 :=
  fun e => Finset.sum Finset.univ (fun v => incidenceMatrix H v e * P v)

/-- P ∈ ker(H^T) iff H^T · P = 0 -/
def inKernelOfTranspose (H : Hypergraph) (P : XOperatorSupport H) : Prop :=
  ∀ e, matrixVectorProduct H P e = 0

/-- **Key Lemma**: Matrix-vector product equals symplectic form mod 2.
    (H^T · P)_e = |{v : P(v) = 1 ∧ v ∈ e}| mod 2 -/
theorem matrixVectorProduct_eq_overlap (H : Hypergraph) (P : XOperatorSupport H)
    (e : H.EdgeIdx) :
    matrixVectorProduct H P e =
    (Finset.filter (fun v => P v = 1 ∧ v ∈ H.hyperedge e) Finset.univ).card := by
  unfold matrixVectorProduct
  simp only [incidenceMatrix_apply]
  -- The sum of (if v ∈ e then 1 else 0) * P v counts v with P v = 1 and v ∈ e
  have h_eq : ∀ v, (if v ∈ H.hyperedge e then (1 : ZMod 2) else 0) * P v =
      if P v = 1 ∧ v ∈ H.hyperedge e then 1 else 0 := by
    intro v
    by_cases he : v ∈ H.hyperedge e
    · simp only [he, ↓reduceIte, one_mul, and_true]
      by_cases hp : P v = 1
      · simp only [hp, ↓reduceIte]
      · have hp' : P v = 0 := by
          have hval : (P v).val = 0 ∨ (P v).val = 1 := by
            have hlt : (P v).val < 2 := (P v).isLt
            omega
          cases hval with
          | inl h0 => exact Fin.ext h0
          | inr h1 =>
            have : P v = 1 := Fin.ext h1
            exact absurd this hp
        simp only [hp']
        decide
    · simp only [he, ↓reduceIte, zero_mul, and_false]
  simp_rw [h_eq]
  rw [← Finset.sum_filter]
  simp only [Finset.sum_const, Nat.smul_one_eq_cast]

/-- **Main Theorem**: P commutes with all B_e iff P ∈ ker(H^T).

    [P, B_e] = 0 for all e ∈ E ⟺ H^T · P = 0

    This is the algebraic characterization of measurable operators. -/
theorem commutes_iff_in_kernel (H : Hypergraph) (P : XOperatorSupport H) :
    commutesWithAllChecks H P ↔ inKernelOfTranspose H P := by
  unfold commutesWithAllChecks commutesWithCheck inKernelOfTranspose
  constructor
  · intro hcomm e
    specialize hcomm e
    unfold symplectic_XZ at hcomm
    rw [matrixVectorProduct_eq_overlap]
    have hmod : ((Finset.filter (fun v => P v = 1 ∧ v ∈ H.hyperedge e)
        Finset.univ).card : ZMod 2) = 0 := by
      have heven : Even (Finset.filter
          (fun v => P v = 1 ∧ v ∈ H.hyperedge e) Finset.univ).card := by
        rw [Nat.even_iff]
        exact hcomm
      exact heven.natCast_zmod_two
    exact hmod
  · intro hker e
    specialize hker e
    rw [matrixVectorProduct_eq_overlap] at hker
    unfold symplectic_XZ
    -- hker : (card : ZMod 2) = 0, need to show card % 2 = 0
    have h : ((Finset.filter (fun v => P v = 1 ∧ v ∈ H.hyperedge e)
        Finset.univ).card : ZMod 2) = 0 := hker
    -- In ZMod 2, x = 0 iff x.val % 2 = 0
    have hval : (Finset.filter (fun v => P v = 1 ∧ v ∈ H.hyperedge e)
        Finset.univ).card % 2 = 0 := by
      have : ((Finset.filter (fun v => P v = 1 ∧ v ∈ H.hyperedge e)
          Finset.univ).card : ZMod 2).val = 0 := by
        simp only [h, ZMod.val_zero]
      rw [ZMod.val_natCast] at this
      exact this
    exact hval

/-! ## Section 8: Measurable Group Structure -/

/-- The group of measurable X-operators: those commuting with all B_e.
    This is isomorphic to ker(H^T) as a Z₂-vector space. -/
def measurableGroup (H : Hypergraph) : Set (XOperatorSupport H) :=
  {P | commutesWithAllChecks H P}

/-- The measurable group equals the kernel of H^T -/
theorem measurableGroup_eq_kernel (H : Hypergraph) :
    measurableGroup H = {P | inKernelOfTranspose H P} := by
  ext P
  simp only [measurableGroup, Set.mem_setOf_eq]
  exact commutes_iff_in_kernel H P

/-- The zero operator is always measurable -/
theorem zero_in_measurableGroup (H : Hypergraph) :
    (fun _ => 0) ∈ measurableGroup H := by
  simp only [measurableGroup, Set.mem_setOf_eq, commutesWithAllChecks, commutesWithCheck,
    symplectic_XZ]
  intro e
  have h_empty : Finset.filter (fun v => (0 : ZMod 2) = 1 ∧ v ∈ H.hyperedge e) Finset.univ = ∅ := by
    ext v
    simp only [Finset.mem_filter, Finset.mem_univ, true_and, Finset.notMem_empty, iff_false,
      not_and]
    intro h01
    exact absurd h01 (by decide : ¬(0 : ZMod 2) = 1)
  simp only [h_empty, Finset.card_empty, Nat.zero_mod]

/-- Sum of measurable operators is measurable -/
theorem sum_in_measurableGroup (H : Hypergraph) (P Q : XOperatorSupport H)
    (hP : P ∈ measurableGroup H) (hQ : Q ∈ measurableGroup H) :
    (fun v => P v + Q v) ∈ measurableGroup H := by
  simp only [measurableGroup, Set.mem_setOf_eq] at *
  rw [commutes_iff_in_kernel] at *
  unfold inKernelOfTranspose matrixVectorProduct at *
  intro e
  have hPe := hP e
  have hQe := hQ e
  have h_distrib : ∀ v, incidenceMatrix H v e * (P v + Q v) =
      incidenceMatrix H v e * P v + incidenceMatrix H v e * Q v := by intro v; ring
  simp_rw [h_distrib]
  rw [Finset.sum_add_distrib, hPe, hQe]
  ring

/-! ## Section 9: Product of Gauss Law Operators -/

/-- Sum of all Gauss law vertex supports (each v contributes 1 to position v) -/
noncomputable def hypergraph_productVertexSupport (H : Hypergraph) : H.Vertex → ZMod 2 :=
  fun v => Finset.sum Finset.univ (fun w =>
    (hypergraphGaussLawOperators H w).vertexSupport v)

/-- Each vertex appears exactly once in the sum -/
theorem hypergraph_productVertexSupport_eq_one (H : Hypergraph) (v : H.Vertex) :
    hypergraph_productVertexSupport H v = 1 := by
  unfold hypergraph_productVertexSupport hypergraphGaussLawOperators mkHypergraphGaussLaw
  simp only
  have h : (Finset.univ.filter (fun w : H.Vertex => v = w)).card = 1 := by
    have heq : (Finset.univ.filter (fun w : H.Vertex => v = w)) =
               (Finset.univ.filter (fun w : H.Vertex => w = v)) := by
      ext x
      simp only [Finset.mem_filter, Finset.mem_univ, true_and]
      exact eq_comm
    rw [heq, Finset.filter_eq', if_pos (Finset.mem_univ v)]
    simp
  rw [Finset.sum_ite, Finset.sum_const_zero, add_zero, Finset.sum_const, Nat.smul_one_eq_cast]
  rw [h]
  rfl

/-- Product of all Gauss law operators gives all-ones support (the logical L) -/
theorem hypergraph_gaussLaw_product_is_all_ones (H : Hypergraph) :
    hypergraph_productVertexSupport H = fun _ => 1 := by
  funext v
  exact hypergraph_productVertexSupport_eq_one H v

/-! ## Section 10: Edge Support Cancellation -/

/-- Sum of all Gauss law edge supports -/
noncomputable def hypergraph_productEdgeSupport (H : Hypergraph) : H.EdgeIdx → ZMod 2 :=
  fun e => Finset.sum Finset.univ (fun v =>
    (hypergraphGaussLawOperators H v).edgeSupport e)

/-- Edge e appears once for each vertex in it, so sum = |e| mod 2 -/
theorem hypergraph_productEdgeSupport_eq_size (H : Hypergraph) (e : H.EdgeIdx) :
    hypergraph_productEdgeSupport H e = (H.edgeSize e : ZMod 2) := by
  unfold hypergraph_productEdgeSupport hypergraphGaussLawOperators mkHypergraphGaussLaw
    Hypergraph.edgeSize
  simp only
  rw [Finset.sum_boole]
  congr
  simp only [Finset.filter_mem_eq_inter, Finset.univ_inter]

/-- For hyperedges of even size, edge support cancels in the product -/
theorem hypergraph_productEdgeSupport_even (H : Hypergraph) (e : H.EdgeIdx)
    (heven : Even (H.edgeSize e)) :
    hypergraph_productEdgeSupport H e = 0 := by
  rw [hypergraph_productEdgeSupport_eq_size]
  exact heven.natCast_zmod_two

/-! ## Section 11: Application - Simultaneous Measurement -/

/-- **Application**: Any X-operator in ker(H^T) can be measured by the hypergraph gauging.

    This is the core of the application: to measure a logical operator P, we need
    P ∈ ker(H^T), which means P commutes with all Z-type hyperedge checks B_e.

    The measurement outcome of the gauging reveals the eigenvalue of P. -/
theorem kernel_operators_measurable (H : Hypergraph) (P : XOperatorSupport H)
    (hker : inKernelOfTranspose H P) :
    commutesWithAllChecks H P := by
  rw [commutes_iff_in_kernel]
  exact hker

/-- **Simultaneous Measurement**: Multiple operators can be measured simultaneously
    if they are all in ker(H^T).

    For operators P₁, P₂, ..., Pₙ ∈ ker(H^T):
    - Each Pᵢ commutes with all B_e (so doesn't disturb the checks)
    - The gauging measurement reveals the eigenvalues of all Pᵢ simultaneously

    This follows immediately from each operator being in the kernel. -/
theorem simultaneous_measurement (H : Hypergraph) {n : ℕ}
    (logicals : Fin n → XOperatorSupport H)
    (hker : ∀ i, inKernelOfTranspose H (logicals i)) :
    ∀ i, commutesWithAllChecks H (logicals i) := by
  intro i
  exact kernel_operators_measurable H (logicals i) (hker i)

/-- **Closure under sum**: The set of measurable operators is closed under sum (XOR).
    If P, Q ∈ ker(H^T), then P + Q ∈ ker(H^T).

    This means ker(H^T) forms a Z₂-vector space of measurable operators. -/
theorem kernel_closed_under_sum (H : Hypergraph) (P Q : XOperatorSupport H)
    (hP : inKernelOfTranspose H P) (hQ : inKernelOfTranspose H Q) :
    inKernelOfTranspose H (fun v => P v + Q v) := by
  unfold inKernelOfTranspose matrixVectorProduct at *
  intro e
  have hPe := hP e
  have hQe := hQ e
  have h_distrib : ∀ v, incidenceMatrix H v e * (P v + Q v) =
      incidenceMatrix H v e * P v + incidenceMatrix H v e * Q v := by intro v; ring
  simp_rw [h_distrib]
  rw [Finset.sum_add_distrib, hPe, hQe]
  ring

/-- **Key Property**: The measurable group = ker(H^T) as sets.
    This is the content of commutes_iff_in_kernel expressed as equality of sets. -/
theorem measurable_eq_kernel_set (H : Hypergraph) :
    {P : XOperatorSupport H | commutesWithAllChecks H P} =
    {P : XOperatorSupport H | inKernelOfTranspose H P} := by
  ext P
  exact commutes_iff_in_kernel H P

/-- **Design Criterion**: To measure a specific set of logical operators {L₁, ..., Lₙ}
    simultaneously, choose a hypergraph H such that L₁, ..., Lₙ ∈ ker(H^T).

    This is achieved when H^T · Lᵢ = 0 for each logical Lᵢ.
    Equivalently: for each hyperedge e, |supp(Lᵢ) ∩ e| is even. -/
theorem design_criterion (H : Hypergraph) (L : XOperatorSupport H) :
    L ∈ measurableGroup H ↔
    ∀ e : H.EdgeIdx,
      Even (Finset.filter (fun v => L v = 1 ∧ v ∈ H.hyperedge e) Finset.univ).card := by
  simp only [measurableGroup, Set.mem_setOf_eq]
  rw [commutes_iff_in_kernel]
  unfold inKernelOfTranspose
  constructor
  · intro hker e
    specialize hker e
    rw [matrixVectorProduct_eq_overlap] at hker
    rw [Nat.even_iff]
    -- hker : (card : ZMod 2) = 0
    have h : ((Finset.filter (fun v => L v = 1 ∧ v ∈ H.hyperedge e)
        Finset.univ).card : ZMod 2).val = 0 := by
      simp only [hker, ZMod.val_zero]
    rw [ZMod.val_natCast] at h
    exact h
  · intro heven e
    rw [matrixVectorProduct_eq_overlap]
    exact (heven e).natCast_zmod_two

/-! ## Section 12: Graph as Special Case -/

/-- A simple graph is a hypergraph where all hyperedges have exactly 2 elements -/
def isSimpleGraph (H : Hypergraph) : Prop :=
  ∀ e, H.edgeSize e = 2

/-- For simple graphs, edge supports always cancel (even size) -/
theorem simpleGraph_edge_cancels (H : Hypergraph) (hsimp : isSimpleGraph H) (e : H.EdgeIdx) :
    hypergraph_productEdgeSupport H e = 0 := by
  apply hypergraph_productEdgeSupport_even
  rw [hsimp e]
  exact ⟨1, rfl⟩

/-- The constraint for simple graphs: product of all A_v = logical L -/
theorem simpleGraph_constraint (H : Hypergraph) (hsimp : isSimpleGraph H) :
    (∀ v, hypergraph_productVertexSupport H v = 1) ∧
    (∀ e, hypergraph_productEdgeSupport H e = 0) := by
  constructor
  · exact fun v => hypergraph_productVertexSupport_eq_one H v
  · exact fun e => simpleGraph_edge_cancels H hsimp e

/-! ## Section 13: Helper Lemmas -/

/-- The all-ones support is always in the measurable group for 2-uniform hypergraphs -/
theorem allOnes_measurable_2uniform (H : Hypergraph) (h2 : isSimpleGraph H) :
    (fun _ => 1) ∈ measurableGroup H := by
  simp only [measurableGroup, Set.mem_setOf_eq]
  rw [commutes_iff_in_kernel]
  unfold inKernelOfTranspose matrixVectorProduct
  intro e
  simp only [incidenceMatrix_apply, mul_one]
  rw [Finset.sum_boole]
  -- sum over e = |e| = 2, which is 0 mod 2
  have hcard : (Finset.filter (fun v => v ∈ H.hyperedge e) Finset.univ).card =
      (H.hyperedge e).card := by
    simp only [Finset.filter_mem_eq_inter, Finset.univ_inter]
  unfold isSimpleGraph at h2
  rw [hcard]
  have h_size := h2 e
  unfold Hypergraph.edgeSize at h_size
  rw [h_size]
  decide

/-- Vertex support characterization -/
@[simp]
theorem hypergraphGaussLaw_vertexSupport (H : Hypergraph) (v w : H.Vertex) :
    (hypergraphGaussLawOperators H v).vertexSupport w = if w = v then 1 else 0 := by
  unfold hypergraphGaussLawOperators mkHypergraphGaussLaw
  rfl

/-- Edge support characterization -/
@[simp]
theorem hypergraphGaussLaw_edgeSupport (H : Hypergraph) (v : H.Vertex) (e : H.EdgeIdx) :
    (hypergraphGaussLawOperators H v).edgeSupport e = if v ∈ H.hyperedge e then 1 else 0 := by
  unfold hypergraphGaussLawOperators mkHypergraphGaussLaw
  rfl

/-- The incidence matrix relates to edge supports -/
theorem incidenceMatrix_eq_edgeSupport (H : Hypergraph) (v : H.Vertex) (e : H.EdgeIdx) :
    incidenceMatrix H v e = (hypergraphGaussLawOperators H v).edgeSupport e := by
  simp only [incidenceMatrix_apply, hypergraphGaussLaw_edgeSupport]

end QEC
