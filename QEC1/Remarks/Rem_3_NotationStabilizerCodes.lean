import QEC1.Remarks.Rem_2_NotationPauliOperators
import Mathlib.Algebra.Group.Subgroup.Lattice
import Mathlib.Data.Fintype.Basic
import Mathlib.Data.Finset.Basic
import Mathlib.Algebra.BigOperators.Group.Finset.Basic

/-!
# Notation: Stabilizer Codes

## Statement
An [[n,k,d]] stabilizer code encodes k logical qubits into n physical qubits with code
distance d. The code is specified by a set of commuting Pauli operators called stabilizer
checks {s_i} that generate the stabilizer group S. The codespace is the simultaneous +1
eigenspace of all stabilizer checks. A logical operator is a Pauli operator that commutes
(in the full Pauli group) with all stabilizers but is not itself a stabilizer (i.e., lies
in the centralizer C(S) but not in S). The distance d is the minimum weight of a
non-trivial logical operator. A quantum low-density parity-check (qLDPC) code is a
stabilizer code where each check has weight bounded by a constant w and each qubit
participates in at most a constant number c of checks.

## Main Results
- `PauliOp.symplecticInner`: symplectic inner product determining commutation
- `PauliOp.PauliCommute`: two Pauli operators commute iff symplectic inner product is 0
- `StabilizerCode`: stabilizer code structure with checks and commutativity condition
- `StabilizerCode.stabilizerGroup`: the stabilizer group generated by the checks
- `StabilizerCode.inCentralizer`: centralizer membership predicate
- `StabilizerCode.isLogicalOp`: predicate for non-trivial logical operators
- `StabilizerCode.distance`: the code distance
- `IsQLDPC`: predicate characterizing quantum LDPC codes

## Corollaries
- Basic properties of symplectic inner product
- Stabilizer group contained in centralizer
- Check weight and qubit degree characterizations
-/

variable {V : Type*}

namespace PauliOp

/-! ## Symplectic inner product

In the full Pauli group (with phases), two Pauli operators P, Q commute iff
their symplectic inner product ⟨P, Q⟩ = Σ_v (P.x_v · Q.z_v + P.z_v · Q.x_v) = 0 in ZMod 2. -/

/-- The symplectic inner product of two Pauli operators, determining commutation in the
    full Pauli group: P and Q commute iff `symplecticInner P Q = 0`. -/
def symplecticInner [Fintype V] (P Q : PauliOp V) : ZMod 2 :=
  ∑ v : V, (P.xVec v * Q.zVec v + P.zVec v * Q.xVec v)

/-- Two Pauli operators commute (in the full Pauli group, including phases) iff
    their symplectic inner product vanishes. -/
def PauliCommute [Fintype V] (P Q : PauliOp V) : Prop :=
  symplecticInner P Q = 0

private lemma zmod2_mul_comm_add_self (a b : ZMod 2) : a * b + b * a = 0 := by
  rw [_root_.mul_comm b a]; exact CharTwo.add_self_eq_zero (a * b)

@[simp]
theorem symplecticInner_self [Fintype V] (P : PauliOp V) :
    symplecticInner P P = 0 := by
  simp only [symplecticInner]
  exact Finset.sum_eq_zero (fun v _ => zmod2_mul_comm_add_self (P.xVec v) (P.zVec v))

theorem pauliCommute_self [Fintype V] (P : PauliOp V) : PauliCommute P P := by
  simp [PauliCommute]

theorem pauliCommute_comm [Fintype V] (P Q : PauliOp V) :
    PauliCommute P Q ↔ PauliCommute Q P := by
  simp only [PauliCommute, symplecticInner]
  constructor <;> intro h <;> [convert h using 1; convert h using 1] <;>
    congr 1 <;> ext v <;> ring

@[simp]
theorem symplecticInner_one_left [Fintype V] (Q : PauliOp V) :
    symplecticInner 1 Q = 0 := by
  simp [symplecticInner]

@[simp]
theorem symplecticInner_one_right [Fintype V] (P : PauliOp V) :
    symplecticInner P 1 = 0 := by
  simp [symplecticInner]

theorem pauliCommute_one_left [Fintype V] (Q : PauliOp V) : PauliCommute 1 Q := by
  simp [PauliCommute]

theorem pauliCommute_one_right [Fintype V] (P : PauliOp V) : PauliCommute P 1 := by
  simp [PauliCommute]

/-- Symplectic inner product is additive in the first argument (over ZMod 2). -/
theorem symplecticInner_mul_left [Fintype V] (P Q R : PauliOp V) :
    symplecticInner (P * Q) R = symplecticInner P R + symplecticInner Q R := by
  simp only [symplecticInner, mul_xVec, mul_zVec, Pi.add_apply, ← Finset.sum_add_distrib]
  congr 1; ext v; ring

/-- Symplectic inner product is additive in the second argument (over ZMod 2). -/
theorem symplecticInner_mul_right [Fintype V] (P Q R : PauliOp V) :
    symplecticInner P (Q * R) = symplecticInner P Q + symplecticInner P R := by
  simp only [symplecticInner, mul_xVec, mul_zVec, Pi.add_apply, ← Finset.sum_add_distrib]
  congr 1; ext v; ring

end PauliOp

/-! ## Stabilizer Code -/

/-- A stabilizer code on qubits labeled by type V, specified by a finite index type I
    for stabilizer checks and a map from I to Pauli operators, with the condition that
    all checks pairwise commute (in the full Pauli group). -/
structure StabilizerCode (V : Type*) [DecidableEq V] [Fintype V] where
  /-- Index type for stabilizer checks -/
  I : Type*
  /-- Finite type instance for check indices -/
  [instFintypeI : Fintype I]
  /-- The stabilizer checks: each index i gives a Pauli operator s_i -/
  check : I → PauliOp V
  /-- All stabilizer checks pairwise commute in the full Pauli group -/
  checks_commute : ∀ i j : I, PauliOp.PauliCommute (check i) (check j)

attribute [instance] StabilizerCode.instFintypeI

namespace StabilizerCode

variable {V : Type*} [DecidableEq V] [Fintype V]

/-! ## The stabilizer group -/

/-- The stabilizer group S is the subgroup of PauliOp V generated by the checks. -/
def stabilizerGroup (C : StabilizerCode V) : Subgroup (PauliOp V) :=
  Subgroup.closure (Set.range C.check)

theorem check_mem_stabilizerGroup (C : StabilizerCode V) (i : C.I) :
    C.check i ∈ C.stabilizerGroup := by
  apply Subgroup.subset_closure
  exact Set.mem_range_self i

/-! ## Centralizer: operators commuting with all stabilizers -/

/-- A Pauli operator P is in the centralizer of the stabilizer code if it commutes
    (in the full Pauli group) with every stabilizer check. -/
def inCentralizer (C : StabilizerCode V) (P : PauliOp V) : Prop :=
  ∀ i : C.I, PauliOp.PauliCommute P (C.check i)

/-- The set of Pauli operators in the centralizer of the stabilizer code. -/
def centralizerSet (C : StabilizerCode V) : Set (PauliOp V) :=
  { P | C.inCentralizer P }

theorem one_inCentralizer (C : StabilizerCode V) : C.inCentralizer 1 := by
  intro i
  exact PauliOp.pauliCommute_one_left _

theorem check_inCentralizer (C : StabilizerCode V) (i : C.I) :
    C.inCentralizer (C.check i) := by
  intro j
  exact C.checks_commute i j

/-! ## Logical operators -/

/-- A Pauli operator P is a non-trivial logical operator if:
    1. It commutes with all stabilizers (is in the centralizer)
    2. It is not in the stabilizer group
    3. It is not the identity -/
def isLogicalOp (C : StabilizerCode V) (P : PauliOp V) : Prop :=
  C.inCentralizer P ∧ P ∉ C.stabilizerGroup ∧ P ≠ 1

theorem isLogicalOp_inCentralizer (C : StabilizerCode V) {P : PauliOp V}
    (h : C.isLogicalOp P) : C.inCentralizer P :=
  h.1

theorem isLogicalOp_not_mem_stabilizerGroup (C : StabilizerCode V) {P : PauliOp V}
    (h : C.isLogicalOp P) : P ∉ C.stabilizerGroup :=
  h.2.1

theorem isLogicalOp_ne_one (C : StabilizerCode V) {P : PauliOp V}
    (h : C.isLogicalOp P) : P ≠ 1 :=
  h.2.2

/-! ## Code distance -/

/-- The code distance is the minimum weight of a non-trivial logical operator.
    Defined as the infimum of the set of weights. Returns 0 if no logical operators exist. -/
noncomputable def distance (C : StabilizerCode V) : ℕ :=
  sInf { w : ℕ | ∃ P : PauliOp V, C.isLogicalOp P ∧ P.weight = w }

/-- The number of physical qubits. -/
def numQubits (_C : StabilizerCode V) : ℕ := Fintype.card V

/-- The number of stabilizer checks. -/
def numChecks (C : StabilizerCode V) : ℕ := Fintype.card C.I

/-! ## Code parameters [[n, k, d]] -/

/-- A stabilizer code has parameters [[n, k, d]] if it has n physical qubits,
    encodes k logical qubits, and has distance d. -/
def HasParameters (C : StabilizerCode V) (n k d : ℕ) : Prop :=
  Fintype.card V = n ∧ n - C.numChecks = k ∧ C.distance = d

/-! ## Check weight and qubit participation -/

/-- The weight of the i-th stabilizer check. -/
def checkWeight (C : StabilizerCode V) (i : C.I) : ℕ :=
  (C.check i).weight

/-- The number of checks that act non-trivially on qubit v. -/
noncomputable def qubitDegree (C : StabilizerCode V) (v : V) : ℕ :=
  (Finset.univ.filter (fun i : C.I => v ∈ (C.check i).support)).card

end StabilizerCode

/-! ## Quantum LDPC codes -/

/-- A quantum low-density parity-check (qLDPC) code is a stabilizer code where:
    1. Each check has weight bounded by a constant w (each check acts on at most w qubits)
    2. Each qubit participates in at most a constant number c of checks -/
def IsQLDPC {V : Type*} [DecidableEq V] [Fintype V]
    (C : StabilizerCode V) (w c : ℕ) : Prop :=
  (∀ i : C.I, C.checkWeight i ≤ w) ∧ (∀ v : V, C.qubitDegree v ≤ c)

/-! ## Basic properties -/

namespace StabilizerCode

variable {V : Type*} [DecidableEq V] [Fintype V]

@[simp]
theorem numQubits_eq (C : StabilizerCode V) : C.numQubits = Fintype.card V := rfl

@[simp]
theorem numChecks_eq (C : StabilizerCode V) : C.numChecks = Fintype.card C.I := rfl

/-- The identity is not a logical operator. -/
theorem not_isLogicalOp_one (C : StabilizerCode V) : ¬C.isLogicalOp 1 := by
  intro ⟨_, _, h3⟩
  exact h3 rfl

/-- The stabilizer group is contained in the centralizer. -/
theorem stabilizerGroup_subset_centralizer (C : StabilizerCode V) :
    ∀ P ∈ C.stabilizerGroup, C.inCentralizer P := by
  intro P hP
  induction hP using Subgroup.closure_induction with
  | mem x hx =>
    obtain ⟨i, rfl⟩ := hx
    exact C.check_inCentralizer i
  | one => exact C.one_inCentralizer
  | mul a b _ _ ha hb =>
    intro i
    simp only [PauliOp.PauliCommute, PauliOp.symplecticInner_mul_left]
    have := ha i
    have := hb i
    simp only [PauliOp.PauliCommute] at *
    rw [‹PauliOp.symplecticInner a (C.check i) = 0›,
        ‹PauliOp.symplecticInner b (C.check i) = 0›, add_zero]
  | inv a _ ha =>
    simp only [PauliOp.inv_eq_self] at ha ⊢
    exact ha

/-- A check is not a logical operator. -/
theorem not_isLogicalOp_check (C : StabilizerCode V) (i : C.I) :
    ¬C.isLogicalOp (C.check i) := by
  intro ⟨_, hNotMem, _⟩
  exact hNotMem (C.check_mem_stabilizerGroup i)

end StabilizerCode
