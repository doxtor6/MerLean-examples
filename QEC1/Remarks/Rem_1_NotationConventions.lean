import Mathlib.Data.ZMod.Basic
import Mathlib.Data.Finset.Basic
import Mathlib.Data.Fintype.Basic
import Mathlib.Data.Finset.Card
import Mathlib.Algebra.Group.Defs
import Mathlib.Order.SymmDiff
import Mathlib.Data.Matrix.Basic
import Mathlib.Data.Complex.Basic
import Mathlib.Tactic

/-!
# Notation Conventions (Remark 1)

## Statement
Throughout this work, we use the following notation and conventions:

(i) **Pauli operators**: For a qubit system on n qubits, the Pauli group is generated by
    single-qubit operators X_i, Y_i, Z_i for i âˆˆ {1, ..., n} satisfying X_iÂ² = Y_iÂ² = Z_iÂ² = I,
    X_i Y_i = i Z_i, and operators on different qubits commute.

(ii) **Stabilizer code**: An [[n, k, d]] stabilizer code is a 2^k-dimensional subspace of
     the n-qubit Hilbert space (â„‚Â²)^âŠ—n defined as the simultaneous +1 eigenspace of an
     abelian subgroup S of the n-qubit Pauli group, where -I âˆ‰ S.

(iii) **Code distance**: The distance d is the minimum weight of a Pauli operator that
      commutes with all stabilizers but is not itself a stabilizer.

(iv) **Support notation**: For a Pauli operator P = i^Ïƒ âˆ_v X_v^{a_v} Z_v^{b_v}, the
     X-type support is S_X(P) = {v : a_v = 1} and the Z-type support is S_Z(P) = {v : b_v = 1}.

(v) **Zâ‚‚-arithmetic**: All sums of binary vectors are computed modulo 2. We identify a subset
    S âŠ† V with the binary vector (ðŸ™_S)_v = [v âˆˆ S] âˆˆ Zâ‚‚^|V|.

## Main Results
**Main Definition** (`PauliOp`): Single-qubit Pauli operators {I, X, Y, Z}
**Main Structure** (`PauliString`): n-qubit Pauli operators as products of single-qubit Paulis
**Key Property**: Support functions for X-type and Z-type qubits

## File Structure
1. Single-Qubit Pauli Operators: Basic I, X, Y, Z definitions
2. n-Qubit Pauli Strings: Tensor products of single-qubit Paulis
3. Support Functions: X-type and Z-type support for Pauli strings
4. Zâ‚‚ Arithmetic: Subset identification and modular arithmetic
5. Stabilizer Code Parameters: Code parameters [[n, k, d]]
-/

namespace QEC

/-! ## Section 1: Single-Qubit Pauli Operators -/

/-- The four single-qubit Pauli operators: Identity, X, Y, Z -/
inductive PauliOp : Type where
  | I : PauliOp  -- Identity
  | X : PauliOp  -- Pauli-X (bit flip)
  | Y : PauliOp  -- Pauli-Y
  | Z : PauliOp  -- Pauli-Z (phase flip)
  deriving DecidableEq, Repr

namespace PauliOp

/-- Pauli operators form a finite type with 4 elements -/
instance : Fintype PauliOp where
  elems := {I, X, Y, Z}
  complete := fun x => by cases x <;> simp

/-- The number of Pauli operators is 4 -/
theorem card_pauliOp : Fintype.card PauliOp = 4 := by
  rfl

/-- Multiplication of single-qubit Pauli operators (ignoring phase) -/
def mul : PauliOp â†’ PauliOp â†’ PauliOp
  | I, p => p
  | p, I => p
  | X, X => I
  | Y, Y => I
  | Z, Z => I
  | X, Y => Z
  | Y, X => Z
  | Y, Z => X
  | Z, Y => X
  | Z, X => Y
  | X, Z => Y

/-- Identity is left neutral for Pauli multiplication -/
theorem mul_I_left (p : PauliOp) : mul I p = p := by
  cases p <;> rfl

/-- Identity is right neutral for Pauli multiplication -/
theorem mul_I_right (p : PauliOp) : mul p I = p := by
  cases p <;> rfl

/-- Each Pauli operator squares to I (PÂ² = I) -/
theorem sq_eq_I (p : PauliOp) : mul p p = I := by
  cases p <;> rfl

/-- Check if a Pauli operator has X component -/
def hasX : PauliOp â†’ Bool
  | I => false
  | X => true
  | Y => true  -- Y = iXZ, has X component
  | Z => false

/-- Check if a Pauli operator has Z component -/
def hasZ : PauliOp â†’ Bool
  | I => false
  | X => false
  | Y => true  -- Y = iXZ, has Z component
  | Z => true

/-- Y has both X and Z components -/
theorem Y_has_both : hasX Y = true âˆ§ hasZ Y = true := âŸ¨rfl, rflâŸ©

/-- I has neither X nor Z component -/
theorem I_has_neither : hasX I = false âˆ§ hasZ I = false := âŸ¨rfl, rflâŸ©

end PauliOp

/-! ## Section 2: n-Qubit Pauli Strings -/

/-- An n-qubit Pauli string is a function from qubit indices to single-qubit Paulis.
    This represents P = âˆ_v P_v where P_v âˆˆ {I, X, Y, Z}.
    We use Fin n for qubit indices (0-indexed, representing qubits 1 to n). -/
def PauliString (n : â„•) := Fin n â†’ PauliOp

namespace PauliString

variable {n : â„•}

/-- The identity Pauli string (all I's) -/
def identity (n : â„•) : PauliString n := fun _ => PauliOp.I

/-- A single-site X operator at position i -/
def singleX (i : Fin n) : PauliString n :=
  fun j => if j = i then PauliOp.X else PauliOp.I

/-- A single-site Y operator at position i -/
def singleY (i : Fin n) : PauliString n :=
  fun j => if j = i then PauliOp.Y else PauliOp.I

/-- A single-site Z operator at position i -/
def singleZ (i : Fin n) : PauliString n :=
  fun j => if j = i then PauliOp.Z else PauliOp.I

/-- Pointwise multiplication of Pauli strings (ignoring global phase) -/
def mul (P Q : PauliString n) : PauliString n :=
  fun i => PauliOp.mul (P i) (Q i)

/-- Identity is left neutral -/
theorem mul_identity_left (P : PauliString n) : mul (identity n) P = P := by
  funext i
  simp only [mul, identity, PauliOp.mul_I_left]

/-- Identity is right neutral -/
theorem mul_identity_right (P : PauliString n) : mul P (identity n) = P := by
  funext i
  simp only [mul, identity, PauliOp.mul_I_right]

/-- Each Pauli string squares to identity (PÂ² = I) -/
theorem sq_eq_identity (P : PauliString n) : mul P P = identity n := by
  funext i
  simp only [mul, identity, PauliOp.sq_eq_I]

instance : DecidableEq (PauliString n) :=
  inferInstanceAs (DecidableEq (Fin n â†’ PauliOp))

instance [NeZero n] : Fintype (PauliString n) :=
  inferInstanceAs (Fintype (Fin n â†’ PauliOp))

end PauliString

/-! ## Section 3: Support Functions -/

/-- The X-type support of a Pauli string: qubits where P has X or Y -/
def supportX (P : PauliString n) : Finset (Fin n) :=
  Finset.filter (fun i => (P i).hasX = true) Finset.univ

/-- The Z-type support of a Pauli string: qubits where P has Z or Y -/
def supportZ (P : PauliString n) : Finset (Fin n) :=
  Finset.filter (fun i => (P i).hasZ = true) Finset.univ

/-- The weight of a Pauli string: number of non-identity sites -/
def weight (P : PauliString n) : â„• :=
  Finset.card (Finset.filter (fun i => P i â‰  PauliOp.I) Finset.univ)

/-- The identity has empty X-support -/
theorem supportX_identity : supportX (PauliString.identity n) = âˆ… := by
  simp only [supportX, PauliString.identity, PauliOp.hasX, Finset.filter_eq_empty_iff]
  intro _ _
  decide

/-- The identity has empty Z-support -/
theorem supportZ_identity : supportZ (PauliString.identity n) = âˆ… := by
  simp only [supportZ, PauliString.identity, PauliOp.hasZ, Finset.filter_eq_empty_iff]
  intro _ _
  decide

/-- The identity has weight 0 -/
theorem weight_identity : weight (PauliString.identity n) = 0 := by
  simp only [weight, PauliString.identity, ne_eq, not_true_eq_false, Finset.filter_false,
    Finset.card_empty]

/-- A single X operator has X-support = {i} -/
theorem supportX_singleX (i : Fin n) : supportX (PauliString.singleX i) = {i} := by
  ext j
  simp only [supportX, PauliString.singleX, Finset.mem_filter, Finset.mem_univ, true_and,
    Finset.mem_singleton]
  constructor
  Â· intro h
    by_cases heq : j = i
    Â· exact heq
    Â· simp only [heq, â†“reduceIte, PauliOp.hasX] at h
      exact absurd h (by decide)
  Â· intro h
    simp only [h, â†“reduceIte, PauliOp.hasX]

/-- A single Z operator has Z-support = {i} -/
theorem supportZ_singleZ (i : Fin n) : supportZ (PauliString.singleZ i) = {i} := by
  ext j
  simp only [supportZ, PauliString.singleZ, Finset.mem_filter, Finset.mem_univ, true_and,
    Finset.mem_singleton]
  constructor
  Â· intro h
    by_cases heq : j = i
    Â· exact heq
    Â· simp only [heq, â†“reduceIte, PauliOp.hasZ] at h
      exact absurd h (by decide)
  Â· intro h
    simp only [h, â†“reduceIte, PauliOp.hasZ]

/-- A single Y operator has both X and Z support = {i} -/
theorem supportX_singleY (i : Fin n) : supportX (PauliString.singleY i) = {i} := by
  ext j
  simp only [supportX, PauliString.singleY, Finset.mem_filter, Finset.mem_univ, true_and,
    Finset.mem_singleton]
  constructor
  Â· intro h
    by_cases heq : j = i
    Â· exact heq
    Â· simp only [heq, â†“reduceIte, PauliOp.hasX] at h
      exact absurd h (by decide)
  Â· intro h
    simp only [h, â†“reduceIte, PauliOp.hasX]

theorem supportZ_singleY (i : Fin n) : supportZ (PauliString.singleY i) = {i} := by
  ext j
  simp only [supportZ, PauliString.singleY, Finset.mem_filter, Finset.mem_univ, true_and,
    Finset.mem_singleton]
  constructor
  Â· intro h
    by_cases heq : j = i
    Â· exact heq
    Â· simp only [heq, â†“reduceIte, PauliOp.hasZ] at h
      exact absurd h (by decide)
  Â· intro h
    simp only [h, â†“reduceIte, PauliOp.hasZ]

/-! ## Section 4: Zâ‚‚ Arithmetic and Subset Identification -/

/-- Convert a subset (Finset) to a binary indicator vector in ZMod 2 -/
def subsetToVector {V : Type*} [DecidableEq V] [Fintype V] (S : Finset V) : V â†’ ZMod 2 :=
  fun v => if v âˆˆ S then 1 else 0

/-- The indicator of a subset is 1 iff element is in the subset -/
theorem subsetToVector_mem {V : Type*} [DecidableEq V] [Fintype V] (S : Finset V) (v : V) :
    subsetToVector S v = 1 â†” v âˆˆ S := by
  simp only [subsetToVector]
  constructor
  Â· intro h
    by_cases hmem : v âˆˆ S
    Â· exact hmem
    Â· simp only [hmem, â†“reduceIte] at h
      exact absurd h.symm (by decide)
  Â· intro h
    simp only [h, â†“reduceIte]

/-- The indicator of a subset is 0 iff element is not in the subset -/
theorem subsetToVector_not_mem {V : Type*} [DecidableEq V] [Fintype V] (S : Finset V) (v : V) :
    subsetToVector S v = 0 â†” v âˆ‰ S := by
  simp only [subsetToVector]
  constructor
  Â· intro h
    by_cases hmem : v âˆˆ S
    Â· simp only [hmem, â†“reduceIte] at h
      exact absurd h (by decide)
    Â· exact hmem
  Â· intro h
    simp only [h, â†“reduceIte]

/-- Symmetric difference of subsets corresponds to addition in ZMod 2 -/
theorem subsetToVector_symmDiff {V : Type*} [DecidableEq V] [Fintype V]
    (S T : Finset V) (v : V) :
    subsetToVector (symmDiff S T) v = subsetToVector S v + subsetToVector T v := by
  simp only [subsetToVector, Finset.mem_symmDiff]
  by_cases hS : v âˆˆ S <;> by_cases hT : v âˆˆ T
  Â· -- v âˆˆ S, v âˆˆ T: symmDiff excludes v, 1 + 1 = 0 in ZMod 2
    simp only [hS, hT, â†“reduceIte, true_and, not_true_eq_false, or_false]
    decide
  Â· -- v âˆˆ S, v âˆ‰ T: symmDiff includes v, 1 + 0 = 1
    simp only [hS, hT, â†“reduceIte, true_and, not_false_eq_true, add_zero]
    decide
  Â· -- v âˆ‰ S, v âˆˆ T: symmDiff includes v, 0 + 1 = 1
    simp only [hS, hT, â†“reduceIte, false_and, zero_add]
    decide
  Â· -- v âˆ‰ S, v âˆ‰ T: symmDiff excludes v, 0 + 0 = 0
    simp only [hS, hT, â†“reduceIte, false_and, false_or, zero_add]

/-- Empty set maps to zero vector -/
theorem subsetToVector_empty {V : Type*} [DecidableEq V] [Fintype V] (v : V) :
    subsetToVector (âˆ… : Finset V) v = 0 := by
  simp only [subsetToVector, Finset.notMem_empty, â†“reduceIte]

/-- Intersection corresponds to multiplication in ZMod 2 -/
theorem subsetToVector_inter {V : Type*} [DecidableEq V] [Fintype V]
    (S T : Finset V) (v : V) :
    subsetToVector (S âˆ© T) v = subsetToVector S v * subsetToVector T v := by
  simp only [subsetToVector, Finset.mem_inter]
  by_cases hS : v âˆˆ S <;> by_cases hT : v âˆˆ T <;> simp only [hS, hT, â†“reduceIte, and_self,
    and_true, and_false, mul_one, mul_zero]

/-! ## Section 5: Stabilizer Code Parameters -/

/-- Parameters of a stabilizer code: [[n, k, d]] notation
    - n: number of physical qubits
    - k: number of logical qubits (code encodes 2^k dimensional space)
    - d: code distance -/
structure StabilizerCodeParams where
  n : â„•  -- physical qubits
  k : â„•  -- logical qubits
  d : â„•  -- code distance
  k_le_n : k â‰¤ n  -- can't encode more logical qubits than physical

namespace StabilizerCodeParams

/-- The dimension of the code space is 2^k -/
def codeDimension (params : StabilizerCodeParams) : â„• := 2 ^ params.k

/-- Number of independent stabilizer generators is n - k -/
def numStabilizerGenerators (params : StabilizerCodeParams) : â„• := params.n - params.k

/-- The [[7, 1, 3]] Steane code parameters -/
def steaneCode : StabilizerCodeParams where
  n := 7
  k := 1
  d := 3
  k_le_n := by omega

/-- The [[5, 1, 3]] perfect code parameters -/
def perfectCode : StabilizerCodeParams where
  n := 5
  k := 1
  d := 3
  k_le_n := by omega

/-- A code can correct up to âŒŠ(d-1)/2âŒ‹ errors -/
def correctableErrors (params : StabilizerCodeParams) : â„• := (params.d - 1) / 2

/-- Steane code can correct 1 error -/
theorem steaneCode_corrects_one : steaneCode.correctableErrors = 1 := by
  rfl

/-- Perfect code can correct 1 error -/
theorem perfectCode_corrects_one : perfectCode.correctableErrors = 1 := by
  rfl

end StabilizerCodeParams

/-! ## Section 6: Commutation Relations -/

/-- Two single-qubit Paulis commute iff they are equal or one is identity -/
def singleCommute (P Q : PauliOp) : Bool :=
  match P, Q with
  | PauliOp.I, _ => true
  | _, PauliOp.I => true
  | PauliOp.X, PauliOp.X => true
  | PauliOp.Y, PauliOp.Y => true
  | PauliOp.Z, PauliOp.Z => true
  | _, _ => false

/-- The overlap count: number of positions where both have non-trivial, non-commuting Paulis -/
def anticommutingOverlap (P Q : PauliString n) : â„• :=
  Finset.card (Finset.filter (fun i => singleCommute (P i) (Q i) = false) Finset.univ)

/-- Two Pauli strings commute iff their anticommuting overlap is even -/
def pauliStringsCommute (P Q : PauliString n) : Prop :=
  anticommutingOverlap P Q % 2 = 0

/-- The identity commutes with everything -/
theorem identity_commutes (P : PauliString n) :
    pauliStringsCommute (PauliString.identity n) P := by
  unfold pauliStringsCommute anticommutingOverlap
  simp only [PauliString.identity, singleCommute]
  convert Nat.zero_mod 2
  rw [Finset.card_eq_zero, Finset.filter_eq_empty_iff]
  intro _ _
  decide

/-- Every Pauli string commutes with itself -/
theorem self_commutes (P : PauliString n) : pauliStringsCommute P P := by
  unfold pauliStringsCommute anticommutingOverlap
  convert Nat.zero_mod 2
  rw [Finset.card_eq_zero, Finset.filter_eq_empty_iff]
  intro i _
  simp only [singleCommute, Bool.not_eq_false]
  cases P i <;> rfl

end QEC
