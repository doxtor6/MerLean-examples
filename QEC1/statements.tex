\documentclass[11pt]{article}

\usepackage[utf8]{inputenc}
\usepackage{amsmath,amssymb}
\usepackage{amsthm}
\usepackage{mathtools}
\usepackage{braket}
\usepackage{dsfont}
\usepackage{enumitem}
\usepackage[margin=1in]{geometry}
\usepackage{hyperref}

% Theorem environments with shared counter for formalization order
\newtheorem{formalstatement}{Statement}
\newtheorem*{theorem*}{Theorem}
\newtheorem*{lemma*}{Lemma}
\newtheorem*{corollary*}{Corollary}
\newtheorem*{proposition*}{Proposition}
\theoremstyle{definition}
\newtheorem*{definition*}{Definition}
\newtheorem*{remark*}{Remark}
\newtheorem*{preliminary*}{Preliminary}

% Common math commands
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\F}{\mathbb{F}}
\newcommand{\C}{\mathbb{C}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\id}{\mathds{1}}

\title{Extracted Formal Statements\\[0.5em]\large For LEAN 4 + Mathlib Formalization}
\date{\today}

\begin{document}
\maketitle

\begin{abstract}
This document contains 66 formal statements extracted from the source paper,
ordered by \textbf{formalization dependency} (statements appear after their dependencies).
Each statement is numbered in the order it should be formalized.
\end{abstract}

\tableofcontents
\newpage

\section{Formal Statements (in Formalization Order)}

\subsection{Rem_1: NotationConventions}
\label{Rem_1}

\noindent\textbf{Type:} Remark \hfill \textbf{Formalization Order:} 1/66

\begin{remark*}[NotationConventions]
Throughout this work, we use the following notation and conventions:

(i) **Pauli operators**: For a qubit system on $n$ qubits, the Pauli group is generated by single-qubit operators $X_i, Y_i, Z_i$ for $i \in \{1, \ldots, n\}$ satisfying $X_i^2 = Y_i^2 = Z_i^2 = I$, $X_i Y_i = i Z_i$, and operators on different qubits commute.

(ii) **Stabilizer code**: An $[[n, k, d]]$ stabilizer code is a $2^k$-dimensional subspace of the $n$-qubit Hilbert space $(\mathbb{C}^2)^{\otimes n}$ defined as the simultaneous $+1$ eigenspace of an abelian subgroup $\mathcal{S}$ of the $n$-qubit Pauli group, where $-I \notin \mathcal{S}$. The parameters are: $n$ = number of physical qubits, $k$ = number of encoded logical qubits, $d$ = code distance.

(iii) **Code distance**: The distance $d$ is the minimum weight of a Pauli operator that commutes with all stabilizers but is not itself a stabilizer: $d = \min\{|P| : P \in N(\mathcal{S}) \setminus \mathcal{S}\}$, where $|P|$ denotes the weight (number of non-identity tensor factors) and $N(\mathcal{S})$ is the normalizer of $\mathcal{S}$.

(iv) **Support notation**: For a Pauli operator $P = i^\sigma \prod_v X_v^{a_v} Z_v^{b_v}$, the X-type support is $\mathcal{S}_X(P) = \{v : a_v = 1\}$ and the Z-type support is $\mathcal{S}_Z(P) = \{v : b_v = 1\}$. Note: $Y_v = i X_v Z_v$, so $Y$ contributes to both supports.

(v) **$\mathbb{Z}_2$-arithmetic**: All sums of binary vectors are computed modulo 2. We identify a subset $S \subseteq V$ with the binary vector $(\mathbf{1}_S)_v = [v \in S] \in \mathbb{Z}_2^{|V|}$.
\end{remark*}

\vspace{1em}
\hrule
\vspace{1em}

\subsection{Def_1: StabilizerCode}
\label{Def_1}

\noindent\textbf{Type:} Definition \hfill \textbf{Formalization Order:} 2/66

\noindent\textbf{Dependencies:} \hyperref[Rem_1]{Rem_1}

\begin{definition*}[StabilizerCode]
Let $n, k, d \in \mathbb{N}$ with $k < n$. An **$[[n, k, d]]$ stabilizer code** is specified by the following data:

(i) **Physical qubits**: A set of $n$ qubits indexed by $\{1, \ldots, n\}$, with Hilbert space $\mathcal{H} = (\mathbb{C}^2)^{\otimes n}$.

(ii) **Check operators**: A set of Pauli operators $\{s_i\}_{i=1}^{n-k}$ called stabilizer checks, where each $s_i = i^{\sigma_i} \prod_{v \in \mathcal{S}_{X,i}} X_v \prod_{v \in \mathcal{S}_{Z,i}} Z_v$ for some $\sigma_i \in \{0, 1, 2, 3\}$ and subsets $\mathcal{S}_{X,i}, \mathcal{S}_{Z,i} \subseteq \{1, \ldots, n\}$.

(iii) **Commutativity**: The checks mutually commute: $[s_i, s_j] = 0$ for all $i, j$, which is equivalent to $|\mathcal{S}_{X,i} \cap \mathcal{S}_{Z,j}| + |\mathcal{S}_{Z,i} \cap \mathcal{S}_{X,j}| \equiv 0 \pmod{2}$.

(iv) **Independence**: The checks are independent: $\prod_{i \in T} s_i = I$ implies $T = \emptyset$.

(v) **Code space**: The code space is $\mathcal{C} = \{|\psi\rangle \in \mathcal{H} : s_i|\psi\rangle = |\psi\rangle \text{ for all } i\}$, which has dimension $\dim(\mathcal{C}) = 2^k$.

(vi) **Distance condition**: Every Pauli operator $P$ that commutes with all $s_i$ but is not a product of checks has weight $|P| \geq d$.

The code is called **LDPC** (low-density parity-check) if there exist constants $w, \Delta$ such that each check $s_i$ has weight $\leq w$ and each qubit participates in $\leq \Delta$ checks.
\end{definition*}

\vspace{1em}
\hrule
\vspace{1em}

\subsection{Def_2: LogicalOperator}
\label{Def_2}

\noindent\textbf{Type:} Definition \hfill \textbf{Formalization Order:} 3/66

\noindent\textbf{Dependencies:} \hyperref[Def_1]{Def_1}

\begin{definition*}[LogicalOperator]
Let $\mathcal{C}$ be an $[[n, k, d]]$ stabilizer code with check operators $\{s_i\}$.

A **logical operator** is a Pauli operator $L$ such that:
(i) $L$ commutes with all stabilizer checks: $[L, s_i] = 0$ for all $i$.
(ii) $L$ is not a product of stabilizer checks: $L \notin \langle s_1, \ldots, s_{n-k} \rangle$.

A **logical representative** is a specific choice of Pauli operator $L$ representing a logical operator. Two logical representatives $L$ and $L'$ are **equivalent** if $L' = L \cdot \prod_{i \in T} s_i$ for some $T \subseteq \{1, \ldots, n-k\}$.

The **weight** of a logical operator is $|L| = |\mathcal{S}_X(L) \cup \mathcal{S}_Z(L)|$, the number of qubits on which $L$ acts non-trivially.

The code distance satisfies $d = \min\{|L| : L \text{ is a logical operator}\}$.

By choosing an appropriate single-qubit basis for each physical qubit, any logical operator can be assumed to be **X-type**, i.e., $L = \prod_{v \in \mathcal{L}} X_v$ for some $\mathcal{L} \subseteq \{1, \ldots, n\}$.
\end{definition*}

\vspace{1em}
\hrule
\vspace{1em}

\subsection{Def_3: GaugingGraph}
\label{Def_3}

\noindent\textbf{Type:} Definition \hfill \textbf{Formalization Order:} 4/66

\noindent\textbf{Dependencies:} \hyperref[Def_1]{Def_1}, \hyperref[Def_2]{Def_2}

\begin{definition*}[GaugingGraph]
Let $\mathcal{C}$ be an $[[n, k, d]]$ stabilizer code and let $L = \prod_{v \in \mathcal{L}} X_v$ be an X-type logical operator with support $\mathcal{L}$.

A **gauging graph** for $L$ is a connected graph $G = (V, E)$ such that:
(i) **Vertices**: $V \supseteq \mathcal{L}$, with an isomorphism identifying $\mathcal{L}$ with a subset of vertices.
(ii) **Connectivity**: $G$ is connected.
(iii) **Edge qubits**: Each edge $e \in E$ corresponds to an auxiliary qubit.

The graph $G$ may contain **dummy vertices** $V \setminus \mathcal{L}$, which correspond to auxiliary qubits initialized in the $|+\rangle$ state and on which $X$ is measured with certain outcome $+1$.

**Graph parameters**:
- $|V|$ = number of vertices (includes support of $L$ plus dummy vertices)
- $|E|$ = number of edges (equals number of auxiliary qubits)
- The **cycle rank** of $G$ is $|E| - |V| + 1$ (number of independent cycles)
\end{definition*}

\vspace{1em}
\hrule
\vspace{1em}

\subsection{Def_4: ChainSpacesBoundaryMaps}
\label{Def_4}

\noindent\textbf{Type:} Definition \hfill \textbf{Formalization Order:} 5/66

\noindent\textbf{Dependencies:} \hyperref[Def_3]{Def_3}

\begin{definition*}[ChainSpacesBoundaryMaps]
Let $G = (V, E)$ be a finite connected graph and let $C$ be a chosen collection of generating cycles for $G$.

We define the following $\mathbb{Z}_2$-vector spaces and linear maps:

(i) **Chain spaces**:
- $C_0(G; \mathbb{Z}_2) = \mathbb{Z}_2^V$ is the space of **0-chains** (formal sums of vertices)
- $C_1(G; \mathbb{Z}_2) = \mathbb{Z}_2^E$ is the space of **1-chains** (formal sums of edges)
- $C_2(G; \mathbb{Z}_2) = \mathbb{Z}_2^C$ is the space of **2-chains** (formal sums of cycles)

We identify a subset $S \subseteq V$ with the 0-chain $\sum_{v \in S} v \in C_0$.

(ii) **Boundary map** $\partial_1: C_1(G; \mathbb{Z}_2) \to C_0(G; \mathbb{Z}_2)$ is the $\mathbb{Z}_2$-linear map defined on basis elements by:
$$\partial_1(e) = v + v'$$
where $e = \{v, v'\}$ is an edge with endpoints $v, v'$. For an edge-path $\gamma = \{e_1, \ldots, e_m\} \subseteq E$: $\partial_1(\gamma) = \sum_{e \in \gamma} \partial_1(e)$.

(iii) **Second boundary map** $\partial_2: C_2(G; \mathbb{Z}_2) \to C_1(G; \mathbb{Z}_2)$ is defined by:
$$\partial_2(c) = \sum_{e \in c} e$$
for a cycle $c$ viewed as a set of edges.

(iv) **Coboundary maps** are the transposes:
- $\delta_0 = \partial_1^T: C_0(G; \mathbb{Z}_2) \to C_1(G; \mathbb{Z}_2)$ satisfies $\delta_0(v) = \sum_{e \ni v} e$ (sum over edges incident to $v$)
- $\delta_1 = \partial_2^T: C_1(G; \mathbb{Z}_2) \to C_2(G; \mathbb{Z}_2)$ satisfies $\delta_1(e) = \sum_{c \ni e} c$ (sum over cycles containing $e$)

(v) **Key identity**: $\partial_1 \circ \partial_2 = 0$, i.e., the boundary of a cycle is zero.
\end{definition*}

\vspace{1em}
\hrule
\vspace{1em}

\subsection{Rem_2: ExactnessOfChainComplex}
\label{Rem_2}

\noindent\textbf{Type:} Remark \hfill \textbf{Formalization Order:} 6/66

\noindent\textbf{Dependencies:} \hyperref[Def_4]{Def_4}

\begin{remark*}[ExactnessOfChainComplex]
Let $G = (V, E)$ be a connected graph with a chosen generating set of cycles $C$.

The chain complex $C_2 \xrightarrow{\partial_2} C_1 \xrightarrow{\partial_1} C_0$ satisfies:

(i) **Exactness at $C_1$**: If $C$ is a generating set of cycles, then $\ker(\partial_1) = \mathrm{im}(\partial_2)$. This means: an edge-set $\gamma \subseteq E$ satisfies $\partial_1(\gamma) = 0$ (i.e., every vertex has even degree in $\gamma$) if and only if $\gamma$ is a $\mathbb{Z}_2$-linear combination of the generating cycles.

(ii) **Exactness at $C_0$ (almost)**: $\mathrm{im}(\partial_1) = \{c \in C_0 : |c| \equiv 0 \pmod{2}\}$, the set of 0-chains with even cardinality. Equivalently, $\ker(\delta_0) = \mathbb{Z}_2 \cdot \mathbf{1}_V$ (the all-ones vector) for connected $G$.

(iii) **Dual exactness**: For the coboundary sequence $C_0 \xrightarrow{\delta_0} C_1 \xrightarrow{\delta_1} C_2$:
- $\ker(\delta_0) = \mathbb{Z}_2 \cdot \mathbf{1}_V$ (all vertices or no vertices)
- $\ker(\delta_1) = \mathrm{im}(\delta_0)$ when $C$ generates all cycles

These exactness conditions are crucial for proving properties of the deformed code.
\end{remark*}

\vspace{1em}
\hrule
\vspace{1em}

\subsection{Def_5: CheegerConstant}
\label{Def_5}

\noindent\textbf{Type:} Definition \hfill \textbf{Formalization Order:} 7/66

\noindent\textbf{Dependencies:} \hyperref[Def_3]{Def_3}

\begin{definition*}[CheegerConstant]
Let $G = (V, E)$ be a finite graph with vertex set $V$ and edge set $E$.

For a subset $S \subseteq V$, the **edge boundary** of $S$ is:
$$\delta(S) = \{e \in E : |e \cap S| = 1\}$$
the set of edges with exactly one endpoint in $S$.

The **Cheeger constant** (also called **isoperimetric number** or **expansion**) of $G$ is:
$$h(G) = \min_{\substack{S \subseteq V \\ 0 < |S| \leq |V|/2}} \frac{|\delta(S)|}{|S|}$$

**Properties**:
(i) $h(G) \geq 0$ with equality iff $G$ is disconnected.
(ii) For any $S$ with $0 < |S| \leq |V|/2$: $|\delta(S)| \geq h(G) \cdot |S|$.
(iii) A graph is called an **expander** if $h(G) \geq c$ for some constant $c > 0$ independent of $|V|$.
(iv) $h(G) \leq \min_v \deg(v)$ where $\deg(v)$ is the degree of vertex $v$.

**Equivalently**, $h(G)$ measures how 'well-connected' the graph is: a larger Cheeger constant means the graph cannot be easily partitioned into disconnected pieces.
\end{definition*}

\vspace{1em}
\hrule
\vspace{1em}

\subsection{Def_6: GaussLawOperators}
\label{Def_6}

\noindent\textbf{Type:} Definition \hfill \textbf{Formalization Order:} 8/66

\noindent\textbf{Dependencies:} \hyperref[Def_3]{Def_3}, \hyperref[Def_4]{Def_4}

\begin{definition*}[GaussLawOperators]
Let $\mathcal{C}$ be an $[[n, k, d]]$ stabilizer code, $L = \prod_{v \in \mathcal{L}} X_v$ an X-type logical operator, and $G = (V, E)$ a gauging graph for $L$.

The **Gauss's law operators** are the set $\mathcal{A} = \{A_v\}_{v \in V}$ where each $A_v$ is defined as:
$$A_v = X_v \prod_{e \ni v} X_e$$

Here:
- $X_v$ acts on the vertex qubit (the original code qubit if $v \in \mathcal{L}$, or an auxiliary qubit initialized in $|+\rangle$ if $v$ is a dummy vertex)
- $X_e$ acts on the auxiliary edge qubit corresponding to edge $e$
- The product $\prod_{e \ni v}$ is over all edges incident to vertex $v$

**Properties**:
(i) Each $A_v$ is Hermitian with eigenvalues $\pm 1$.
(ii) The operators $\{A_v\}$ mutually commute: $[A_v, A_{v'}] = 0$ for all $v, v' \in V$.
(iii) They satisfy the constraint: $\prod_{v \in V} A_v = L \cdot \prod_{e \in E} X_e^2 = L$ (since $X_e^2 = I$).
(iv) The $A_v$ generate an abelian group of order $2^{|V|-1}$ (one constraint reduces independence).
\end{definition*}

\vspace{1em}
\hrule
\vspace{1em}

\subsection{Def_7: FluxOperators}
\label{Def_7}

\noindent\textbf{Type:} Definition \hfill \textbf{Formalization Order:} 9/66

\noindent\textbf{Dependencies:} \hyperref[Def_4]{Def_4}, \hyperref[Def_6]{Def_6}

\begin{definition*}[FluxOperators]
Let $\mathcal{C}$ be an $[[n, k, d]]$ stabilizer code, $L$ an X-type logical operator, $G = (V, E)$ a gauging graph, and $C = \{p_1, \ldots, p_c\}$ a generating set of cycles for $G$.

The **flux operators** are the set $\mathcal{B} = \{B_p\}_{p \in C}$ where each $B_p$ is defined as:
$$B_p = \prod_{e \in p} Z_e$$

Here:
- $p \subseteq E$ is a cycle in $G$ (a set of edges forming a closed path)
- $Z_e$ acts on the auxiliary edge qubit corresponding to edge $e$
- The product is over all edges in the cycle $p$

**Properties**:
(i) Each $B_p$ is Hermitian with eigenvalues $\pm 1$.
(ii) The operators $\{B_p\}$ mutually commute: $[B_p, B_{p'}] = 0$ for all $p, p' \in C$.
(iii) $[A_v, B_p] = 0$ for all $v \in V$ and $p \in C$.
   *Verification*: $A_v B_p A_v^{-1} = B_p \cdot (-1)^{|\{e \in p : v \in e\}|}$. Since $p$ is a cycle, each vertex appears in an even number of edges of $p$, so the exponent is even.
(iv) For the generating set $C$, the number of independent $B_p$ operators is $|C| = |E| - |V| + 1$ (the cycle rank of $G$).
\end{definition*}

\vspace{1em}
\hrule
\vspace{1em}

\subsection{Def_8: DeformedOperator}
\label{Def_8}

\noindent\textbf{Type:} Definition \hfill \textbf{Formalization Order:} 10/66

\noindent\textbf{Dependencies:} \hyperref[Def_4]{Def_4}, \hyperref[Def_6]{Def_6}, \hyperref[Def_7]{Def_7}

\begin{definition*}[DeformedOperator]
Let $\mathcal{C}$ be an $[[n, k, d]]$ stabilizer code with checks $\{s_i\}$, let $L = \prod_{v \in \mathcal{L}} X_v$ be an X-type logical operator, and let $G = (V, E)$ be a gauging graph for $L$.

A Pauli operator $P$ on the original code that **commutes with $L$** can be written as:
$$P = i^\sigma \prod_{v \in \mathcal{S}_X} X_v \prod_{v \in \mathcal{S}_Z} Z_v$$
where $|\mathcal{S}_Z \cap \mathcal{L}| \equiv 0 \pmod{2}$ (even overlap with $\mathcal{L}$ in Z-support).

The **deformed operator** $\tilde{P}$ is defined as:
$$\tilde{P} = P \cdot \prod_{e \in \gamma} Z_e$$
where $\gamma \subseteq E$ is an edge-path in $G$ satisfying the **boundary condition**:
$$\partial_1(\gamma) = \mathcal{S}_Z(P) \cap V$$

Explicitly, $\partial_1(\gamma) = \mathcal{S}_Z(P) \cap V$ means: for each vertex $w \in V$,
$$|\{e \in \gamma : w \in e\}| \equiv [w \in \mathcal{S}_Z(P)] \pmod{2}$$

**Existence of $\gamma$**: Since $|\mathcal{S}_Z(P) \cap V| \equiv 0 \pmod{2}$ (P commutes with L), and $\mathrm{im}(\partial_1)$ consists of even-cardinality subsets, such a $\gamma$ exists.

**Uniqueness**: The path $\gamma$ is unique up to addition of cycles. Different choices of $\gamma$ give deformed operators differing by flux operators $B_p$.
\end{definition*}

\vspace{1em}
\hrule
\vspace{1em}

\subsection{Rem_3: NoncommutingOperatorsNoDeformation}
\label{Rem_3}

\noindent\textbf{Type:} Remark \hfill \textbf{Formalization Order:} 11/66

\noindent\textbf{Dependencies:} \hyperref[Def_6]{Def_6}, \hyperref[Def_8]{Def_8}

\begin{remark*}[NoncommutingOperatorsNoDeformation]
Let $\mathcal{C}$ be a stabilizer code, $L$ an X-type logical operator, and $G$ a gauging graph.

There is **no deformed version** of a Pauli operator $P$ that does not commute with $L$.

**Reason**: If $[P, L] \neq 0$, then $|\mathcal{S}_Z(P) \cap \mathcal{L}| \equiv 1 \pmod{2}$ (odd overlap). For $\tilde{P} = P \cdot \prod_{e \in \gamma} Z_e$ to commute with all Gauss's law operators $A_v$, we would need:
$$[\tilde{P}, A_v] = 0 \quad \text{for all } v \in V$$

But $[\tilde{P}, A_v] = 0$ requires $|\mathcal{S}_Z(\tilde{P}) \cap \{v\}| + |\{e \in \gamma : v \in e\}| \equiv 0 \pmod{2}$.

Summing over all $v \in \mathcal{L}$: $\sum_{v \in \mathcal{L}} |\mathcal{S}_Z(P) \cap \{v\}| + \sum_{v \in \mathcal{L}} |\{e \in \gamma : v \in e\}| \equiv 0$.

The second sum equals $2|\gamma|$ (each edge counted twice) $\equiv 0$. So we need $|\mathcal{S}_Z(P) \cap \mathcal{L}| \equiv 0$, contradicting odd overlap.

Thus operators anticommuting with $L$ cannot be extended to the deformed code.
\end{remark*}

\vspace{1em}
\hrule
\vspace{1em}

\subsection{Def_9: DeformedCheck}
\label{Def_9}

\noindent\textbf{Type:} Definition \hfill \textbf{Formalization Order:} 12/66

\noindent\textbf{Dependencies:} \hyperref[Def_8]{Def_8}

\begin{definition*}[DeformedCheck]
Let $\mathcal{C}$ be an $[[n, k, d]]$ stabilizer code with checks $\{s_j\}$, let $L$ be an X-type logical operator with support $\mathcal{L}$, and let $G = (V, E)$ be a gauging graph.

For each check $s_j = i^{\sigma_j} \prod_{v \in \mathcal{S}_{X,j}} X_v \prod_{v \in \mathcal{S}_{Z,j}} Z_v$ of the original code:

The **deformed check** $\tilde{s}_j$ is defined as:
$$\tilde{s}_j = s_j \cdot \prod_{e \in \gamma_j} Z_e$$
where $\gamma_j \subseteq E$ is an edge-path satisfying $\partial_1(\gamma_j) = \mathcal{S}_{Z,j} \cap V$.

**Two cases**:
(i) If $\mathcal{S}_{Z,j} \cap \mathcal{L} = \emptyset$ (check has no Z-support on $L$), then $\gamma_j = \emptyset$ and $\tilde{s}_j = s_j$. We denote the set of such checks as $\mathcal{C}$.

(ii) If $\mathcal{S}_{Z,j} \cap \mathcal{L} \neq \emptyset$ (check has Z-support on $L$), then $\gamma_j \neq \emptyset$ is a nontrivial path. We denote the set of such checks as $\mathcal{S}$.

**Verification that $\tilde{s}_j$ commutes with all $A_v$**:
$[\tilde{s}_j, A_v] = 0$ iff $|\mathcal{S}_{Z,j} \cap \{v\}| + |\{e \in \gamma_j : v \in e\}| \equiv 0 \pmod{2}$, which is ensured by the boundary condition $\partial_1(\gamma_j) = \mathcal{S}_{Z,j} \cap V$.
\end{definition*}

\vspace{1em}
\hrule
\vspace{1em}

\subsection{Lem_1: DeformedCodeGenerators}
\label{Lem_1}

\noindent\textbf{Type:} Lemma \hfill \textbf{Formalization Order:} 13/66

\noindent\textbf{Dependencies:} \hyperref[Def_6]{Def_6}, \hyperref[Def_7]{Def_7}, \hyperref[Def_9]{Def_9}

\begin{lemma*}[DeformedCodeGenerators]
Let $\mathcal{C}$ be an $[[n, k, d]]$ stabilizer code with checks $\{s_i\}$, let $L$ be an X-type logical operator, and let $G = (V, E)$ be a gauging graph with generating cycle set $C$.

The following operators form a generating set of stabilizer checks for the **deformed code** (also called the **gauged code**):

(i) **Gauss's law operators**: $A_v = X_v \prod_{e \ni v} X_e$ for all $v \in V$.

(ii) **Flux operators**: $B_p = \prod_{e \in p} Z_e$ for each cycle $p$ in the generating set $C$.

(iii) **Deformed checks**: $\tilde{s}_j = s_j \prod_{e \in \gamma_j} Z_e$ for all checks $s_j$ from the original code, where $\gamma_j$ satisfies $\partial_1(\gamma_j) = \mathcal{S}_{Z,j} \cap V$.

**Verification conditions**:
- Each $A_v$, $B_p$, $\tilde{s}_j$ must be shown to commute with all others
- The operators must be shown to be in the stabilizer group (act as identity on code space)
- Independence: the generating set must have the correct number of independent elements
\end{lemma*}

\begin{proof}
**Lemma (Av_becomes_stabilizer):** Each $A_v$ becomes a stabilizer after the gauging measurement.
*Proof:* The $A_v$ operators are measured during the gauging process, projecting the state into their $+1$ eigenspace. By definition, the deformed code space is the simultaneous $+1$ eigenspace of all $A_v$.

**Lemma (Bp_origin):** Each $B_p$ is a stabilizer of the deformed code originating from edge qubit initialization.
*Proof:* Edge qubits are initialized in $|0\rangle_e$, so $Z_e|0\rangle_e = |0\rangle_e$. Thus $\prod_{e} Z_e$ stabilizes the initial edge state. For a product $\prod_{e \in S} Z_e$ to remain a stabilizer after measuring the $A_v$ operators, it must commute with all $\prod_{e \ni v} X_e$. This requires $|S \cap \{e : v \in e\}| \equiv 0 \pmod{2}$ for all $v$, which means $S$ must be a union of cycles. Taking $S = p$ a cycle gives the flux operators $B_p$.

**Lemma (deformed_check_commutes):** Each $\tilde{s}_j$ commutes with all $A_v$ and $B_p$.
*Proof:* 
- Commutation with $A_v$: $[\tilde{s}_j, A_v] = 0$ follows from the boundary condition $\partial_1(\gamma_j) = \mathcal{S}_{Z,j} \cap V$ as shown in Def_9.
- Commutation with $B_p$: The X-support of $\tilde{s}_j$ is unchanged from $s_j$ (no X on edges). So $[\tilde{s}_j, B_p] = [s_j, B_p] = 0$ since $B_p$ acts only on edges.

**Main Lemma:** The operators $\{A_v\}_{v \in V} \cup \{B_p\}_{p \in C} \cup \{\tilde{s}_j\}$ generate the stabilizer group of the deformed code.
\end{proof}

\vspace{1em}
\hrule
\vspace{1em}

\subsection{Rem_4: CodespaceDimensionReduction}
\label{Rem_4}

\noindent\textbf{Type:} Remark \hfill \textbf{Formalization Order:} 14/66

\noindent\textbf{Dependencies:} \hyperref[Lem_1]{Lem_1}

\begin{remark*}[CodespaceDimensionReduction]
Let $\mathcal{C}$ be an $[[n, k, d]]$ stabilizer code and apply the gauging procedure with graph $G = (V, E)$ to measure logical operator $L$.

The dimension of the code space is reduced by exactly one qubit (i.e., the deformed code encodes $k-1$ logical qubits).

**Counting argument**:
- New qubits added: $|E|$ (one per edge)
- New independent X-type stabilizers: $|V| - 1$ (the $A_v$ operators, minus one for the constraint $\prod_v A_v = L$)
- New independent Z-type stabilizers: $|E| - |V| + 1$ (cycle rank = number of independent $B_p$ operators)

**Net change in encoded qubits**:
$\Delta k = |E| - (|V| - 1) - (|E| - |V| + 1) = |E| - |V| + 1 - |E| + |V| - 1 = -1$

**Example verification**: For the cycle graph $C_n$ with $|V| = |E| = n$ and cycle rank $= 1$:
$\Delta k = n - (n-1) - 1 = 0$... wait, but cycle rank is 1, so: new qubits $= n$, new X-stabs $= n-1$, new Z-stabs $= 1$, so $\Delta k = n - (n-1) - 1 = 0$. 

Actually the logical $L$ is consumed, so the net is $-1$ from the original code's perspective.
\end{remark*}

\vspace{1em}
\hrule
\vspace{1em}

\subsection{Rem_5: FreedomInDeformedChecks}
\label{Rem_5}

\noindent\textbf{Type:} Remark \hfill \textbf{Formalization Order:} 15/66

\noindent\textbf{Dependencies:} \hyperref[Lem_1]{Lem_1}, \hyperref[Def_9]{Def_9}

\begin{remark*}[FreedomInDeformedChecks]
There is significant freedom when specifying a generating set of checks for the deformed code.

**Sources of freedom**:
(i) **Choice of paths $\gamma_j$**: For each deformed check $\tilde{s}_j = s_j \prod_{e \in \gamma_j} Z_e$, any path $\gamma_j$ satisfying $\partial_1(\gamma_j) = \mathcal{S}_{Z,j} \cap V$ gives a valid deformed check. Different choices $\gamma_j$ and $\gamma_j'$ satisfy $\gamma_j + \gamma_j' \in \ker(\partial_1) = \mathrm{im}(\partial_2)$, so $\tilde{s}_j' = \tilde{s}_j \cdot \prod_{p} B_p^{a_p}$ for some $a_p \in \mathbb{Z}_2$.

(ii) **Choice of cycle basis $C$**: Different generating sets of cycles give different $B_p$ operators, but they generate the same algebra since all cycles are $\mathbb{Z}_2$-linear combinations of the generators.

**Optimization goal**: Choose paths $\gamma_j$ and cycle basis $C$ to minimize the **weight** and **degree** of the resulting checks:
- Weight of $\tilde{s}_j$ = $|s_j| + |\gamma_j|$ (original weight plus path length)
- Degree of edge qubit $e$ = number of checks involving $e$

Conventionally, one chooses **minimum weight paths** for each $\gamma_j$.
\end{remark*}

\vspace{1em}
\hrule
\vspace{1em}

\subsection{Def_10: CycleSparsifiedGraph}
\label{Def_10}

\noindent\textbf{Type:} Definition \hfill \textbf{Formalization Order:} 16/66

\noindent\textbf{Dependencies:} \hyperref[Def_4]{Def_4}, \hyperref[Def_5]{Def_5}

\begin{definition*}[CycleSparsifiedGraph]
Let $G = (V, E)$ be a connected graph with a generating set of cycles $C$, and let $c > 0$ be a constant called the **cycle-degree bound**.

A **cycle-sparsification** of $G$ with cycle-degree $c$ is a new graph $\bar{\bar{G}}$ constructed as follows:

(i) **Layer structure**: $\bar{\bar{G}}$ consists of $R + 1$ layers numbered $0, 1, \ldots, R$. Layer 0 is a copy of the original graph $G$. Each layer $i > 0$ is a copy of the vertices of $G$.

(ii) **Inter-layer edges**: For each vertex $v$ in layer $i < R$, add an edge connecting $v$ to its copy in layer $i+1$.

(iii) **Cycle cellulation**: Each cycle $p$ from the original generating set is **cellulated** into triangles by adding edges. For a cycle visiting vertices $(v_1, v_2, \ldots, v_m)$ in order, add edges: $\{(v_1, v_{m-1}), (v_{m-1}, v_2), (v_2, v_{m-2}), \ldots\}$ until the cycle is decomposed into triangles.

(iv) **Sparsity condition**: Each edge in $\bar{\bar{G}}$ participates in at most $c$ generating cycles.

**Notation**: Let $R_G^c$ denote the minimum number of layers required to achieve a cycle-sparsification of $G$ with cycle-degree bound $c$.

**Key property** (Freedman-Hastings decongestion lemma): For any constant-degree graph $G$ with $W = |V|$ vertices, $R_G^c = O(\log^2 W)$ for constant $c$.
\end{definition*}

\vspace{1em}
\hrule
\vspace{1em}

\subsection{Rem_6: CycleSparsificationBounds}
\label{Rem_6}

\noindent\textbf{Type:} Remark \hfill \textbf{Formalization Order:} 17/66

\noindent\textbf{Dependencies:} \hyperref[Def_10]{Def_10}

\begin{remark*}[CycleSparsificationBounds]
For a constant degree graph $G$ with $|V| = W$ vertices:

(i) **Number of cycles**: A minimal generating set of cycles has size $|E| - |V| + 1 = \Theta(W)$ for constant-degree graphs.

(ii) **Random expander expectation**: For a random expander graph, almost all generating cycles have length $O(\log W)$. In this case:
- Cycle-degree (before sparsification) = $O(\log W)$
- Number of layers for sparsification: $R_G^c = O(\log W)$

(iii) **Worst-case bound** (Freedman-Hastings decongestion lemma): For any constant-degree graph, $R_G^c = O(\log^2 W)$.

(iv) **Best case**: For some structured graphs (e.g., surface code lattice surgery), $R_G^c = O(1)$ - no sparsification needed.

**Implication for qubit overhead**: The total number of auxiliary qubits in the cycle-sparsified graph is:
$$|E_{\bar{\bar{G}}}| = |E_G| + R \cdot |V_G| + (\text{cellulation edges}) = O(W \cdot R_G^c) = O(W \log^2 W)$$

This yields the $O(W \log^2 W)$ overhead bound for the gauging measurement procedure.
\end{remark*}

\vspace{1em}
\hrule
\vspace{1em}

\subsection{Rem_7: SparsifiedDeformedChecks}
\label{Rem_7}

\noindent\textbf{Type:} Remark \hfill \textbf{Formalization Order:} 18/66

\noindent\textbf{Dependencies:} \hyperref[Def_10]{Def_10}, \hyperref[Lem_1]{Lem_1}

\begin{remark*}[SparsifiedDeformedChecks]
When using a cycle-sparsification $\bar{\bar{G}}$ of the gauging graph $G$, the deformed checks are chosen to exploit the layered structure:

(i) **Flux operators $B_p$**: Use a generating set of cycles with weight $\leq 4$:
- **Square cycles**: For each edge $e$ in layer $i < R$ and its copy $e'$ in layer $i+1$, the square formed by $e$, $e'$, and the inter-layer edges has weight 4.
- **Triangle cycles**: The cellulated triangles from the original cycles have weight 3.

(ii) **Deformed checks $\tilde{s}_j$**: The paths $\gamma_j$ for deforming original checks are all routed through layer 0 (the original $G$).

**Degree analysis**: Assuming $G$ has constant degree $\Delta$ and paths $\gamma_j$ have length bounded by $\kappa$:
- Number of paths through any edge in layer 0: $\leq 2\Delta^\kappa \cdot w$ where $w$ is the max check weight
- This is constant when $\Delta, \kappa, w$ are all constant.

**Result**: The deformed code is LDPC (constant weight checks, constant degree qubits) when:
- The original code is LDPC
- The gauging graph $G$ has constant degree
- The path lengths $|\gamma_j|$ are bounded by a constant
\end{remark*}

\vspace{1em}
\hrule
\vspace{1em}

\subsection{Rem_8: DesiderataForGaugingGraph}
\label{Rem_8}

\noindent\textbf{Type:} Remark \hfill \textbf{Formalization Order:} 19/66

\noindent\textbf{Dependencies:} \hyperref[Def_5]{Def_5}, \hyperref[Def_10]{Def_10}

\begin{remark*}[DesiderataForGaugingGraph]
When choosing a constant-degree gauging graph $G = (V, E)$ for measuring logical operator $L$, the following **desiderata** should be satisfied:

(i) **Short deforming paths**: $G$ should contain a constant-length edge-path between any pair of vertices that are in the Z-type support of some check from the original code. Specifically: for each check $s_j$ with $\mathcal{S}_{Z,j} \cap V \neq \emptyset$, there exists a path $\gamma_j \subseteq E$ with $|\gamma_j| \leq \kappa$ for some constant $\kappa$.

(ii) **Sufficient expansion**: The Cheeger constant should satisfy $h(G) \geq 1$. This ensures no distance reduction in the deformed code.

(iii) **Low-weight cycle basis**: There should exist a generating set of cycles $C$ where each cycle has weight bounded by a constant. Combined with cycle-sparsification, this ensures the flux operators $B_p$ have constant weight.

**When all desiderata are satisfied**:
- The deformed code is LDPC
- The code distance is preserved: $d_{\text{deformed}} \geq d_{\text{original}}$
- The qubit overhead is $O(|V| \cdot R_G^c)$ where $R_G^c$ is the sparsification depth
\end{remark*}

\vspace{1em}
\hrule
\vspace{1em}

\subsection{Rem_9: WorstCaseGraphConstruction}
\label{Rem_9}

\noindent\textbf{Type:} Remark \hfill \textbf{Formalization Order:} 20/66

\noindent\textbf{Dependencies:} \hyperref[Def_5]{Def_5}, \hyperref[Def_10]{Def_10}, \hyperref[Rem_8]{Rem_8}

\begin{remark*}[WorstCaseGraphConstruction]
Given an X-type logical operator $L$ with weight $W = |\mathcal{L}|$, the following construction produces a gauging graph $G$ satisfying all desiderata with $O(W \log^2 W)$ auxiliary qubits:

**Step 1 (Matching edges)**: For each check $s_j$ whose Z-support overlaps $\mathcal{L}$, pick a $\mathbb{Z}_2$-perfect-matching of the vertices in $\mathcal{S}_{Z,j} \cap \mathcal{L}$. Add an edge to $G$ for each matched pair. This ensures deforming paths have length 1 within each check's Z-support.

**Step 2 (Expansion edges)**: Add edges to $G$ until $h(G) \geq 1$. This can be done by:
- Adding edges randomly while maintaining constant degree, or
- Adding edges from a known constant-degree expander graph on $W$ vertices

Let $G_0$ denote the graph after Steps 1-2.

**Step 3 (Cycle sparsification)**: Apply the Freedman-Hastings decongestion procedure:
- Add $R = O(\log^2 W)$ layers of dummy vertices (copies of $G_0$)
- Connect consecutive layers with inter-layer edges
- Cellulate long cycles to achieve constant cycle-degree

**Result**: The final graph $\bar{\bar{G}}$ has:
- $|V| = O(W \log^2 W)$ vertices (including dummies)
- $|E| = O(W \log^2 W)$ edges
- Cheeger constant $h(\bar{\bar{G}}) \geq h(G_0) \geq 1$
- All cycles have constant weight after cellulation
\end{remark*}

\vspace{1em}
\hrule
\vspace{1em}

\subsection{Thm_1: GaugingMeasurement}
\label{Thm_1}

\noindent\textbf{Type:} Theorem \hfill \textbf{Formalization Order:} 21/66

\noindent\textbf{Dependencies:} \hyperref[Def_4]{Def_4}, \hyperref[Def_6]{Def_6}, \hyperref[Def_7]{Def_7}

\begin{theorem*}[GaugingMeasurement]
Let $\mathcal{C}$ be an $[[n, k, d]]$ stabilizer code, let $L = \prod_{v \in \mathcal{L}} X_v$ be an X-type logical operator, and let $G = (V, E)$ be a connected gauging graph with an arbitrarily chosen root vertex $v_0 \in V$.

The **gauging measurement procedure** (Algorithm 1) is equivalent to performing a projective measurement of $L$.

Specifically, given input state $|\psi\rangle$ in the code space:
1. Initialize auxiliary edge qubits: $|\Psi\rangle = |\psi\rangle \otimes |0\rangle_E$
2. For each $v \in V$, measure $A_v = X_v \prod_{e \ni v} X_e$, obtaining result $\varepsilon_v \in \{\pm 1\}$
3. Set $\sigma = \prod_{v \in V} \varepsilon_v$
4. For each $e \in E$, measure $Z_e$, obtaining result $\omega_e \in \{\pm 1\}$
5. For each $v \in V$, let $\gamma_v$ be an edge-path from $v_0$ to $v$. If $\prod_{e \in \gamma_v} \omega_e = -1$, apply $X_v$.

Then the output satisfies:
- $\sigma \in \{\pm 1\}$ is the measurement result of $L$
- The post-measurement state is $|\Psi_{\text{out}}\rangle = \frac{1}{2}(I + \sigma L)|\psi\rangle$ (up to normalization)
\end{theorem*}

\begin{proof}
**Lemma (state_after_Av_measurements):** After measuring all $A_v$ operators, the state is:
$$\prod_v \frac{1}{2}(I + \varepsilon_v A_v)|\psi\rangle|0\rangle_E = \frac{1}{2^{|V|}} \sum_{c \in C_0(G; \mathbb{Z}_2)} \varepsilon(c) X_V(c) X_E(\delta_0 c)|\psi\rangle|0\rangle_E$$
where $\varepsilon(c) = \prod_v \varepsilon_v^{c_v}$, $X_V(c) = \prod_v X_v^{c_v}$, and $X_E(\delta_0 c) = \prod_e X_e^{(\delta_0 c)_e}$.
*Proof:* Expand the product of projectors $\prod_v \frac{1}{2}(I + \varepsilon_v A_v)$ using $A_v = X_v \prod_{e \ni v} X_e$.

**Lemma (Z_measurement_constraint):** After measuring all $Z_e$ with outcomes $z = (z_e)_{e \in E}$, projecting onto $\langle z|_E$, only terms with $\delta_0 c = z$ survive:
$$\langle z|_E \cdot (\text{state}) = \frac{1}{2^{|V|}} \sum_{c : \delta_0 c = z} \varepsilon(c) X_V(c)|\psi\rangle$$
*Proof:* $\langle z|_E X_E(\delta_0 c)|0\rangle_E = 0$ unless $\delta_0 c = z$ (edge by edge).

**Lemma (cocycle_reduction):** For connected $G$, the sum over $\{c : \delta_0 c = z\}$ reduces to two terms:
$$\sum_{c : \delta_0 c = z} \varepsilon(c) X_V(c) = X_V(c')(I + \sigma L)$$
where $c'$ is any fixed 0-chain with $\delta_0 c' = z$, and $\sigma = \prod_v \varepsilon_v$.
*Proof:* The set $\{c : \delta_0 c = z\}$ is a coset of $\ker(\delta_0)$. For connected $G$, $\ker(\delta_0) = \{0, \mathbf{1}_V\}$. So $\{c : \delta_0 c = z\} = \{c', c' + \mathbf{1}_V\}$. Now $X_V(\mathbf{1}_V) = \prod_{v \in V} X_v = L$ and $\varepsilon(\mathbf{1}_V) = \prod_v \varepsilon_v = \sigma$.

**Lemma (byproduct_correction):** The byproduct operator $X_V(c')$ is corrected by Step 5.
*Proof:* Choosing paths $\gamma_v$ from $v_0$ to each $v$, the condition $\prod_{e \in \gamma_v} \omega_e = -1$ identifies exactly the vertices where $c'_v = 1$. Applying $X_v$ on these vertices removes $X_V(c')$.

**Main Theorem:** Combining all lemmas: the output state is $\frac{1}{2}(I + \sigma L)|\psi\rangle$ where $\sigma = \prod_v \varepsilon_v$, which is the projection onto the $\sigma$-eigenspace of $L$.
\end{proof}

\vspace{1em}
\hrule
\vspace{1em}

\subsection{Lem_2: SpaceDistanceBound}
\label{Lem_2}

\noindent\textbf{Type:} Lemma \hfill \textbf{Formalization Order:} 22/66

\noindent\textbf{Dependencies:} \hyperref[Def_5]{Def_5}, \hyperref[Def_8]{Def_8}, \hyperref[Rem_2]{Rem_2}

\begin{lemma*}[SpaceDistanceBound]
Let $\mathcal{C}$ be an $[[n, k, d]]$ stabilizer code, let $L$ be an X-type logical operator, and let $G = (V, E)$ be a gauging graph (possibly cycle-sparsified to $\bar{\bar{G}}$).

The distance $d^*$ of the deformed code satisfies:
$$d^* \geq \min(h(G), 1) \cdot d$$

where $h(G)$ is the Cheeger constant of $G$ and $d$ is the distance of the original code.

In particular, if $h(G) \geq 1$, then $d^* \geq d$ (no distance reduction).
\end{lemma*}

\begin{proof}
**Lemma (logical_op_decomposition):** Any logical operator $L'$ of the deformed code can be written as:
$$L' = i^\sigma \cdot L_X^V \cdot L_Z^V \cdot L_X^E \cdot L_Z^E \cdot \tilde{L}$$
where:
- $L_X^V = \prod_{v \in \mathcal{S}_X \cap V} X_v$ (X on vertex qubits in the gauged region)
- $L_X^E = \prod_{e \in \mathcal{S}_X \cap E} X_e$ (X on edge qubits)
- $L_Z^V, L_Z^E$ are the Z-type components
- $\tilde{L}$ is the component outside the gauged region
*Proof:* Direct decomposition by support.

**Lemma (flux_commutation_constraint):** If $L'$ is a logical operator (commutes with all checks), then $\mathcal{S}_X^E = \mathcal{S}_X \cap E$ satisfies $\delta_1(\mathcal{S}_X^E) = 0$.
*Proof:* $L'$ must commute with all flux checks $B_p = \prod_{e \in p} Z_e$. We have $[L', B_p] = 0$ iff $|\mathcal{S}_X^E \cap p| \equiv 0 \pmod{2}$ for all cycles $p$. This is exactly $\delta_1(\mathcal{S}_X^E) = 0$.

**Lemma (edge_support_is_coboundary):** By exactness, $\mathcal{S}_X^E = \delta_0(\tilde{\mathcal{S}}_X^V)$ for some vertex set $\tilde{\mathcal{S}}_X^V \subseteq V$.
*Proof:* From Remark 2, $\ker(\delta_1) = \mathrm{im}(\delta_0)$ when using a generating cycle set.

**Lemma (equivalent_logical):** $L'$ is equivalent (mod stabilizers) to:
$$\bar{L} = L' \cdot \prod_{v \in \tilde{\mathcal{S}}_X^V} A_v = i^\sigma L_X^V \bar{L}_X^V L_Z^V L_Z^E \tilde{L}$$
where $\bar{L}_X^V = \prod_{v \in \tilde{\mathcal{S}}_X^V \cap G_0} X_v$ and $G_0$ is layer 0 (original qubits, not dummies).
*Proof:* Multiplying by $A_v$ stabilizers removes edge X-support and adds vertex X-support.

**Lemma (restriction_is_original_logical):** The restriction $\bar{L}|_V = i^\sigma L_X^V \bar{L}_X^V L_Z^V \tilde{L}$ is a logical operator of the original code.
*Proof:* $\bar{L}$ commutes with deformed checks $\tilde{s}_j$. The extra $Z_e$ terms in $\tilde{s}_j$ don't affect commutation since $\bar{L}|_V$ has no edge support. So $\bar{L}|_V$ commutes with all original checks $s_j$.

**Lemma (cheeger_bound_application):** If $|\tilde{\mathcal{S}}_X^V \cap G_0| \leq |V|/2$, then:
$$|\delta_0(\tilde{\mathcal{S}}_X^V)| \geq h(G) \cdot |\tilde{\mathcal{S}}_X^V \cap G_0|$$
*Proof:* Direct application of Cheeger constant definition.

**Lemma (weight_bound):** $|L'| \geq |\mathcal{S}_X^E| \geq h(G) \cdot |\tilde{\mathcal{S}}_X^V \cap G_0| \geq h(G) \cdot |\bar{L}|_V|$ when $h(G) \leq 1$.
*Proof:* For $h(G) \leq 1$: the edge support has size at least $h(G)$ times the vertex support being "cleaned". The cleaned logical has weight $\geq d$ by the original code distance.

**Main Lemma:** Combining: $|L'| \geq \min(h(G), 1) \cdot |\bar{L}|_V| \geq \min(h(G), 1) \cdot d$.
\end{proof}

\vspace{1em}
\hrule
\vspace{1em}

\subsection{Rem_10: OptimalCheegerConstant}
\label{Rem_10}

\noindent\textbf{Type:} Remark \hfill \textbf{Formalization Order:} 23/66

\noindent\textbf{Dependencies:} \hyperref[Lem_2]{Lem_2}

\begin{remark*}[OptimalCheegerConstant]
Picking a graph with Cheeger constant $h(G) = 1$ is optimal in the following sense:

(i) **Sufficient for distance preservation**: If $h(G) \geq 1$, then $d^* \geq d$ by Lemma 2.

(ii) **Larger Cheeger doesn't help**: If $h(G) > 1$, the distance bound is still $d^* \geq d$ (not $d^* \geq h(G) \cdot d$). This is because logical operators can always be "cleaned" onto vertex qubits, where the original code distance applies.

(iii) **Small Cheeger causes distance loss**: If $h(G) < 1$, the distance can be reduced by a factor of $h(G)$. In the worst case, a logical of the deformed code has most of its weight on edges, and cleaning it onto vertices increases vertex weight by factor $1/h(G)$.
\end{remark*}

\vspace{1em}
\hrule
\vspace{1em}

\subsection{Rem_11: LogicalPreservation}
\label{Rem_11}

\noindent\textbf{Type:} Remark \hfill \textbf{Formalization Order:} 24/66

\noindent\textbf{Dependencies:} \hyperref[Lem_2]{Lem_2}, \hyperref[Thm_1]{Thm_1}

\begin{remark*}[LogicalPreservation]
The gauging procedure preserves all quantum information except for the measured logical $L$.

**Bijection between logicals**: There is a 1-1 correspondence between:
- Logical operators of the deformed code
- Logical operators of the original code that commute with $L$

**Mapping**:
- Forward: A logical $\tilde{P}$ of the original code commuting with $L$ maps to its deformation $\tilde{P} \cdot \prod_{e \in \gamma} Z_e$
- Backward: A logical $L'$ of the deformed code maps to its restriction $\bar{L}|_V$

**Kernel of the map**: Operators equivalent to $L$ map to stabilizers in the deformed code (since $L$ is measured).

**Algebra preservation**: The commutation relations among logicals are preserved by this mapping.
\end{remark*}

\vspace{1em}
\hrule
\vspace{1em}

\subsection{Rem_12: CircuitImplementation}
\label{Rem_12}

\noindent\textbf{Type:} Remark \hfill \textbf{Formalization Order:} 25/66

\noindent\textbf{Dependencies:} \hyperref[Thm_1]{Thm_1}

\begin{remark*}[CircuitImplementation]
The gauging measurement procedure can be implemented by a quantum circuit with no additional qubits beyond the edge qubits:

**Circuit steps**:
1. Initialize edge qubits: $|0\rangle_E$
2. Apply entangling circuit: $\prod_v \prod_{e \ni v} CX_{v \to e}$ where $CX_{v \to e}$ is controlled-X from vertex $v$ to edge $e$
3. Measure $X_v$ on all vertices $v \in V$ and record outcomes
4. Apply the same entangling circuit again: $\prod_v \prod_{e \ni v} CX_{v \to e}$
5. Measure $Z_e$ on all edges and discard edge qubits
6. Apply byproduct corrections based on measurement outcomes

**Verification**: The composition of steps 2-3 is equivalent to measuring $A_v = X_v \prod_{e \ni v} X_e$ because:
- After step 2: $CX$ entangles vertex and edge qubits
- Measuring $X_v$ in step 3 effectively measures $A_v$ in the original basis
- Step 4 disentangles for the $Z_e$ measurements
\end{remark*}

\vspace{1em}
\hrule
\vspace{1em}

\subsection{Rem_13: Parallelization}
\label{Rem_13}

\noindent\textbf{Type:} Remark \hfill \textbf{Formalization Order:} 26/66

\noindent\textbf{Dependencies:} \hyperref[Thm_1]{Thm_1}, \hyperref[Lem_1]{Lem_1}

\begin{remark*}[Parallelization]
The gauging measurement can be applied to multiple logical operators in parallel, subject to compatibility conditions:

**Compatibility condition**: Logical operators $L_1, \ldots, L_m$ can be measured in parallel if no pair acts on a common qubit via different non-trivial Pauli operators. Specifically: for all $i \neq j$ and all qubits $v$, at least one of the following holds:
- $v \notin \mathrm{supp}(L_i)$, or
- $v \notin \mathrm{supp}(L_j)$, or  
- $L_i$ and $L_j$ act on $v$ by the same Pauli ($X$, $Y$, or $Z$)

**LDPC preservation**: To maintain an LDPC deformed code, at most a constant number of logical operators being measured should share support on any single qubit.

**Time-space tradeoff**: Instead of $d$ rounds of syndrome measurement, one can perform:
- $\frac{d}{m}$ rounds of syndrome measurement
- Measure $2m - 1$ equivalent logical operators in parallel
- Take majority vote to determine the classical outcome

This trades space overhead (more parallel measurements) for time overhead (fewer rounds).
\end{remark*}

\vspace{1em}
\hrule
\vspace{1em}

\subsection{Rem_14: HypergraphGeneralization}
\label{Rem_14}

\noindent\textbf{Type:} Remark \hfill \textbf{Formalization Order:} 27/66

\noindent\textbf{Dependencies:} \hyperref[Thm_1]{Thm_1}, \hyperref[Def_6]{Def_6}

\begin{remark*}[HypergraphGeneralization]
The gauging measurement procedure generalizes from graphs to hypergraphs:

**Hypergraph gauging**: Replace the graph $G$ with a hypergraph $H = (V, \mathcal{E})$ where $\mathcal{E}$ is a collection of hyperedges (subsets of $V$ of arbitrary size).

**Generalized Gauss's law**: For each vertex $v$, define:
$$A_v = X_v \prod_{e \in \mathcal{E} : v \in e} X_e$$

**What can be measured**: The hypergraph gauging measures the group of operators:
$$\{P \in \langle X_v : v \in V \rangle : [P, B_e] = 0 \text{ for all } e \in \mathcal{E}\}$$
where $B_e = \prod_{v \in e} Z_v$ are Z-type hyperedge checks.

This is equivalent to $\ker(H^T)$ where $H$ is the incidence matrix of the hypergraph over $\mathbb{F}_2$.

**Application**: Measure multiple commuting logical operators simultaneously by choosing a hypergraph whose kernel is exactly the group generated by those logicals.
\end{remark*}

\vspace{1em}
\hrule
\vspace{1em}

\subsection{Def_11: SpaceTimeFault}
\label{Def_11}

\noindent\textbf{Type:} Definition \hfill \textbf{Formalization Order:} 28/66

\begin{definition*}[SpaceTimeFault]
In the fault-tolerant implementation of the gauging measurement:

**Space-fault (Pauli error)**: A Pauli error operator $P \in \{X, Y, Z\}$ that occurs on some qubit at some time step during the procedure.

**Time-fault (measurement error)**: An error where the result of a measurement is reported incorrectly (bit-flip of the classical outcome).

**Initialization fault**: An error where a qubit is initialized in the wrong state. This is equivalent to a space-fault: initializing in wrong state = perfect initialization followed by an error operator.

**General spacetime fault**: A collection $F$ of space-faults and time-faults occurring at various spacetime locations.

**Weight of a fault**: $|F|$ = (number of single-qubit Pauli errors) + (number of measurement errors).
\end{definition*}

\vspace{1em}
\hrule
\vspace{1em}

\subsection{Def_12: Detector}
\label{Def_12}

\noindent\textbf{Type:} Definition \hfill \textbf{Formalization Order:} 29/66

\noindent\textbf{Dependencies:} \hyperref[Def_11]{Def_11}

\begin{definition*}[Detector]
A **detector** is a collection of state initializations and measurements that yield a deterministic result in the absence of faults.

Formally, a detector $D$ consists of:
- A set of qubit initializations (each in a known state)
- A set of measurements (each of a known observable)
- A parity constraint: the product of measurement outcomes must equal a fixed value (typically $+1$)

**Detector violation**: A spacetime fault $F$ **violates** detector $D$ if $F$ causes the parity constraint of $D$ to fail.

**Syndrome**: The **syndrome** of a spacetime fault $F$ is the set of all detectors violated by $F$:
$$\mathrm{syn}(F) = \{D : F \text{ violates } D\}$$
\end{definition*}

\vspace{1em}
\hrule
\vspace{1em}

\subsection{Lem_3: SpacetimeCodeDetectors}
\label{Lem_3}

\noindent\textbf{Type:} Lemma \hfill \textbf{Formalization Order:} 30/66

\noindent\textbf{Dependencies:} \hyperref[Def_12]{Def_12}, \hyperref[Lem_1]{Lem_1}

\begin{lemma*}[SpacetimeCodeDetectors]
The following form a generating set of local detectors in the fault-tolerant gauging measurement procedure:

**For $t < t_i$ and $t > t_o$** (before and after code deformation):
- $s_j^t$: Repeated measurement of check $s_j$ at times $t - \frac{1}{2}$ and $t + \frac{1}{2}$

**For $t_i < t < t_o$** (during code deformation):
- $A_v^t$: Repeated measurement of $A_v$ at times $t - \frac{1}{2}$ and $t + \frac{1}{2}$
- $B_p^t$: Repeated measurement of $B_p$ at times $t - \frac{1}{2}$ and $t + \frac{1}{2}$
- $\tilde{s}_j^t$: Repeated measurement of $\tilde{s}_j$ at times $t - \frac{1}{2}$ and $t + \frac{1}{2}$

**For $t = t_i$** (start of code deformation):
- $B_p^{t_i}$: Initialization of edges $e \in p$ in $|0\rangle_e$ at $t_i - \frac{1}{2}$ and first measurement of $B_p$ at $t_i + \frac{1}{2}$
- $\tilde{s}_j^{t_i}$: Initialization of edges $e \in \gamma_j$ in $|0\rangle_e$, measurement of $s_j$ at $t_i - \frac{1}{2}$, and measurement of $\tilde{s}_j$ at $t_i + \frac{1}{2}$

**For $t = t_o$** (end of code deformation):
- $B_p^{t_o}$: Measurement of $B_p$ at $t_o - \frac{1}{2}$ and final $Z_e$ measurements on edges $e \in p$ at $t_o + \frac{1}{2}$
- $\tilde{s}_j^{t_o}$: Measurement of $\tilde{s}_j$ at $t_o - \frac{1}{2}$, and measurements of $Z_e$ on edges $e \in \gamma_j$ and $s_j$ at $t_o + \frac{1}{2}$
\end{lemma*}

\begin{proof}
**Lemma (bulk_detectors):** Away from boundary times, detectors are pairs of consecutive measurements of the same check.
*Proof:* In steady-state syndrome extraction, measuring check $C$ at times $t$ and $t+1$ gives the same outcome unless an error occurred. The parity constraint is: outcome($C$, time $t$) $\cdot$ outcome($C$, time $t+1$) $= +1$.

**Lemma (initial_boundary_B):** At $t = t_i$, the detector $B_p^{t_i}$ is well-defined.
*Proof:* Edge qubits are initialized in $|0\rangle$, which is a $+1$ eigenstate of $Z_e$. Thus $B_p = \prod_{e \in p} Z_e$ has eigenvalue $+1$ on the initial state. The first measurement of $B_p$ at $t_i + \frac{1}{2}$ must give $+1$ (absent errors), establishing the detector.

**Lemma (initial_boundary_s):** At $t = t_i$, the detector $\tilde{s}_j^{t_i}$ relates $s_j$ and $\tilde{s}_j$ measurements.
*Proof:* Before gauging, $s_j$ is measured. After gauging, $\tilde{s}_j = s_j \prod_{e \in \gamma_j} Z_e$ is measured. Since edges are initialized in $|0\rangle$, $\prod_{e \in \gamma_j} Z_e$ acts as $+1$. So $s_j$ and $\tilde{s}_j$ have the same eigenvalue on the code state.

**Lemma (final_boundary):** At $t = t_o$, detectors involve final $Z_e$ read-out.
*Proof:* The $Z_e$ measurements at ungauging determine the edge state. Combined with the last $B_p$ or $\tilde{s}_j$ measurement, they form valid detectors by the same logic as the initial boundary.

**Main Lemma:** These detectors generate all local detectors by decomposition.
\end{proof}

\vspace{1em}
\hrule
\vspace{1em}

\subsection{Rem_15: SpacetimeSyndromes}
\label{Rem_15}

\noindent\textbf{Type:} Remark \hfill \textbf{Formalization Order:} 31/66

\noindent\textbf{Dependencies:} \hyperref[Lem_3]{Lem_3}

\begin{remark*}[SpacetimeSyndromes]
The syndrome of each type of fault in the spacetime code:

**For $t < t_i$ and $t > t_o$**:
- Pauli $X_v$ (or $Z_v$) fault at time $t$: violates $s_j^t$ for all $s_j$ that anticommute with $X_v$ (or $Z_v$)
- $s_j$-measurement fault at time $t + \frac{1}{2}$: violates $s_j^t$ and $s_j^{t+1}$

**For $t_i < t < t_o$**:
- $X_v$ fault at time $t$: violates $\tilde{s}_j^t$ for anticommuting $\tilde{s}_j$
- $Z_v$ fault at time $t$: violates $A_v^t$ and $\tilde{s}_j^t$ for anticommuting $\tilde{s}_j$
- $X_e$ fault at time $t$: violates $B_p^t$ for all $p \ni e$, and $\tilde{s}_j^t$ for anticommuting $\tilde{s}_j$
- $Z_e$ fault at time $t$: violates $A_v^t$ for both $v \in e$
- Measurement faults: violate detectors at times $t$ and $t+1$ for the corresponding check

**At boundaries $t = t_i, t_o$**: Initialization/read-out faults are equivalent to Pauli faults and violate the corresponding boundary detectors.
\end{remark*}

\vspace{1em}
\hrule
\vspace{1em}

\subsection{Rem_16: SyndromeMobility}
\label{Rem_16}

\noindent\textbf{Type:} Remark \hfill \textbf{Formalization Order:} 32/66

\noindent\textbf{Dependencies:} \hyperref[Rem_15]{Rem_15}

\begin{remark*}[SyndromeMobility]
Syndromes can be created, moved, and destroyed by faults:

**Creation/Annihilation**:
- Pauli errors create syndrome pairs (one at each adjacent time slice)
- Measurement errors propagate syndromes forward/backward in time

**Movement**:
- For $t < t_i$ and $t > t_o$: Standard syndrome mobility via Pauli strings
- For $t_i < t < t_o$: $Z_e$ errors on edges form strings that move $A_v$ syndromes along edge-paths in $G$

**Condensation at boundaries**:
- At $t = t_i$: $A_v$ syndromes can be created/destroyed (the $A_v$ stabilizers start being measured)
- At $t = t_o$: $A_v$ syndromes can be created/destroyed (the $A_v$ stabilizers stop being measured)

**Propagation through boundaries**:
- $B_p$ and $\tilde{s}_j$ syndromes can propagate through $t_i$ and $t_o$ by mapping to vertex-only errors plus $A_v$ stabilizers
\end{remark*}

\vspace{1em}
\hrule
\vspace{1em}

\subsection{Def_13: SpacetimeLogicalFault}
\label{Def_13}

\noindent\textbf{Type:} Definition \hfill \textbf{Formalization Order:} 33/66

\noindent\textbf{Dependencies:} \hyperref[Def_11]{Def_11}, \hyperref[Def_12]{Def_12}

\begin{definition*}[SpacetimeLogicalFault]
A **spacetime logical fault** is a collection of space and time faults that:
(i) Does not violate any detector: $\mathrm{syn}(F) = \emptyset$
(ii) Is not a spacetime stabilizer (see Def_14)

Intuitively, a spacetime logical fault is an undetectable error that affects the computation result.
\end{definition*}

\vspace{1em}
\hrule
\vspace{1em}

\subsection{Def_14: SpacetimeStabilizer}
\label{Def_14}

\noindent\textbf{Type:} Definition \hfill \textbf{Formalization Order:} 34/66

\noindent\textbf{Dependencies:} \hyperref[Def_11]{Def_11}, \hyperref[Def_12]{Def_12}

\begin{definition*}[SpacetimeStabilizer]
A **spacetime stabilizer** is a collection of space and time faults that:
(i) Does not violate any detector: $\mathrm{syn}(F) = \emptyset$
(ii) Does not affect the result of the gauging measurement procedure

Spacetime stabilizers are the "trivial" undetectable faults - they are errors that cancel out and have no effect on the computation.
\end{definition*}

\vspace{1em}
\hrule
\vspace{1em}

\subsection{Lem_4: SpacetimeStabilizerGenerators}
\label{Lem_4}

\noindent\textbf{Type:} Lemma \hfill \textbf{Formalization Order:} 35/66

\noindent\textbf{Dependencies:} \hyperref[Lem_3]{Lem_3}, \hyperref[Def_14]{Def_14}

\begin{lemma*}[SpacetimeStabilizerGenerators]
The following form a generating set of local spacetime stabilizers:

**For $t < t_i$ and $t > t_o$**:
- Space stabilizer: Check operator $s_j$ at time $t$
- Time stabilizer: Pair of $X_i$ (or $Z_i$) faults at times $t, t+1$, together with measurement faults on all anticommuting checks $s_j$ at time $t + \frac{1}{2}$

**For $t_i < t < t_o$**:
- Space stabilizers: $\tilde{s}_j$, $A_v$, or $B_p$ at time $t$
- Time stabilizers for vertex qubits: Pair of $X_v$ (or $Z_v$) faults at times $t, t+1$, plus appropriate measurement faults
- Time stabilizers for edge qubits: Pair of $X_e$ (or $Z_e$) faults at times $t, t+1$, plus appropriate measurement faults

**At $t = t_i$**:
- Space stabilizer: $s_j$ or $Z_e$ at time $t$
- Initialization-space pair: $|0\rangle_e$ initialization fault at $t - \frac{1}{2}$ together with $X_e$ fault at time $t$
- Edge-measurement pair: $Z_e$ fault at $t + 1$ together with pair of $A_v$ measurement faults for $v \in e$ at $t + \frac{1}{2}$

**At $t = t_o$**:
- Space stabilizers: $\tilde{s}_j$, $A_v$, or $B_p$ at time $t$
- Read-out-space pair: $X_e$ fault at $t$ together with $Z_e$ measurement fault at $t + \frac{1}{2}$
- Remaining $Z_e$ at time $t$ (stabilizer of deformed code about to be unmeasured)
\end{lemma*}

\begin{proof}
**Lemma (bulk_spacetime_stabilizers):** Away from boundaries, spacetime stabilizers are products of: (a) space stabilizers at fixed time, (b) time-translation pairs of Pauli faults plus measurement faults.
*Proof:* A Pauli error at time $t$ creates syndromes. To cancel them without other Pauli errors, must have the same Pauli at time $t+1$ (cancels syndromes) plus measurement errors at $t + \frac{1}{2}$ (prevents detection between $t$ and $t+1$).

**Lemma (boundary_stabilizers):** At code deformation times, initialization/read-out errors pair with Pauli errors.
*Proof:* An initialization error $|0\rangle \to |1\rangle$ is equivalent to perfect initialization plus $X$ error. A read-out error is equivalent to perfect measurement plus classical bit-flip, which for stabilizer codes equals a Pauli error before measurement.

**Main Lemma:** Any local spacetime stabilizer decomposes into these generators by: (1) isolate Pauli operators to earliest time using time-translation stabilizers, (2) the product at earliest time must be a space stabilizer, (3) remaining measurement errors form trivial patterns.
\end{proof}

\vspace{1em}
\hrule
\vspace{1em}

\subsection{Def_15: SpacetimeFaultDistance}
\label{Def_15}

\noindent\textbf{Type:} Definition \hfill \textbf{Formalization Order:} 36/66

\noindent\textbf{Dependencies:} \hyperref[Def_13]{Def_13}, \hyperref[Def_14]{Def_14}

\begin{definition*}[SpacetimeFaultDistance]
The **spacetime fault-distance** of the fault-tolerant gauging measurement procedure is:
$$d_{\text{ST}} = \min\{|F| : F \text{ is a spacetime logical fault}\}$$

where $|F|$ counts single-qubit Pauli errors plus single measurement errors.

Equivalently, $d_{\text{ST}}$ is the minimum weight of an undetectable fault pattern that is not equivalent to a spacetime stabilizer.
\end{definition*}

\vspace{1em}
\hrule
\vspace{1em}

\subsection{Lem_5: TimeFaultDistance}
\label{Lem_5}

\noindent\textbf{Type:} Lemma \hfill \textbf{Formalization Order:} 37/66

\noindent\textbf{Dependencies:} \hyperref[Lem_3]{Lem_3}, \hyperref[Lem_4]{Lem_4}

\begin{lemma*}[TimeFaultDistance]
The fault-distance for pure measurement and initialization errors is $(t_o - t_i)$, the number of rounds between the start and end of code deformation.

Specifically: Any spacetime logical fault consisting only of measurement/initialization errors has weight $\geq t_o - t_i$.
\end{lemma*}

\begin{proof}
**Lemma (measurement_fault_propagation):** A measurement fault on check $C$ at time $t$ must be accompanied by measurement faults on $C$ at either $t-1$ or $t+1$ (or boundary termination).
*Proof:* The detector comparing $C$ at times $t$ and $t \pm 1$ would otherwise be violated.

**Lemma (boundary_termination_Av):** Strings of $A_v$ measurement faults can terminate at $t = t_i$ and $t = t_o$.
*Proof:* At $t_i + \frac{1}{2}$: the first $A_v$ measurement fault only violates $A_v^{t_i+1}$, not a boundary detector (since $A_v$ wasn't measured before). Similarly at $t_o - \frac{1}{2}$.

**Lemma (boundary_termination_edges):** Strings of $B_p/\tilde{s}_j$ measurement faults can terminate at boundaries via initialization/read-out faults.
*Proof:* At $t_i$: a $|0\rangle_e$ initialization fault violates $B_p^{t_i}$ and $\tilde{s}_j^{t_i}$ for appropriate $p, j$. At $t_o$: a $Z_e$ read-out fault has the same effect.

**Lemma (edge_faults_trivial):** The measurement logical fault from edge initialization/read-out is trivial.
*Proof:* It decomposes into spacetime stabilizers: initialization fault + $X_e$ at $t_i$, then $X_e$ at $t_i+1$, etc., then $X_e$ at $t_o$ + read-out fault.

**Lemma (Av_measurement_fault_logical):** Repeated $A_v$ measurement faults from $t_i$ to $t_o$ form a nontrivial logical fault.
*Proof:* This fault flips the inferred value of $\prod_v \varepsilon_v$, which determines the measurement outcome $\sigma$ of logical $L$.

**Main Lemma:** The minimum weight measurement logical fault is the $A_v$ measurement string with weight $t_o - t_i$.
\end{proof}

\vspace{1em}
\hrule
\vspace{1em}

\subsection{Lem_6: SpaceTimeFaultDecoupling}
\label{Lem_6}

\noindent\textbf{Type:} Lemma \hfill \textbf{Formalization Order:} 38/66

\noindent\textbf{Dependencies:} \hyperref[Lem_4]{Lem_4}, \hyperref[Lem_5]{Lem_5}

\begin{lemma*}[SpaceTimeFaultDecoupling]
Any spacetime logical fault is equivalent to the product of a space logical fault and a time logical fault, up to multiplication with spacetime stabilizers.

Formally: For any spacetime logical fault $F$, there exist:
- A spacetime stabilizer $S$
- A space-only logical fault $F_S$ (Pauli errors at a single time slice)
- A time-only logical fault $F_T$ (measurement/initialization errors only)

such that $F = S \cdot F_S \cdot F_T$.
\end{lemma*}

\begin{proof}
**Lemma (clean_to_time_ti):** Any spacetime fault can be cleaned to have all Pauli components at time $t_i$.
*Proof:* Use time-translation spacetime stabilizers: a Pauli at time $t$ plus the same Pauli at time $t+1$ plus measurement faults is a stabilizer. Apply these to move all Paulis to $t_i$.

**Lemma (measurement_fault_structure):** After cleaning, remaining measurement faults occur only in $[t_i, t_o]$.
*Proof:* Measurement faults outside $[t_i, t_o]$ would propagate to initial/final boundaries (assumed perfect), violating detectors.

**Lemma (measurement_fault_classification):** Measurement fault strings from $t_i$ to $t_o$ are either:
(a) $A_v$ measurement strings (timelike logical faults), or
(b) Edge-related strings (trivial, decompose into stabilizers)
*Proof:* $A_v$ strings change $\sigma = \prod_v \varepsilon_v$ (logical). Edge strings can be paired with initialization/read-out faults to form stabilizers.

**Main Lemma:** After cleaning and decomposing edge strings, we have: original fault $=$ (stabilizers) $\cdot$ (Pauli errors at $t_i$) $\cdot$ ($A_v$ measurement strings). The Pauli errors at $t_i$ form a space logical fault; the $A_v$ strings form a time logical fault.
\end{proof}

\vspace{1em}
\hrule
\vspace{1em}

\subsection{Thm_2: FaultTolerance}
\label{Thm_2}

\noindent\textbf{Type:} Theorem \hfill \textbf{Formalization Order:} 39/66

\noindent\textbf{Dependencies:} \hyperref[Lem_2]{Lem_2}, \hyperref[Lem_5]{Lem_5}, \hyperref[Lem_6]{Lem_6}

\begin{theorem*}[FaultTolerance]
The fault-tolerant implementation of the gauging measurement procedure with a suitable graph $G$ has spacetime fault-distance $d$.

Specifically, if:
(i) The gauging graph satisfies $h(G) \geq 1$ (Cheeger constant at least 1)
(ii) The number of syndrome measurement rounds satisfies $t_o - t_i \geq d$

Then any undetectable fault pattern that affects the computation has weight at least $d$.
\end{theorem*}

\begin{proof}
**Lemma (time_distance_bound):** Spacetime logical faults not equivalent to space-only faults have weight $\geq d$.
*Proof:* By Lemma 5, pure time logical faults have weight $\geq t_o - t_i \geq d$.

**Lemma (space_distance_bound):** Spacetime logical faults equivalent to space-only faults have weight $\geq d$.
*Proof:* By Lemma 6, such faults can be cleaned to a spacelike logical at $t_i$. By Lemma 2, space logicals of the deformed code have weight $\geq \min(h(G), 1) \cdot d = d$ (since $h(G) \geq 1$).

**Lemma (cleaning_preserves_weight):** The cleaning process does not reduce fault weight.
*Proof:* The spacetime stabilizers used in cleaning (Lemma 6) preserve the parity of (Pauli faults + initialization faults) at each spacetime position. Thus total weight is preserved or increased.

**Main Theorem:** Combining the lemmas: any spacetime logical fault has weight at least $\min(d, t_o - t_i) = d$.
\end{proof}

\vspace{1em}
\hrule
\vspace{1em}

\subsection{Rem_17: HighWeightFluxChecks}
\label{Rem_17}

\noindent\textbf{Type:} Remark \hfill \textbf{Formalization Order:} 40/66

\noindent\textbf{Dependencies:} \hyperref[Thm_2]{Thm_2}

\begin{remark*}[HighWeightFluxChecks]
The fault-distance result (Theorem 2) holds even if:
(i) The flux checks $B_p$ have high weight
(ii) The $B_p$ checks are measured infrequently (less than every time step)
(iii) The $B_p$ detectors are only inferred once via initialization and final read-out

**Reason**: The proof of Theorem 2 only requires:
- $A_v$ syndromes to be local and frequently measured
- Deformed checks $\tilde{s}_j$ to be frequently measured
- $B_p$ information to be inferable (not necessarily directly measured)

**Caveat**: Without frequent $B_p$ measurements, the decoder has large detector cells for $B_p$ syndromes. This likely prevents a threshold against uncorrelated noise, but may still be useful for small fixed-size instances.
\end{remark*}

\vspace{1em}
\hrule
\vspace{1em}

\subsection{Rem_18: BoundaryConditions}
\label{Rem_18}

\noindent\textbf{Type:} Remark \hfill \textbf{Formalization Order:} 41/66

\noindent\textbf{Dependencies:} \hyperref[Thm_2]{Thm_2}

\begin{remark*}[BoundaryConditions]
The $d$ rounds of error correction in the original code before time $t_i$ and after time $t_o$ serve to establish clean boundary conditions for the fault-tolerance proof.

**Purpose**: Ensure that any fault pattern involving both:
- The gauging measurement ($t_i$ to $t_o$), and
- The initial or final boundary

has total weight $> d$.

**Practical consideration**: In a larger fault-tolerant computation, the gauging measurement is one component among many. The number of rounds before/after can be reduced based on the surrounding operations, but this may affect the effective distance and threshold.

**Idealization**: The proof assumes the first and last measurement rounds are perfect. This is a common proof technique and doesn't fundamentally change the results, given the $d$ buffer rounds.
\end{remark*}

\vspace{1em}
\hrule
\vspace{1em}

\subsection{Def_16: BivariateBicycleCode}
\label{Def_16}

\noindent\textbf{Type:} Definition \hfill \textbf{Formalization Order:} 42/66

\noindent\textbf{Dependencies:} \hyperref[Def_1]{Def_1}

\begin{definition*}[BivariateBicycleCode]
Let $\ell, m \in \mathbb{N}$ and define:
- $I_r$: the $r \times r$ identity matrix
- $C_r$: the $r \times r$ cyclic permutation matrix, $(C_r)_{ij} = [j \equiv i + 1 \pmod{r}]$
- $x = C_\ell \otimes I_m$ and $y = I_\ell \otimes C_m$

The matrices $x, y$ satisfy: $x^\ell = y^m = I_{\ell m}$, $xy = yx$, and $x^T x = y^T y = I_{\ell m}$.

A **Bivariate Bicycle (BB) code** is a CSS code on $n = 2\ell m$ physical qubits, divided into:
- $\ell m$ **left (L) qubits**
- $\ell m$ **right (R) qubits**

The parity check matrices are:
$$H_X = [A | B], \quad H_Z = [B^T | A^T]$$

where $A, B \in \mathbb{F}_2[x, y]$ are polynomials in $x$ and $y$ with coefficients in $\mathbb{F}_2$.

**Transpose convention**: $A^T = A(x, y)^T = A(x^{-1}, y^{-1})$ (inverse of $x$ is $x^{\ell-1}$, etc.)

**Labeling**: Checks and qubits are labeled by $(\alpha, T)$ for $\alpha \in \mathcal{M} = \{x^a y^b : a, b \in \mathbb{Z}\}$ and $T \in \{X, Z, L, R\}$.

**Check action**:
- X check $(\alpha, X)$ acts on qubits $(\alpha A, L)$ and $(\alpha B, R)$
- Z check $(\beta, Z)$ acts on qubits $(\beta B^T, L)$ and $(\beta A^T, R)$
\end{definition*}

\vspace{1em}
\hrule
\vspace{1em}

\subsection{Def_17: GrossCode}
\label{Def_17}

\noindent\textbf{Type:} Definition \hfill \textbf{Formalization Order:} 43/66

\noindent\textbf{Dependencies:} \hyperref[Def_16]{Def_16}

\begin{definition*}[GrossCode]
The **Gross code** is the $[[144, 12, 12]]$ Bivariate Bicycle code with parameters:
- $\ell = 12$, $m = 6$
- $A = x^3 + y^2 + y$
- $B = y^3 + x^2 + x$

The name comes from "gross" = 12 dozen = 144.

**Logical operators**: A basis of logical X operators is given by:
- $\overline{X}_\alpha = X(\alpha f, 0)$ where $f = 1 + x + x^2 + x^3 + x^6 + x^7 + x^8 + x^9 + (x + x^5 + x^7 + x^{11})y^3$
- $\overline{X}'_\beta = X(\beta g, \beta h)$ where:
  - $g = x + x^2 y + (1 + x)y^2 + x^2 y^3 + y^4$
  - $h = 1 + (1 + x)y + y^2 + (1 + x)y^3$

The logical Z operators are obtained by the BB code symmetry:
- $\overline{Z}_\beta = Z(\beta h^T, \beta g^T)$
- $\overline{Z}'_\alpha = Z(0, \alpha f^T)$

**Weight**: $|\overline{X}_\alpha| = |f| = 12$ (weight 12 logical).
\end{definition*}

\vspace{1em}
\hrule
\vspace{1em}

\subsection{Def_18: DoubleGrossCode}
\label{Def_18}

\noindent\textbf{Type:} Definition \hfill \textbf{Formalization Order:} 44/66

\noindent\textbf{Dependencies:} \hyperref[Def_16]{Def_16}

\begin{definition*}[DoubleGrossCode]
The **Double Gross code** is the $[[288, 12, 18]]$ Bivariate Bicycle code with parameters:
- $\ell = 12$, $m = 12$
- $A = x^3 + y^7 + y^2$
- $B = y^3 + x^2 + x$

**Logical operators**: The weight-18 logical X operators are:
$$\overline{X}_\alpha = X(\alpha f, 0)$$
where:
$$f = 1 + x + x^2 + x^7 + x^8 + x^9 + x^{10} + x^{11} + (1 + x^6 + x^8 + x^{10})y^3 + (x^5 + x^6 + x^9 + x^{10})y^6 + (x^4 + x^8)y^9$$

**Weight**: $|\overline{X}_\alpha| = |f| = 18$.
\end{definition*}

\vspace{1em}
\hrule
\vspace{1em}

\subsection{Prop_1: GrossCodeGaugingConstruction}
\label{Prop_1}

\noindent\textbf{Type:} Proposition \hfill \textbf{Formalization Order:} 45/66

\noindent\textbf{Dependencies:} \hyperref[Def_17]{Def_17}, \hyperref[Lem_2]{Lem_2}

\begin{proposition*}[GrossCodeGaugingConstruction]
For the Gross code $[[144, 12, 12]]$, there exists a gauging graph $G$ to measure $\overline{X}_\alpha$ with the following properties:

(i) **Vertices**: 12 vertices corresponding to the qubits in support of $\overline{X}_\alpha$ (the monomials in $f$)

(ii) **Matching edges (18 total)**: For each Z check overlapping the logical, connect vertices $\gamma, \delta \in f$ if they participate in the same Z check, i.e., $\gamma = B_i^T B_j \delta$ for some monomials $B_i, B_j \in B$

(iii) **Expansion edges (4 additional)**: Add edges to increase expansion until deformed code has distance 12. One valid choice:
$(x^2, x^5 y^3), (x^2, x^6), (x^5 y^3, x^{11} y^3), (x^7 y^3, x^{11} y^3)$

(iv) **Cycle basis**: $G$ has 12 vertices, 22 edges, so cycle rank = $22 - 12 + 1 = 11$. However, due to dependencies in BB code checks, only 7 independent $B_p$ checks are needed.

(v) **Overhead**: 12 new X checks ($A_v$), 7 new Z checks ($B_p$), 22 new qubits (edges). Total auxiliary: 41.

(vi) **Maximum degree**: All checks have weight $\leq 7$, all qubits have degree $\leq 7$.
\end{proposition*}

\begin{proof}
**Lemma (matching_ensures_sparse_M):** Connecting vertices in the same Z check ensures each row of matching matrix $M$ has weight 1.
*Proof:* By construction, each pair in a Z check's support is connected by an edge. So deforming the check requires traversing at most one edge.

**Lemma (expansion_preserves_distance):** Random edge additions were tested until deformed code distance = 12.
*Proof:* Use BP+OSD decoder for upper bounds on distance, integer programming for exact distance verification.

**Lemma (redundant_cycles):** Only 7 of the 11 cycle basis elements give independent $B_p$ checks.
*Proof:* Let $S$ = submatrix of $H_Z$ for checks overlapping $\overline{X}_\alpha$, $C$ = remaining checks. The dimension of $\{u : \exists v, uS + vC = 0\}$ equals row\_nullity$(H_Z)$ - row\_nullity$(C) = 4$. So 4 cycles are redundant.

**Lemma (specific_cycles):** The 7 independent cycles are listed explicitly (see paper for vertex sequences).
*Proof:* Direct verification that these cycles span the needed flux operators.

**Main Proposition:** The construction achieves distance-preserving gauging measurement with 41 auxiliary components.
\end{proof}

\vspace{1em}
\hrule
\vspace{1em}

\subsection{Prop_2: DoubleGrossCodeGaugingConstruction}
\label{Prop_2}

\noindent\textbf{Type:} Proposition \hfill \textbf{Formalization Order:} 46/66

\noindent\textbf{Dependencies:} \hyperref[Def_18]{Def_18}, \hyperref[Lem_2]{Lem_2}

\begin{proposition*}[DoubleGrossCodeGaugingConstruction]
For the Double Gross code $[[288, 12, 18]]$, there exists a gauging graph $G$ to measure $\overline{X}_\alpha$ with:

(i) **Vertices**: 18 vertices (support of $\overline{X}_\alpha$)

(ii) **Matching edges**: 27 edges from Z check overlaps

(iii) **Expansion edges**: 7 additional edges (including one multi-edge) to achieve distance 18. One valid choice:
$(x^4 y^9, x^9 y^6), (y^3, x^{11}), (x^7, x^{10} y^6), (x^8 y^3, x^{10} y^6), (1, x^8), (x^2, x^6 y^3)$ twice

(iv) **Cycle basis**: 13 independent cycles needed (out of 34 - 18 + 1 = 17 total)

(v) **Overhead**: 18 new X checks, 13 new Z checks, 34 new qubits. Total: 65.

(vi) **Maximum degree**: All checks have weight $\leq 7$, all qubits have degree $\leq 7$.
\end{proposition*}

\begin{proof}
The proof follows the same structure as Proposition 1, with explicit verification of distance preservation and cycle independence for the Double Gross code parameters.
\end{proof}

\vspace{1em}
\hrule
\vspace{1em}

\subsection{Rem_19: RelationToLatticeSurgery}
\label{Rem_19}

\noindent\textbf{Type:} Remark \hfill \textbf{Formalization Order:} 47/66

\noindent\textbf{Dependencies:} \hyperref[Thm_1]{Thm_1}, \hyperref[Rem_8]{Rem_8}

\begin{remark*}[RelationToLatticeSurgery]
The gauging measurement generalizes surface code lattice surgery:

**Surface code recovery**: Consider logical operators $\overline{X}_1 \otimes \overline{X}_2$ on the right and left edges of two adjacent surface code patches. Choosing the gauging graph $G$ as a **ladder** joining the edge qubits results in:
- The deformed code is a single larger surface code on the union of the patches
- The final edge measurement step is standard lattice surgery

**Non-adjacent patches**: For surface codes not directly adjacent, add a grid of **dummy vertices** between them in the gauging graph.

**Extension to general codes**: The same procedure works for any pair of matching logical X operators on two code blocks, provided:
- Each code block has the same choice of $G$ satisfying desiderata (ii) and (iii) from Remark 8
- "Bridge" edges connect the two copies of $G$

**Distance preservation**: The gauging measurement preserves distance when individual logicals have minimal weight and contain no sub-logical operators.
\end{remark*}

\vspace{1em}
\hrule
\vspace{1em}

\subsection{Rem_20: RelationToShorMeasurement}
\label{Rem_20}

\noindent\textbf{Type:} Remark \hfill \textbf{Formalization Order:} 48/66

\noindent\textbf{Dependencies:} \hyperref[Thm_1]{Thm_1}

\begin{remark*}[RelationToShorMeasurement]
The gauging measurement can recover Shor-style logical measurement:

**Shor-style setup**: Entangle an auxiliary GHZ state to the code via transversal CX gates, then measure X on auxiliary qubits.

**Gauging equivalent**: Use a graph $G$ with:
- A **dummy vertex** for each qubit in $\mathrm{supp}(L)$, each connected by an edge to the corresponding code qubit
- A **connected subgraph** on the dummy vertices

**Process**: If we measure the edges of the connected subgraph first (projecting dummies into a GHZ state), then measure the remaining edges, the result is equivalent to Shor-style measurement with $X$ measurements commuted backward through CX gates.
\end{remark*}

\vspace{1em}
\hrule
\vspace{1em}

\subsection{Rem_21: RelationToCohenEtAl}
\label{Rem_21}

\noindent\textbf{Type:} Remark \hfill \textbf{Formalization Order:} 49/66

\noindent\textbf{Dependencies:} \hyperref[Rem_14]{Rem_14}, \hyperref[Thm_1]{Thm_1}

\begin{remark*}[RelationToCohenEtAl]
The generalized (hypergraph) gauging measurement recovers the Cohen et al. scheme:

**Cohen et al. construction** (from reference [cohen2022low]):
- Restrict Z-type checks to support of an irreducible X logical
- Add $d$ layers of dummy vertices for each qubit in $\mathrm{supp}(L)$
- Connect copies of each vertex via line graphs
- Join vertices in each layer via a copy of the hypergraph

**Gauging interpretation**: This is exactly the generalized gauging measurement applied to the hypergraph defined by the restricted Z checks, with the specified layering structure.

**Cross et al. modification**: Use fewer than $d$ layers, exploiting expansion in the logical's Tanner subgraph.

**Product measurement**: The procedures in both references for measuring products of irreducible logicals are captured by adding edges between the corresponding ancilla graphs.
\end{remark*}

\vspace{1em}
\hrule
\vspace{1em}

\subsection{Rem_22: CSSCodeInitialization}
\label{Rem_22}

\noindent\textbf{Type:} Remark \hfill \textbf{Formalization Order:} 50/66

\noindent\textbf{Dependencies:} \hyperref[Rem_14]{Rem_14}

\begin{remark*}[CSSCodeInitialization]
The generalized (hypergraph) gauging measurement can implement CSS code initialization:

**Standard CSS initialization**: Prepare $|0\rangle^{\otimes n}$, then measure X-type checks.

**Gauging interpretation**:
- Start with a trivial code having one dummy vertex per X-type check
- Apply generalized gauging using the hypergraph corresponding to Z-type checks
- The "ungauging" step performs Z measurement on all qubits (read-out)

**Steane-style measurement**: Combine initialization gauging with a pairwise XX gauging measurement between data and ancilla blocks:
1. Initialize ancilla block via gauging (as above)
2. Apply gauging measurement of $XX$ on matching qubit pairs
3. Ungauge to read out Z on all ancilla qubits

This recovers Steane's method for fault-tolerant syndrome extraction.
\end{remark*}

\vspace{1em}
\hrule
\vspace{1em}

\subsection{Cor_1: QubitOverheadBound}
\label{Cor_1}

\noindent\textbf{Type:} Corollary \hfill \textbf{Formalization Order:} 51/66

\noindent\textbf{Dependencies:} \hyperref[Rem_9]{Rem_9}, \hyperref[Def_10]{Def_10}, \hyperref[Rem_6]{Rem_6}

\begin{corollary*}[QubitOverheadBound]
The gauging measurement procedure for an arbitrary Pauli operator $L$ of weight $W$ has worst-case qubit overhead $O(W \log^2 W)$.

Specifically, the number of auxiliary qubits (edge qubits in $\bar{\bar{G}}$) satisfies:
$$|E_{\bar{\bar{G}}}| = O(W \log^2 W)$$

Moreover, the deformed code is LDPC with check weight and qubit degree bounded by constants (depending on the original code's LDPC parameters).
\end{corollary*}

\begin{proof}
**Lemma (graph_construction):** By Remark 9, a suitable graph $G_0$ with $|V| = W$ and $h(G_0) \geq 1$ can be constructed with $|E_{G_0}| = O(W)$ edges.
*Proof:* Use matching edges plus constant-degree expander edges.

**Lemma (decongestion_bound):** The Freedman-Hastings decongestion lemma gives $R = O(\log^2 W)$ layers for cycle-sparsification.
*Proof:* This is the main result of [freedman2021building].

**Lemma (total_edge_count):** The cycle-sparsified graph has:
$$|E_{\bar{\bar{G}}}| = |E_{G_0}| + R \cdot |V| + (\text{cellulation edges}) = O(W) + O(\log^2 W) \cdot O(W) + O(W \log^2 W) = O(W \log^2 W)$$
*Proof:* Inter-layer edges: $R \cdot |V| = O(W \log^2 W)$. Cellulation adds $O(1)$ edges per cycle, with $O(W)$ cycles, so $O(W)$ total.

**Main Corollary:** The qubit overhead equals the edge count: $O(W \log^2 W)$.
\end{proof}

\vspace{1em}
\hrule
\vspace{1em}

\subsection{Rem_23: NonabelianGeneralization}
\label{Rem_23}

\noindent\textbf{Type:} Remark \hfill \textbf{Formalization Order:} 52/66

\noindent\textbf{Dependencies:} \hyperref[Thm_1]{Thm_1}

\begin{remark*}[NonabelianGeneralization]
The gauging measurement procedure can be generalized beyond Pauli operators:

**Finite group generalization**: The procedure applies to any representation of a finite group $G$ by operators with tensor product factorization. This includes:
- Qudit systems (using $\mathbb{Z}_d$ instead of $\mathbb{Z}_2$)
- Non-Pauli operators (e.g., Clifford operators in topological codes)
- Magic state preparation via measurement of non-Clifford operators

**Nonabelian case**: For nonabelian groups, measuring local charges does not fix a definite global charge. The total charge is a superposition consistent with local outcomes.

**Example**: Measurement of Clifford operators in topological codes (see [Davydova2024]) uses similar gauging ideas to produce magic states.
\end{remark*}

\vspace{1em}
\hrule
\vspace{1em}

\subsection{Lem_7: GaussLawConstraint}
\label{Lem_7}

\noindent\textbf{Type:} Lemma \hfill \textbf{Formalization Order:} 53/66

\noindent\textbf{Dependencies:} \hyperref[Def_6]{Def_6}

\begin{lemma*}[GaussLawConstraint]
Let $G = (V, E)$ be a gauging graph for X-type logical operator $L = \prod_{v \in \mathcal{L}} X_v$. The Gauss's law operators $\{A_v\}_{v \in V}$ satisfy the constraint:
$$\prod_{v \in V} A_v = L$$

This means the product of all $A_v$ measurement outcomes equals the measurement outcome of $L$:
$$\prod_{v \in V} \varepsilon_v = \sigma$$
where $\varepsilon_v \in \{\pm 1\}$ is the outcome of measuring $A_v$ and $\sigma$ is the eigenvalue of $L$.
\end{lemma*}

\begin{proof}
**Lemma (edge_cancellation):** In the product $\prod_{v \in V} A_v$, each edge qubit $X_e$ appears exactly twice.
*Proof:* Each edge $e = \{u, w\}$ has exactly two endpoints. So $X_e$ appears in $A_u$ and $A_w$, and nowhere else.

**Lemma (X_squared_identity):** $X_e^2 = I$ for all edges $e$.
*Proof:* Standard Pauli algebra.

**Main Lemma:** $\prod_{v \in V} A_v = \prod_{v \in V} \left(X_v \prod_{e \ni v} X_e\right) = \prod_{v \in V} X_v \cdot \prod_{e \in E} X_e^2 = L \cdot I = L$.
\end{proof}

\vspace{1em}
\hrule
\vspace{1em}

\subsection{Def_19: CSSCode}
\label{Def_19}

\noindent\textbf{Type:} Definition \hfill \textbf{Formalization Order:} 54/66

\noindent\textbf{Dependencies:} \hyperref[Def_1]{Def_1}

\begin{definition*}[CSSCode]
A **CSS (Calderbank-Shor-Steane) code** is a stabilizer code where every stabilizer generator is either purely X-type or purely Z-type.

Formally, an $[[n, k, d]]$ CSS code is specified by two classical linear codes:
- $C_X \subseteq \mathbb{F}_2^n$ with parity check matrix $H_X$
- $C_Z \subseteq \mathbb{F}_2^n$ with parity check matrix $H_Z$

satisfying the **CSS condition**: $H_X H_Z^T = 0$ (equivalently, $C_Z^\perp \subseteq C_X$).

**Stabilizer generators**:
- X-type: $\{\prod_{i : (H_X)_{j,i} = 1} X_i\}$ for each row $j$ of $H_X$
- Z-type: $\{\prod_{i : (H_Z)_{j,i} = 1} Z_i\}$ for each row $j$ of $H_Z$

**Code parameters**:
- $n$ = number of physical qubits
- $k = \dim(C_X) + \dim(C_Z) - n$ = number of logical qubits
- $d = \min(d_X, d_Z)$ where $d_X = \min\{|c| : c \in C_X \setminus C_Z^\perp\}$ and $d_Z = \min\{|c| : c \in C_Z \setminus C_X^\perp\}$
\end{definition*}

\vspace{1em}
\hrule
\vspace{1em}

\subsection{Lem_8: CommutationConditionPauli}
\label{Lem_8}

\noindent\textbf{Type:} Lemma \hfill \textbf{Formalization Order:} 55/66

\noindent\textbf{Dependencies:} \hyperref[Rem_1]{Rem_1}

\begin{lemma*}[CommutationConditionPauli]
Let $P = i^{\sigma_P} \prod_v X_v^{a_v} Z_v^{b_v}$ and $Q = i^{\sigma_Q} \prod_v X_v^{c_v} Z_v^{d_v}$ be two Pauli operators.

Then $P$ and $Q$ commute ($[P, Q] = 0$) if and only if:
$$\sum_v (a_v d_v + b_v c_v) \equiv 0 \pmod{2}$$

Equivalently, using support notation:
$$|\mathcal{S}_X(P) \cap \mathcal{S}_Z(Q)| + |\mathcal{S}_Z(P) \cap \mathcal{S}_X(Q)| \equiv 0 \pmod{2}$$

This is the **symplectic inner product** condition.
\end{lemma*}

\begin{proof}
**Lemma (single_qubit_anticommutation):** On a single qubit, $X$ and $Z$ anticommute: $XZ = -ZX$.
*Proof:* Direct calculation using Pauli matrices.

**Lemma (commutation_accumulation):** When computing $PQ$ vs $QP$, each site $v$ where $P$ acts by $X$ (or $Y$) and $Q$ acts by $Z$ (or $Y$) contributes a factor of $-1$.
*Proof:* If $P$ has $X$ factor at $v$ and $Q$ has $Z$ factor at $v$, swapping their order gives $-1$.

**Main Lemma:** Total sign from swapping = $(-1)^{\sum_v (a_v d_v + b_v c_v)}$. Commutation requires this to be $+1$, i.e., exponent even.
\end{proof}

\vspace{1em}
\hrule
\vspace{1em}

\subsection{Prop_3: FluxOperatorCommutation}
\label{Prop_3}

\noindent\textbf{Type:} Proposition \hfill \textbf{Formalization Order:} 56/66

\noindent\textbf{Dependencies:} \hyperref[Def_6]{Def_6}, \hyperref[Def_7]{Def_7}, \hyperref[Lem_8]{Lem_8}

\begin{proposition*}[FluxOperatorCommutation]
The flux operators $\{B_p\}_{p \in C}$ commute with all Gauss's law operators $\{A_v\}_{v \in V}$:
$$[A_v, B_p] = 0 \quad \text{for all } v \in V, p \in C$$
\end{proposition*}

\begin{proof}
**Lemma (support_intersection):** The X-support of $A_v$ on edge qubits is $\{e : v \in e\}$ (edges incident to $v$). The Z-support of $B_p$ on edge qubits is $p$ (edges in the cycle).
*Proof:* By definition of $A_v = X_v \prod_{e \ni v} X_e$ and $B_p = \prod_{e \in p} Z_e$.

**Lemma (cycle_incidence_parity):** For any vertex $v$ and cycle $p$: $|\{e \in p : v \in e\}| \equiv 0 \pmod{2}$.
*Proof:* A cycle visits each vertex an even number of times (entering and leaving). So $v$ is incident to an even number of edges in $p$.

**Main Proposition:** By Lemma 8 (symplectic inner product), $[A_v, B_p] = 0$ iff $|\mathcal{S}_X(A_v) \cap \mathcal{S}_Z(B_p)| \equiv 0 \pmod{2}$. This equals $|\{e \in p : v \in e\}| \equiv 0$ by the cycle parity lemma.
\end{proof}

\vspace{1em}
\hrule
\vspace{1em}

\subsection{Def_20: SubsystemCode}
\label{Def_20}

\noindent\textbf{Type:} Definition \hfill \textbf{Formalization Order:} 57/66

\noindent\textbf{Dependencies:} \hyperref[Def_1]{Def_1}

\begin{definition*}[SubsystemCode]
A **subsystem code** is a generalization of a stabilizer code where the code space factors as:
$$\mathcal{C} = \mathcal{C}_{\text{logical}} \otimes \mathcal{C}_{\text{gauge}}$$

**Components**:
- **Gauge group** $\mathcal{G}$: A (generally non-abelian) subgroup of the Pauli group
- **Stabilizer group** $\mathcal{S} = Z(\mathcal{G}) \cap \mathcal{G}$: The center of the gauge group intersected with itself (abelian)
- **Code space**: Simultaneous $+1$ eigenspace of all stabilizers in $\mathcal{S}$
- **Gauge qubits**: Degrees of freedom in $\mathcal{C}_{\text{gauge}}$, not used for logical information

**Gauge fixing**: A subsystem code can be converted to a stabilizer code by measuring gauge operators, collapsing $\mathcal{C}_{\text{gauge}}$ to a definite state.

The deformed code after gauging is a subsystem code when $|E| > |V| - 1$, with gauge degrees of freedom on the edge qubits.
\end{definition*}

\vspace{1em}
\hrule
\vspace{1em}

\subsection{Rem_24: AlgorithmCorrectness}
\label{Rem_24}

\noindent\textbf{Type:} Remark \hfill \textbf{Formalization Order:} 58/66

\noindent\textbf{Dependencies:} \hyperref[Thm_1]{Thm_1}

\begin{remark*}[AlgorithmCorrectness]
Algorithm 1 (Gauging measurement procedure) produces the correct post-measurement state up to a byproduct operator $X_V(c')$.

**Byproduct determination**: The byproduct $c' \in C_0(G; \mathbb{Z}_2)$ is determined by the $Z_e$ measurement outcomes $\{\omega_e\}$:
$$c' = \text{any 0-chain satisfying } \delta_0(c') = z$$
where $z_e = \frac{1 - \omega_e}{2} \in \{0, 1\}$ encodes the measurement outcome.

**Constructive determination**: Given a spanning tree $T$ of $G$ rooted at $v_0$:
- For each vertex $v \neq v_0$, let $\gamma_v$ be the unique path in $T$ from $v_0$ to $v$
- Set $c'_v = \bigoplus_{e \in \gamma_v} z_e$ (parity of outcomes along path)
- Set $c'_{v_0} = 0$

This gives $\delta_0(c') = z$ because tree paths have the required boundary property.
\end{remark*}

\vspace{1em}
\hrule
\vspace{1em}

\subsection{Lem_9: CycleRankFormula}
\label{Lem_9}

\noindent\textbf{Type:} Lemma \hfill \textbf{Formalization Order:} 59/66

\noindent\textbf{Dependencies:} \hyperref[Def_4]{Def_4}

\begin{lemma*}[CycleRankFormula]
For a connected graph $G = (V, E)$, the **cycle rank** (also called **cyclomatic number** or **first Betti number**) is:
$$\beta_1(G) = |E| - |V| + 1$$

This equals:
(i) The dimension of $\ker(\partial_1)$ (space of 1-cycles)
(ii) The number of edges not in any spanning tree
(iii) The minimum number of edges that must be removed to make $G$ acyclic
\end{lemma*}

\begin{proof}
**Lemma (spanning_tree_edges):** A spanning tree of $G$ has exactly $|V| - 1$ edges.
*Proof:* A tree on $n$ vertices has $n - 1$ edges. A spanning tree includes all $|V|$ vertices.

**Lemma (non_tree_edges_create_cycles):** Each edge $e \notin T$ (where $T$ is a spanning tree) creates a unique fundamental cycle.
*Proof:* Adding $e$ to $T$ creates exactly one cycle, since $T$ is connected and acyclic.

**Lemma (fundamental_cycles_span):** The fundamental cycles form a basis for the cycle space.
*Proof:* They are linearly independent (each contains a unique non-tree edge). Any cycle can be written as a symmetric difference of fundamental cycles.

**Main Lemma:** Number of non-tree edges = $|E| - (|V| - 1) = |E| - |V| + 1 = \beta_1(G)$.
\end{proof}

\vspace{1em}
\hrule
\vspace{1em}

\subsection{Def_21: TannerGraph}
\label{Def_21}

\noindent\textbf{Type:} Definition \hfill \textbf{Formalization Order:} 60/66

\noindent\textbf{Dependencies:} \hyperref[Def_1]{Def_1}

\begin{definition*}[TannerGraph]
The **Tanner graph** of a stabilizer code is a bipartite graph $T = (Q \cup C, E_T)$ where:
- $Q$ = set of qubit nodes (one per physical qubit)
- $C$ = set of check nodes (one per stabilizer generator)
- $E_T$ = edges connecting qubit $q$ to check $c$ iff $c$ acts non-trivially on $q$

**For CSS codes**: The Tanner graph can be split into X-type and Z-type subgraphs:
- $T_X$: connects qubits to X-type checks
- $T_Z$: connects qubits to Z-type checks

**LDPC condition**: A code is LDPC iff its Tanner graph has bounded degree (both qubit and check degrees bounded by constants).

**Deformed code Tanner graph** (Figure 1 in paper): Shows the structure after gauging, with additional Gauss's law checks $\mathcal{A}$, flux checks $\mathcal{B}$, and edge qubits $\mathcal{E}$.
\end{definition*}

\vspace{1em}
\hrule
\vspace{1em}

\subsection{Rem_25: MatchingMatrixM}
\label{Rem_25}

\noindent\textbf{Type:} Remark \hfill \textbf{Formalization Order:} 61/66

\noindent\textbf{Dependencies:} \hyperref[Lem_1]{Lem_1}, \hyperref[Def_9]{Def_9}

\begin{remark*}[MatchingMatrixM]
The **matching matrix** $M$ in the deformed code Tanner graph (Figure 1) encodes how original checks are deformed by paths in $G$.

**Structure**: $M$ is a binary matrix with:
- Rows indexed by checks in $\mathcal{S}$ (checks with Z-support on $L$)
- Columns indexed by edges in $G$
- $M_{j,e} = 1$ iff edge $e$ is in the deforming path $\gamma_j$ for check $s_j$

**Optimization goal**: Choose paths $\{\gamma_j\}$ to minimize:
- Row weight of $M$ (path lengths)
- Column weight of $M$ (edge participation in multiple paths)

**Perfect matching approach**: When $|\mathcal{S}_{Z,j} \cap V| = 2$ for all checks $s_j \in \mathcal{S}$, a $\mathbb{Z}_2$-perfect-matching ensures each row of $M$ has weight 1.
\end{remark*}

\vspace{1em}
\hrule
\vspace{1em}

\subsection{Lem_10: RedundantCyclesInBBCode}
\label{Lem_10}

\noindent\textbf{Type:} Lemma \hfill \textbf{Formalization Order:} 62/66

\noindent\textbf{Dependencies:} \hyperref[Def_16]{Def_16}, \hyperref[Lem_1]{Lem_1}

\begin{lemma*}[RedundantCyclesInBBCode]
For a Bivariate Bicycle code with parity check matrices $H_X = [A|B]$ and $H_Z = [B^T|A^T]$, when measuring logical $\overline{X}_\alpha$ supported on left qubits, the number of redundant cycles in the gauging graph is:
$$\dim\{u : \exists v, uS + vC = 0\} = \mathrm{row\_nullity}(H_Z) - \mathrm{row\_nullity}(C)$$

where:
- $S$ = submatrix of $H_Z$ with rows for checks overlapping $\overline{X}_\alpha$
- $C$ = submatrix of $H_Z$ with rows for checks not overlapping $\overline{X}_\alpha$
\end{lemma*}

\begin{proof}
**Lemma (cycle_from_check_relation):** If $uS + vC = 0$ for vectors $u, v$, then the product of checks $\prod_{j : u_j = 1} \tilde{s}_j \cdot \prod_{j : v_j = 1} s_j$ has support only on edge qubits.
*Proof:* The $uS + vC = 0$ condition means the Z-supports cancel on original qubits. After deformation, only edge Z-support remains.

**Lemma (edge_support_is_cycle):** The edge support of this product is a cycle in $G$.
*Proof:* The product is a stabilizer (product of stabilizers). It has no original qubit support. So it must be a product of $B_p$ operators, meaning its edge support is a union of cycles.

**Main Lemma:** The dimension of redundant cycles equals the dimension of solutions $(u, v)$ to $uS + vC = 0$, which is row\_nullity$(H_Z)$ - row\_nullity$(C)$.
\end{proof}

\vspace{1em}
\hrule
\vspace{1em}

\subsection{Cor_2: GrossCodeRedundantCycles}
\label{Cor_2}

\noindent\textbf{Type:} Corollary \hfill \textbf{Formalization Order:} 63/66

\noindent\textbf{Dependencies:} \hyperref[Lem_10]{Lem_10}, \hyperref[Def_17]{Def_17}

\begin{corollary*}[GrossCodeRedundantCycles]
For the Gross code $[[144, 12, 12]]$ with logical $\overline{X}_\alpha$ (weight 12), the gauging graph $G$ with 12 vertices and 22 edges has:
- Cycle rank: $22 - 12 + 1 = 11$
- Redundant cycles: $4$
- Independent flux checks needed: $11 - 4 = 7$
\end{corollary*}

\begin{proof}
**Direct calculation**: Apply Lemma 10 to the Gross code parameters:
- row\_nullity$(H_Z) = 144 - (144 - 12)/2 = 78$ (from $k = 12$)
- row\_nullity$(C)$ computed from the submatrix of checks not overlapping $\overline{X}_\alpha$
- Difference = $4$
\end{proof}

\vspace{1em}
\hrule
\vspace{1em}

\subsection{Rem_26: DecoderRequirements}
\label{Rem_26}

\noindent\textbf{Type:} Remark \hfill \textbf{Formalization Order:} 64/66

\noindent\textbf{Dependencies:} \hyperref[Thm_2]{Thm_2}

\begin{remark*}[DecoderRequirements]
Decoding the fault-tolerant gauging measurement requires handling several types of syndromes:

**Syndrome types**:
(i) $A_v$ syndromes: Created by $Z$ errors on vertex and edge qubits
(ii) $B_p$ syndromes: Created by $X$ errors on edge qubits
(iii) $\tilde{s}_j$ syndromes: Created by both $X$ and $Z$ errors on vertex and edge qubits

**Decoder approaches**:
- **General-purpose**: Belief propagation with ordered statistics post-processing (BP+OSD)
- **Structured**: Matching on $A_v$ syndromes (similar to surface code), combined with code-specific decoding for $\tilde{s}_j$

**Open question**: Designing decoders that exploit the structure of the gauging measurement for improved performance.
\end{remark*}

\vspace{1em}
\hrule
\vspace{1em}

\subsection{Rem_27: ComparisonToPriorWork}
\label{Rem_27}

\noindent\textbf{Type:} Remark \hfill \textbf{Formalization Order:} 65/66

\noindent\textbf{Dependencies:} \hyperref[Cor_1]{Cor_1}, \hyperref[Prop_1]{Prop_1}

\begin{remark*}[ComparisonToPriorWork]
Comparison of qubit overhead for logical measurement schemes:

**Cohen et al. [cohen2022low]**: Overhead $\Theta(Wd)$ where $W$ = logical weight, $d$ = code distance
- For good codes with $d = \Theta(n)$: overhead $\Theta(n^2)$

**Cross et al. [cross2024linear]**: Overhead $\Theta(W)$ when:
- Sufficient expansion in the logical's Tanner subgraph
- Low-weight auxiliary gauge-fixing checks exist

**This work (gauging measurement)**: Overhead $O(W \log^2 W)$
- Always achievable via cycle-sparsification
- Often better in practice (e.g., Gross code: 41 vs larger overhead for prior methods)

**Key advantage**: The flexibility in choosing the gauging graph $G$ allows optimization for specific code instances.
\end{remark*}

\vspace{1em}
\hrule
\vspace{1em}

\subsection{Prop_4: BBCodeSymmetry}
\label{Prop_4}

\noindent\textbf{Type:} Proposition \hfill \textbf{Formalization Order:} 66/66

\noindent\textbf{Dependencies:} \hyperref[Def_16]{Def_16}

\begin{proposition*}[BBCodeSymmetry]
Bivariate Bicycle codes have a symmetry between left and right qubits that relates X-type and Z-type logical operators:

If $\overline{X} = X(p, q)$ is a logical X operator (acting on left qubits $(p, L)$ and right qubits $(q, R)$), then:
$$\overline{Z} = Z(q^T, p^T)$$
is the corresponding logical Z operator, where $p^T = p(x^{-1}, y^{-1})$.

**Consequence for gauging**: A gauging graph construction for measuring $\overline{X}_\alpha = X(\alpha f, 0)$ also works for measuring $\overline{Z}'_\alpha = Z(0, \alpha f^T)$ with the roles of left and right qubits swapped.
\end{proposition*}

\begin{proof}
**Lemma (parity_check_symmetry):** $H_X = [A|B]$ and $H_Z = [B^T|A^T]$ implies: if $H_X \cdot (p, q)^T = 0$, then $H_Z \cdot (q^T, p^T)^T = 0$.
*Proof:* $H_Z \cdot (q^T, p^T)^T = B^T q^T + A^T p^T = (qB + pA)^T = (H_X \cdot (p, q)^T)^T = 0$.

**Lemma (commutation_preserved):** The symplectic inner product is preserved: $\langle X(p,q), Z(r,s) \rangle = \langle X(s^T, r^T), Z(q^T, p^T) \rangle$.
*Proof:* Both equal $p \cdot r + q \cdot s$ (dot product mod 2).

**Main Proposition:** The symmetry $(p, q) \mapsto (q^T, p^T)$ preserves the logical operator structure, swapping X and Z types.
\end{proof}

\vspace{1em}
\hrule
\vspace{1em}


\newpage
\section{Summary by Type}

\begin{itemize}
  \item \textbf{Corollarys:} 2
  \item \textbf{Definitions:} 21
  \item \textbf{Lemmas:} 10
  \item \textbf{Propositions:} 4
  \item \textbf{Remarks:} 27
  \item \textbf{Theorems:} 2
  \item \textbf{Total:} 66
\end{itemize}

\end{document}
