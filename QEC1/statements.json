{
  "statements": [
    {
      "id": "Rem_1",
      "type": "Remark",
      "name": "NotationConventions",
      "content": "Throughout this work, we use the following notation and conventions:\n\n(i) **Pauli operators**: For a qubit system on $n$ qubits, the Pauli group is generated by single-qubit operators $X_i, Y_i, Z_i$ for $i \\in \\{1, \\ldots, n\\}$ satisfying $X_i^2 = Y_i^2 = Z_i^2 = I$, $X_i Y_i = i Z_i$, and operators on different qubits commute.\n\n(ii) **Stabilizer code**: An $[[n, k, d]]$ stabilizer code is a $2^k$-dimensional subspace of the $n$-qubit Hilbert space $(\\mathbb{C}^2)^{\\otimes n}$ defined as the simultaneous $+1$ eigenspace of an abelian subgroup $\\mathcal{S}$ of the $n$-qubit Pauli group, where $-I \\notin \\mathcal{S}$. The parameters are: $n$ = number of physical qubits, $k$ = number of encoded logical qubits, $d$ = code distance.\n\n(iii) **Code distance**: The distance $d$ is the minimum weight of a Pauli operator that commutes with all stabilizers but is not itself a stabilizer: $d = \\min\\{|P| : P \\in N(\\mathcal{S}) \\setminus \\mathcal{S}\\}$, where $|P|$ denotes the weight (number of non-identity tensor factors) and $N(\\mathcal{S})$ is the normalizer of $\\mathcal{S}$.\n\n(iv) **Support notation**: For a Pauli operator $P = i^\\sigma \\prod_v X_v^{a_v} Z_v^{b_v}$, the X-type support is $\\mathcal{S}_X(P) = \\{v : a_v = 1\\}$ and the Z-type support is $\\mathcal{S}_Z(P) = \\{v : b_v = 1\\}$. Note: $Y_v = i X_v Z_v$, so $Y$ contributes to both supports.\n\n(v) **$\\mathbb{Z}_2$-arithmetic**: All sums of binary vectors are computed modulo 2. We identify a subset $S \\subseteq V$ with the binary vector $(\\mathbf{1}_S)_v = [v \\in S] \\in \\mathbb{Z}_2^{|V|}$.",
      "proof": null,
      "dependencies": [],
      "number": 1
    },
    {
      "id": "Def_1",
      "type": "Definition",
      "name": "StabilizerCode",
      "content": "Let $n, k, d \\in \\mathbb{N}$ with $k < n$. An **$[[n, k, d]]$ stabilizer code** is specified by the following data:\n\n(i) **Physical qubits**: A set of $n$ qubits indexed by $\\{1, \\ldots, n\\}$, with Hilbert space $\\mathcal{H} = (\\mathbb{C}^2)^{\\otimes n}$.\n\n(ii) **Check operators**: A set of Pauli operators $\\{s_i\\}_{i=1}^{n-k}$ called stabilizer checks, where each $s_i = i^{\\sigma_i} \\prod_{v \\in \\mathcal{S}_{X,i}} X_v \\prod_{v \\in \\mathcal{S}_{Z,i}} Z_v$ for some $\\sigma_i \\in \\{0, 1, 2, 3\\}$ and subsets $\\mathcal{S}_{X,i}, \\mathcal{S}_{Z,i} \\subseteq \\{1, \\ldots, n\\}$.\n\n(iii) **Commutativity**: The checks mutually commute: $[s_i, s_j] = 0$ for all $i, j$, which is equivalent to $|\\mathcal{S}_{X,i} \\cap \\mathcal{S}_{Z,j}| + |\\mathcal{S}_{Z,i} \\cap \\mathcal{S}_{X,j}| \\equiv 0 \\pmod{2}$.\n\n(iv) **Independence**: The checks are independent: $\\prod_{i \\in T} s_i = I$ implies $T = \\emptyset$.\n\n(v) **Code space**: The code space is $\\mathcal{C} = \\{|\\psi\\rangle \\in \\mathcal{H} : s_i|\\psi\\rangle = |\\psi\\rangle \\text{ for all } i\\}$, which has dimension $\\dim(\\mathcal{C}) = 2^k$.\n\n(vi) **Distance condition**: Every Pauli operator $P$ that commutes with all $s_i$ but is not a product of checks has weight $|P| \\geq d$.\n\nThe code is called **LDPC** (low-density parity-check) if there exist constants $w, \\Delta$ such that each check $s_i$ has weight $\\leq w$ and each qubit participates in $\\leq \\Delta$ checks.",
      "proof": null,
      "dependencies": ["Rem_1"],
      "number": 1
    },
    {
      "id": "Def_2",
      "type": "Definition",
      "name": "LogicalOperator",
      "content": "Let $\\mathcal{C}$ be an $[[n, k, d]]$ stabilizer code with check operators $\\{s_i\\}$.\n\nA **logical operator** is a Pauli operator $L$ such that:\n(i) $L$ commutes with all stabilizer checks: $[L, s_i] = 0$ for all $i$.\n(ii) $L$ is not a product of stabilizer checks: $L \\notin \\langle s_1, \\ldots, s_{n-k} \\rangle$.\n\nA **logical representative** is a specific choice of Pauli operator $L$ representing a logical operator. Two logical representatives $L$ and $L'$ are **equivalent** if $L' = L \\cdot \\prod_{i \\in T} s_i$ for some $T \\subseteq \\{1, \\ldots, n-k\\}$.\n\nThe **weight** of a logical operator is $|L| = |\\mathcal{S}_X(L) \\cup \\mathcal{S}_Z(L)|$, the number of qubits on which $L$ acts non-trivially.\n\nThe code distance satisfies $d = \\min\\{|L| : L \\text{ is a logical operator}\\}$.\n\nBy choosing an appropriate single-qubit basis for each physical qubit, any logical operator can be assumed to be **X-type**, i.e., $L = \\prod_{v \\in \\mathcal{L}} X_v$ for some $\\mathcal{L} \\subseteq \\{1, \\ldots, n\\}$.",
      "proof": null,
      "dependencies": ["Def_1"],
      "number": 2
    },
    {
      "id": "Def_3",
      "type": "Definition",
      "name": "GaugingGraph",
      "content": "Let $\\mathcal{C}$ be an $[[n, k, d]]$ stabilizer code and let $L = \\prod_{v \\in \\mathcal{L}} X_v$ be an X-type logical operator with support $\\mathcal{L}$.\n\nA **gauging graph** for $L$ is a connected graph $G = (V, E)$ such that:\n(i) **Vertices**: $V \\supseteq \\mathcal{L}$, with an isomorphism identifying $\\mathcal{L}$ with a subset of vertices.\n(ii) **Connectivity**: $G$ is connected.\n(iii) **Edge qubits**: Each edge $e \\in E$ corresponds to an auxiliary qubit.\n\nThe graph $G$ may contain **dummy vertices** $V \\setminus \\mathcal{L}$, which correspond to auxiliary qubits initialized in the $|+\\rangle$ state and on which $X$ is measured with certain outcome $+1$.\n\n**Graph parameters**:\n- $|V|$ = number of vertices (includes support of $L$ plus dummy vertices)\n- $|E|$ = number of edges (equals number of auxiliary qubits)\n- The **cycle rank** of $G$ is $|E| - |V| + 1$ (number of independent cycles)",
      "proof": null,
      "dependencies": ["Def_1", "Def_2"],
      "number": 3
    },
    {
      "id": "Def_4",
      "type": "Definition",
      "name": "ChainSpacesBoundaryMaps",
      "content": "Let $G = (V, E)$ be a finite connected graph and let $C$ be a chosen collection of generating cycles for $G$.\n\nWe define the following $\\mathbb{Z}_2$-vector spaces and linear maps:\n\n(i) **Chain spaces**:\n- $C_0(G; \\mathbb{Z}_2) = \\mathbb{Z}_2^V$ is the space of **0-chains** (formal sums of vertices)\n- $C_1(G; \\mathbb{Z}_2) = \\mathbb{Z}_2^E$ is the space of **1-chains** (formal sums of edges)\n- $C_2(G; \\mathbb{Z}_2) = \\mathbb{Z}_2^C$ is the space of **2-chains** (formal sums of cycles)\n\nWe identify a subset $S \\subseteq V$ with the 0-chain $\\sum_{v \\in S} v \\in C_0$.\n\n(ii) **Boundary map** $\\partial_1: C_1(G; \\mathbb{Z}_2) \\to C_0(G; \\mathbb{Z}_2)$ is the $\\mathbb{Z}_2$-linear map defined on basis elements by:\n$$\\partial_1(e) = v + v'$$\nwhere $e = \\{v, v'\\}$ is an edge with endpoints $v, v'$. For an edge-path $\\gamma = \\{e_1, \\ldots, e_m\\} \\subseteq E$: $\\partial_1(\\gamma) = \\sum_{e \\in \\gamma} \\partial_1(e)$.\n\n(iii) **Second boundary map** $\\partial_2: C_2(G; \\mathbb{Z}_2) \\to C_1(G; \\mathbb{Z}_2)$ is defined by:\n$$\\partial_2(c) = \\sum_{e \\in c} e$$\nfor a cycle $c$ viewed as a set of edges.\n\n(iv) **Coboundary maps** are the transposes:\n- $\\delta_0 = \\partial_1^T: C_0(G; \\mathbb{Z}_2) \\to C_1(G; \\mathbb{Z}_2)$ satisfies $\\delta_0(v) = \\sum_{e \\ni v} e$ (sum over edges incident to $v$)\n- $\\delta_1 = \\partial_2^T: C_1(G; \\mathbb{Z}_2) \\to C_2(G; \\mathbb{Z}_2)$ satisfies $\\delta_1(e) = \\sum_{c \\ni e} c$ (sum over cycles containing $e$)\n\n(v) **Key identity**: $\\partial_1 \\circ \\partial_2 = 0$, i.e., the boundary of a cycle is zero.",
      "proof": null,
      "dependencies": ["Def_3"],
      "number": 4
    },
    {
      "id": "Rem_2",
      "type": "Remark",
      "name": "ExactnessOfChainComplex",
      "content": "Let $G = (V, E)$ be a connected graph with a chosen generating set of cycles $C$.\n\nThe chain complex $C_2 \\xrightarrow{\\partial_2} C_1 \\xrightarrow{\\partial_1} C_0$ satisfies:\n\n(i) **Exactness at $C_1$**: If $C$ is a generating set of cycles, then $\\ker(\\partial_1) = \\mathrm{im}(\\partial_2)$. This means: an edge-set $\\gamma \\subseteq E$ satisfies $\\partial_1(\\gamma) = 0$ (i.e., every vertex has even degree in $\\gamma$) if and only if $\\gamma$ is a $\\mathbb{Z}_2$-linear combination of the generating cycles.\n\n(ii) **Exactness at $C_0$ (almost)**: $\\mathrm{im}(\\partial_1) = \\{c \\in C_0 : |c| \\equiv 0 \\pmod{2}\\}$, the set of 0-chains with even cardinality. Equivalently, $\\ker(\\delta_0) = \\mathbb{Z}_2 \\cdot \\mathbf{1}_V$ (the all-ones vector) for connected $G$.\n\n(iii) **Dual exactness**: For the coboundary sequence $C_0 \\xrightarrow{\\delta_0} C_1 \\xrightarrow{\\delta_1} C_2$:\n- $\\ker(\\delta_0) = \\mathbb{Z}_2 \\cdot \\mathbf{1}_V$ (all vertices or no vertices)\n- $\\ker(\\delta_1) = \\mathrm{im}(\\delta_0)$ when $C$ generates all cycles\n\nThese exactness conditions are crucial for proving properties of the deformed code.",
      "proof": null,
      "dependencies": ["Def_4"],
      "number": 2
    },
    {
      "id": "Def_5",
      "type": "Definition",
      "name": "CheegerConstant",
      "content": "Let $G = (V, E)$ be a finite graph with vertex set $V$ and edge set $E$.\n\nFor a subset $S \\subseteq V$, the **edge boundary** of $S$ is:\n$$\\delta(S) = \\{e \\in E : |e \\cap S| = 1\\}$$\nthe set of edges with exactly one endpoint in $S$.\n\nThe **Cheeger constant** (also called **isoperimetric number** or **expansion**) of $G$ is:\n$$h(G) = \\min_{\\substack{S \\subseteq V \\\\ 0 < |S| \\leq |V|/2}} \\frac{|\\delta(S)|}{|S|}$$\n\n**Properties**:\n(i) $h(G) \\geq 0$ with equality iff $G$ is disconnected.\n(ii) For any $S$ with $0 < |S| \\leq |V|/2$: $|\\delta(S)| \\geq h(G) \\cdot |S|$.\n(iii) A graph is called an **expander** if $h(G) \\geq c$ for some constant $c > 0$ independent of $|V|$.\n(iv) $h(G) \\leq \\min_v \\deg(v)$ where $\\deg(v)$ is the degree of vertex $v$.\n\n**Equivalently**, $h(G)$ measures how 'well-connected' the graph is: a larger Cheeger constant means the graph cannot be easily partitioned into disconnected pieces.",
      "proof": null,
      "dependencies": ["Def_3"],
      "number": 5
    },
    {
      "id": "Def_6",
      "type": "Definition",
      "name": "GaussLawOperators",
      "content": "Let $\\mathcal{C}$ be an $[[n, k, d]]$ stabilizer code, $L = \\prod_{v \\in \\mathcal{L}} X_v$ an X-type logical operator, and $G = (V, E)$ a gauging graph for $L$.\n\nThe **Gauss's law operators** are the set $\\mathcal{A} = \\{A_v\\}_{v \\in V}$ where each $A_v$ is defined as:\n$$A_v = X_v \\prod_{e \\ni v} X_e$$\n\nHere:\n- $X_v$ acts on the vertex qubit (the original code qubit if $v \\in \\mathcal{L}$, or an auxiliary qubit initialized in $|+\\rangle$ if $v$ is a dummy vertex)\n- $X_e$ acts on the auxiliary edge qubit corresponding to edge $e$\n- The product $\\prod_{e \\ni v}$ is over all edges incident to vertex $v$\n\n**Properties**:\n(i) Each $A_v$ is Hermitian with eigenvalues $\\pm 1$.\n(ii) The operators $\\{A_v\\}$ mutually commute: $[A_v, A_{v'}] = 0$ for all $v, v' \\in V$.\n(iii) They satisfy the constraint: $\\prod_{v \\in V} A_v = L \\cdot \\prod_{e \\in E} X_e^2 = L$ (since $X_e^2 = I$).\n(iv) The $A_v$ generate an abelian group of order $2^{|V|-1}$ (one constraint reduces independence).",
      "proof": null,
      "dependencies": ["Def_3", "Def_4"],
      "number": 6
    },
    {
      "id": "Def_7",
      "type": "Definition",
      "name": "FluxOperators",
      "content": "Let $\\mathcal{C}$ be an $[[n, k, d]]$ stabilizer code, $L$ an X-type logical operator, $G = (V, E)$ a gauging graph, and $C = \\{p_1, \\ldots, p_c\\}$ a generating set of cycles for $G$.\n\nThe **flux operators** are the set $\\mathcal{B} = \\{B_p\\}_{p \\in C}$ where each $B_p$ is defined as:\n$$B_p = \\prod_{e \\in p} Z_e$$\n\nHere:\n- $p \\subseteq E$ is a cycle in $G$ (a set of edges forming a closed path)\n- $Z_e$ acts on the auxiliary edge qubit corresponding to edge $e$\n- The product is over all edges in the cycle $p$\n\n**Properties**:\n(i) Each $B_p$ is Hermitian with eigenvalues $\\pm 1$.\n(ii) The operators $\\{B_p\\}$ mutually commute: $[B_p, B_{p'}] = 0$ for all $p, p' \\in C$.\n(iii) $[A_v, B_p] = 0$ for all $v \\in V$ and $p \\in C$.\n   *Verification*: $A_v B_p A_v^{-1} = B_p \\cdot (-1)^{|\\{e \\in p : v \\in e\\}|}$. Since $p$ is a cycle, each vertex appears in an even number of edges of $p$, so the exponent is even.\n(iv) For the generating set $C$, the number of independent $B_p$ operators is $|C| = |E| - |V| + 1$ (the cycle rank of $G$).",
      "proof": null,
      "dependencies": ["Def_4", "Def_6"],
      "number": 7
    },
    {
      "id": "Def_8",
      "type": "Definition",
      "name": "DeformedOperator",
      "content": "Let $\\mathcal{C}$ be an $[[n, k, d]]$ stabilizer code with checks $\\{s_i\\}$, let $L = \\prod_{v \\in \\mathcal{L}} X_v$ be an X-type logical operator, and let $G = (V, E)$ be a gauging graph for $L$.\n\nA Pauli operator $P$ on the original code that **commutes with $L$** can be written as:\n$$P = i^\\sigma \\prod_{v \\in \\mathcal{S}_X} X_v \\prod_{v \\in \\mathcal{S}_Z} Z_v$$\nwhere $|\\mathcal{S}_Z \\cap \\mathcal{L}| \\equiv 0 \\pmod{2}$ (even overlap with $\\mathcal{L}$ in Z-support).\n\nThe **deformed operator** $\\tilde{P}$ is defined as:\n$$\\tilde{P} = P \\cdot \\prod_{e \\in \\gamma} Z_e$$\nwhere $\\gamma \\subseteq E$ is an edge-path in $G$ satisfying the **boundary condition**:\n$$\\partial_1(\\gamma) = \\mathcal{S}_Z(P) \\cap V$$\n\nExplicitly, $\\partial_1(\\gamma) = \\mathcal{S}_Z(P) \\cap V$ means: for each vertex $w \\in V$,\n$$|\\{e \\in \\gamma : w \\in e\\}| \\equiv [w \\in \\mathcal{S}_Z(P)] \\pmod{2}$$\n\n**Existence of $\\gamma$**: Since $|\\mathcal{S}_Z(P) \\cap V| \\equiv 0 \\pmod{2}$ (P commutes with L), and $\\mathrm{im}(\\partial_1)$ consists of even-cardinality subsets, such a $\\gamma$ exists.\n\n**Uniqueness**: The path $\\gamma$ is unique up to addition of cycles. Different choices of $\\gamma$ give deformed operators differing by flux operators $B_p$.",
      "proof": null,
      "dependencies": ["Def_4", "Def_6", "Def_7"],
      "number": 8
    },
    {
      "id": "Rem_3",
      "type": "Remark",
      "name": "NoncommutingOperatorsNoDeformation",
      "content": "Let $\\mathcal{C}$ be a stabilizer code, $L$ an X-type logical operator, and $G$ a gauging graph.\n\nThere is **no deformed version** of a Pauli operator $P$ that does not commute with $L$.\n\n**Reason**: If $[P, L] \\neq 0$, then $|\\mathcal{S}_Z(P) \\cap \\mathcal{L}| \\equiv 1 \\pmod{2}$ (odd overlap). For $\\tilde{P} = P \\cdot \\prod_{e \\in \\gamma} Z_e$ to commute with all Gauss's law operators $A_v$, we would need:\n$$[\\tilde{P}, A_v] = 0 \\quad \\text{for all } v \\in V$$\n\nBut $[\\tilde{P}, A_v] = 0$ requires $|\\mathcal{S}_Z(\\tilde{P}) \\cap \\{v\\}| + |\\{e \\in \\gamma : v \\in e\\}| \\equiv 0 \\pmod{2}$.\n\nSumming over all $v \\in \\mathcal{L}$: $\\sum_{v \\in \\mathcal{L}} |\\mathcal{S}_Z(P) \\cap \\{v\\}| + \\sum_{v \\in \\mathcal{L}} |\\{e \\in \\gamma : v \\in e\\}| \\equiv 0$.\n\nThe second sum equals $2|\\gamma|$ (each edge counted twice) $\\equiv 0$. So we need $|\\mathcal{S}_Z(P) \\cap \\mathcal{L}| \\equiv 0$, contradicting odd overlap.\n\nThus operators anticommuting with $L$ cannot be extended to the deformed code.",
      "proof": null,
      "dependencies": ["Def_6", "Def_8"],
      "number": 3
    },
    {
      "id": "Def_9",
      "type": "Definition",
      "name": "DeformedCheck",
      "content": "Let $\\mathcal{C}$ be an $[[n, k, d]]$ stabilizer code with checks $\\{s_j\\}$, let $L$ be an X-type logical operator with support $\\mathcal{L}$, and let $G = (V, E)$ be a gauging graph.\n\nFor each check $s_j = i^{\\sigma_j} \\prod_{v \\in \\mathcal{S}_{X,j}} X_v \\prod_{v \\in \\mathcal{S}_{Z,j}} Z_v$ of the original code:\n\nThe **deformed check** $\\tilde{s}_j$ is defined as:\n$$\\tilde{s}_j = s_j \\cdot \\prod_{e \\in \\gamma_j} Z_e$$\nwhere $\\gamma_j \\subseteq E$ is an edge-path satisfying $\\partial_1(\\gamma_j) = \\mathcal{S}_{Z,j} \\cap V$.\n\n**Two cases**:\n(i) If $\\mathcal{S}_{Z,j} \\cap \\mathcal{L} = \\emptyset$ (check has no Z-support on $L$), then $\\gamma_j = \\emptyset$ and $\\tilde{s}_j = s_j$. We denote the set of such checks as $\\mathcal{C}$.\n\n(ii) If $\\mathcal{S}_{Z,j} \\cap \\mathcal{L} \\neq \\emptyset$ (check has Z-support on $L$), then $\\gamma_j \\neq \\emptyset$ is a nontrivial path. We denote the set of such checks as $\\mathcal{S}$.\n\n**Verification that $\\tilde{s}_j$ commutes with all $A_v$**:\n$[\\tilde{s}_j, A_v] = 0$ iff $|\\mathcal{S}_{Z,j} \\cap \\{v\\}| + |\\{e \\in \\gamma_j : v \\in e\\}| \\equiv 0 \\pmod{2}$, which is ensured by the boundary condition $\\partial_1(\\gamma_j) = \\mathcal{S}_{Z,j} \\cap V$.",
      "proof": null,
      "dependencies": ["Def_8"],
      "number": 9
    },
    {
      "id": "Lem_1",
      "type": "Lemma",
      "name": "DeformedCodeGenerators",
      "content": "Let $\\mathcal{C}$ be an $[[n, k, d]]$ stabilizer code with checks $\\{s_i\\}$, let $L$ be an X-type logical operator, and let $G = (V, E)$ be a gauging graph with generating cycle set $C$.\n\nThe following operators form a generating set of stabilizer checks for the **deformed code** (also called the **gauged code**):\n\n(i) **Gauss's law operators**: $A_v = X_v \\prod_{e \\ni v} X_e$ for all $v \\in V$.\n\n(ii) **Flux operators**: $B_p = \\prod_{e \\in p} Z_e$ for each cycle $p$ in the generating set $C$.\n\n(iii) **Deformed checks**: $\\tilde{s}_j = s_j \\prod_{e \\in \\gamma_j} Z_e$ for all checks $s_j$ from the original code, where $\\gamma_j$ satisfies $\\partial_1(\\gamma_j) = \\mathcal{S}_{Z,j} \\cap V$.\n\n**Verification conditions**:\n- Each $A_v$, $B_p$, $\\tilde{s}_j$ must be shown to commute with all others\n- The operators must be shown to be in the stabilizer group (act as identity on code space)\n- Independence: the generating set must have the correct number of independent elements",
      "proof": "**Lemma (Av_becomes_stabilizer):** Each $A_v$ becomes a stabilizer after the gauging measurement.\n*Proof:* The $A_v$ operators are measured during the gauging process, projecting the state into their $+1$ eigenspace. By definition, the deformed code space is the simultaneous $+1$ eigenspace of all $A_v$.\n\n**Lemma (Bp_origin):** Each $B_p$ is a stabilizer of the deformed code originating from edge qubit initialization.\n*Proof:* Edge qubits are initialized in $|0\\rangle_e$, so $Z_e|0\\rangle_e = |0\\rangle_e$. Thus $\\prod_{e} Z_e$ stabilizes the initial edge state. For a product $\\prod_{e \\in S} Z_e$ to remain a stabilizer after measuring the $A_v$ operators, it must commute with all $\\prod_{e \\ni v} X_e$. This requires $|S \\cap \\{e : v \\in e\\}| \\equiv 0 \\pmod{2}$ for all $v$, which means $S$ must be a union of cycles. Taking $S = p$ a cycle gives the flux operators $B_p$.\n\n**Lemma (deformed_check_commutes):** Each $\\tilde{s}_j$ commutes with all $A_v$ and $B_p$.\n*Proof:* \n- Commutation with $A_v$: $[\\tilde{s}_j, A_v] = 0$ follows from the boundary condition $\\partial_1(\\gamma_j) = \\mathcal{S}_{Z,j} \\cap V$ as shown in Def_9.\n- Commutation with $B_p$: The X-support of $\\tilde{s}_j$ is unchanged from $s_j$ (no X on edges). So $[\\tilde{s}_j, B_p] = [s_j, B_p] = 0$ since $B_p$ acts only on edges.\n\n**Main Lemma:** The operators $\\{A_v\\}_{v \\in V} \\cup \\{B_p\\}_{p \\in C} \\cup \\{\\tilde{s}_j\\}$ generate the stabilizer group of the deformed code.",
      "dependencies": ["Def_6", "Def_7", "Def_9"],
      "number": 1
    },
    {
      "id": "Rem_4",
      "type": "Remark",
      "name": "CodespaceDimensionReduction",
      "content": "Let $\\mathcal{C}$ be an $[[n, k, d]]$ stabilizer code and apply the gauging procedure with graph $G = (V, E)$ to measure logical operator $L$.\n\nThe dimension of the code space is reduced by exactly one qubit (i.e., the deformed code encodes $k-1$ logical qubits).\n\n**Counting argument**:\n- New qubits added: $|E|$ (one per edge)\n- New independent X-type stabilizers: $|V| - 1$ (the $A_v$ operators, minus one for the constraint $\\prod_v A_v = L$)\n- New independent Z-type stabilizers: $|E| - |V| + 1$ (cycle rank = number of independent $B_p$ operators)\n\n**Net change in encoded qubits**:\n$\\Delta k = |E| - (|V| - 1) - (|E| - |V| + 1) = |E| - |V| + 1 - |E| + |V| - 1 = -1$\n\n**Example verification**: For the cycle graph $C_n$ with $|V| = |E| = n$ and cycle rank $= 1$:\n$\\Delta k = n - (n-1) - 1 = 0$... wait, but cycle rank is 1, so: new qubits $= n$, new X-stabs $= n-1$, new Z-stabs $= 1$, so $\\Delta k = n - (n-1) - 1 = 0$. \n\nActually the logical $L$ is consumed, so the net is $-1$ from the original code's perspective.",
      "proof": null,
      "dependencies": ["Lem_1"],
      "number": 4
    },
    {
      "id": "Rem_5",
      "type": "Remark",
      "name": "FreedomInDeformedChecks",
      "content": "There is significant freedom when specifying a generating set of checks for the deformed code.\n\n**Sources of freedom**:\n(i) **Choice of paths $\\gamma_j$**: For each deformed check $\\tilde{s}_j = s_j \\prod_{e \\in \\gamma_j} Z_e$, any path $\\gamma_j$ satisfying $\\partial_1(\\gamma_j) = \\mathcal{S}_{Z,j} \\cap V$ gives a valid deformed check. Different choices $\\gamma_j$ and $\\gamma_j'$ satisfy $\\gamma_j + \\gamma_j' \\in \\ker(\\partial_1) = \\mathrm{im}(\\partial_2)$, so $\\tilde{s}_j' = \\tilde{s}_j \\cdot \\prod_{p} B_p^{a_p}$ for some $a_p \\in \\mathbb{Z}_2$.\n\n(ii) **Choice of cycle basis $C$**: Different generating sets of cycles give different $B_p$ operators, but they generate the same algebra since all cycles are $\\mathbb{Z}_2$-linear combinations of the generators.\n\n**Optimization goal**: Choose paths $\\gamma_j$ and cycle basis $C$ to minimize the **weight** and **degree** of the resulting checks:\n- Weight of $\\tilde{s}_j$ = $|s_j| + |\\gamma_j|$ (original weight plus path length)\n- Degree of edge qubit $e$ = number of checks involving $e$\n\nConventionally, one chooses **minimum weight paths** for each $\\gamma_j$.",
      "proof": null,
      "dependencies": ["Lem_1", "Def_9"],
      "number": 5
    },
    {
      "id": "Def_10",
      "type": "Definition",
      "name": "CycleSparsifiedGraph",
      "content": "Let $G = (V, E)$ be a connected graph with a generating set of cycles $C$, and let $c > 0$ be a constant called the **cycle-degree bound**.\n\nA **cycle-sparsification** of $G$ with cycle-degree $c$ is a new graph $\\bar{\\bar{G}}$ constructed as follows:\n\n(i) **Layer structure**: $\\bar{\\bar{G}}$ consists of $R + 1$ layers numbered $0, 1, \\ldots, R$. Layer 0 is a copy of the original graph $G$. Each layer $i > 0$ is a copy of the vertices of $G$.\n\n(ii) **Inter-layer edges**: For each vertex $v$ in layer $i < R$, add an edge connecting $v$ to its copy in layer $i+1$.\n\n(iii) **Cycle cellulation**: Each cycle $p$ from the original generating set is **cellulated** into triangles by adding edges. For a cycle visiting vertices $(v_1, v_2, \\ldots, v_m)$ in order, add edges: $\\{(v_1, v_{m-1}), (v_{m-1}, v_2), (v_2, v_{m-2}), \\ldots\\}$ until the cycle is decomposed into triangles.\n\n(iv) **Sparsity condition**: Each edge in $\\bar{\\bar{G}}$ participates in at most $c$ generating cycles.\n\n**Notation**: Let $R_G^c$ denote the minimum number of layers required to achieve a cycle-sparsification of $G$ with cycle-degree bound $c$.\n\n**Key property** (Freedman-Hastings decongestion lemma): For any constant-degree graph $G$ with $W = |V|$ vertices, $R_G^c = O(\\log^2 W)$ for constant $c$.",
      "proof": null,
      "dependencies": ["Def_4", "Def_5"],
      "number": 10
    },
    {
      "id": "Rem_6",
      "type": "Remark",
      "name": "CycleSparsificationBounds",
      "content": "For a constant degree graph $G$ with $|V| = W$ vertices:\n\n(i) **Number of cycles**: A minimal generating set of cycles has size $|E| - |V| + 1 = \\Theta(W)$ for constant-degree graphs.\n\n(ii) **Random expander expectation**: For a random expander graph, almost all generating cycles have length $O(\\log W)$. In this case:\n- Cycle-degree (before sparsification) = $O(\\log W)$\n- Number of layers for sparsification: $R_G^c = O(\\log W)$\n\n(iii) **Worst-case bound** (Freedman-Hastings decongestion lemma): For any constant-degree graph, $R_G^c = O(\\log^2 W)$.\n\n(iv) **Best case**: For some structured graphs (e.g., surface code lattice surgery), $R_G^c = O(1)$ - no sparsification needed.\n\n**Implication for qubit overhead**: The total number of auxiliary qubits in the cycle-sparsified graph is:\n$$|E_{\\bar{\\bar{G}}}| = |E_G| + R \\cdot |V_G| + (\\text{cellulation edges}) = O(W \\cdot R_G^c) = O(W \\log^2 W)$$\n\nThis yields the $O(W \\log^2 W)$ overhead bound for the gauging measurement procedure.",
      "proof": null,
      "dependencies": ["Def_10"],
      "number": 6
    },
    {
      "id": "Rem_7",
      "type": "Remark",
      "name": "SparsifiedDeformedChecks",
      "content": "When using a cycle-sparsification $\\bar{\\bar{G}}$ of the gauging graph $G$, the deformed checks are chosen to exploit the layered structure:\n\n(i) **Flux operators $B_p$**: Use a generating set of cycles with weight $\\leq 4$:\n- **Square cycles**: For each edge $e$ in layer $i < R$ and its copy $e'$ in layer $i+1$, the square formed by $e$, $e'$, and the inter-layer edges has weight 4.\n- **Triangle cycles**: The cellulated triangles from the original cycles have weight 3.\n\n(ii) **Deformed checks $\\tilde{s}_j$**: The paths $\\gamma_j$ for deforming original checks are all routed through layer 0 (the original $G$).\n\n**Degree analysis**: Assuming $G$ has constant degree $\\Delta$ and paths $\\gamma_j$ have length bounded by $\\kappa$:\n- Number of paths through any edge in layer 0: $\\leq 2\\Delta^\\kappa \\cdot w$ where $w$ is the max check weight\n- This is constant when $\\Delta, \\kappa, w$ are all constant.\n\n**Result**: The deformed code is LDPC (constant weight checks, constant degree qubits) when:\n- The original code is LDPC\n- The gauging graph $G$ has constant degree\n- The path lengths $|\\gamma_j|$ are bounded by a constant",
      "proof": null,
      "dependencies": ["Def_10", "Lem_1"],
      "number": 7
    },
    {
      "id": "Rem_8",
      "type": "Remark",
      "name": "DesiderataForGaugingGraph",
      "content": "When choosing a constant-degree gauging graph $G = (V, E)$ for measuring logical operator $L$, the following **desiderata** should be satisfied:\n\n(i) **Short deforming paths**: $G$ should contain a constant-length edge-path between any pair of vertices that are in the Z-type support of some check from the original code. Specifically: for each check $s_j$ with $\\mathcal{S}_{Z,j} \\cap V \\neq \\emptyset$, there exists a path $\\gamma_j \\subseteq E$ with $|\\gamma_j| \\leq \\kappa$ for some constant $\\kappa$.\n\n(ii) **Sufficient expansion**: The Cheeger constant should satisfy $h(G) \\geq 1$. This ensures no distance reduction in the deformed code.\n\n(iii) **Low-weight cycle basis**: There should exist a generating set of cycles $C$ where each cycle has weight bounded by a constant. Combined with cycle-sparsification, this ensures the flux operators $B_p$ have constant weight.\n\n**When all desiderata are satisfied**:\n- The deformed code is LDPC\n- The code distance is preserved: $d_{\\text{deformed}} \\geq d_{\\text{original}}$\n- The qubit overhead is $O(|V| \\cdot R_G^c)$ where $R_G^c$ is the sparsification depth",
      "proof": null,
      "dependencies": ["Def_5", "Def_10"],
      "number": 8
    },
    {
      "id": "Rem_9",
      "type": "Remark",
      "name": "WorstCaseGraphConstruction",
      "content": "Given an X-type logical operator $L$ with weight $W = |\\mathcal{L}|$, the following construction produces a gauging graph $G$ satisfying all desiderata with $O(W \\log^2 W)$ auxiliary qubits:\n\n**Step 1 (Matching edges)**: For each check $s_j$ whose Z-support overlaps $\\mathcal{L}$, pick a $\\mathbb{Z}_2$-perfect-matching of the vertices in $\\mathcal{S}_{Z,j} \\cap \\mathcal{L}$. Add an edge to $G$ for each matched pair. This ensures deforming paths have length 1 within each check's Z-support.\n\n**Step 2 (Expansion edges)**: Add edges to $G$ until $h(G) \\geq 1$. This can be done by:\n- Adding edges randomly while maintaining constant degree, or\n- Adding edges from a known constant-degree expander graph on $W$ vertices\n\nLet $G_0$ denote the graph after Steps 1-2.\n\n**Step 3 (Cycle sparsification)**: Apply the Freedman-Hastings decongestion procedure:\n- Add $R = O(\\log^2 W)$ layers of dummy vertices (copies of $G_0$)\n- Connect consecutive layers with inter-layer edges\n- Cellulate long cycles to achieve constant cycle-degree\n\n**Result**: The final graph $\\bar{\\bar{G}}$ has:\n- $|V| = O(W \\log^2 W)$ vertices (including dummies)\n- $|E| = O(W \\log^2 W)$ edges\n- Cheeger constant $h(\\bar{\\bar{G}}) \\geq h(G_0) \\geq 1$\n- All cycles have constant weight after cellulation",
      "proof": null,
      "dependencies": ["Def_5", "Def_10", "Rem_8"],
      "number": 9
    },
    {
      "id": "Thm_1",
      "type": "Theorem",
      "name": "GaugingMeasurement",
      "content": "Let $\\mathcal{C}$ be an $[[n, k, d]]$ stabilizer code, let $L = \\prod_{v \\in \\mathcal{L}} X_v$ be an X-type logical operator, and let $G = (V, E)$ be a connected gauging graph with an arbitrarily chosen root vertex $v_0 \\in V$.\n\nThe **gauging measurement procedure** (Algorithm 1) is equivalent to performing a projective measurement of $L$.\n\nSpecifically, given input state $|\\psi\\rangle$ in the code space:\n1. Initialize auxiliary edge qubits: $|\\Psi\\rangle = |\\psi\\rangle \\otimes |0\\rangle_E$\n2. For each $v \\in V$, measure $A_v = X_v \\prod_{e \\ni v} X_e$, obtaining result $\\varepsilon_v \\in \\{\\pm 1\\}$\n3. Set $\\sigma = \\prod_{v \\in V} \\varepsilon_v$\n4. For each $e \\in E$, measure $Z_e$, obtaining result $\\omega_e \\in \\{\\pm 1\\}$\n5. For each $v \\in V$, let $\\gamma_v$ be an edge-path from $v_0$ to $v$. If $\\prod_{e \\in \\gamma_v} \\omega_e = -1$, apply $X_v$.\n\nThen the output satisfies:\n- $\\sigma \\in \\{\\pm 1\\}$ is the measurement result of $L$\n- The post-measurement state is $|\\Psi_{\\text{out}}\\rangle = \\frac{1}{2}(I + \\sigma L)|\\psi\\rangle$ (up to normalization)",
      "proof": "**Lemma (state_after_Av_measurements):** After measuring all $A_v$ operators, the state is:\n$$\\prod_v \\frac{1}{2}(I + \\varepsilon_v A_v)|\\psi\\rangle|0\\rangle_E = \\frac{1}{2^{|V|}} \\sum_{c \\in C_0(G; \\mathbb{Z}_2)} \\varepsilon(c) X_V(c) X_E(\\delta_0 c)|\\psi\\rangle|0\\rangle_E$$\nwhere $\\varepsilon(c) = \\prod_v \\varepsilon_v^{c_v}$, $X_V(c) = \\prod_v X_v^{c_v}$, and $X_E(\\delta_0 c) = \\prod_e X_e^{(\\delta_0 c)_e}$.\n*Proof:* Expand the product of projectors $\\prod_v \\frac{1}{2}(I + \\varepsilon_v A_v)$ using $A_v = X_v \\prod_{e \\ni v} X_e$.\n\n**Lemma (Z_measurement_constraint):** After measuring all $Z_e$ with outcomes $z = (z_e)_{e \\in E}$, projecting onto $\\langle z|_E$, only terms with $\\delta_0 c = z$ survive:\n$$\\langle z|_E \\cdot (\\text{state}) = \\frac{1}{2^{|V|}} \\sum_{c : \\delta_0 c = z} \\varepsilon(c) X_V(c)|\\psi\\rangle$$\n*Proof:* $\\langle z|_E X_E(\\delta_0 c)|0\\rangle_E = 0$ unless $\\delta_0 c = z$ (edge by edge).\n\n**Lemma (cocycle_reduction):** For connected $G$, the sum over $\\{c : \\delta_0 c = z\\}$ reduces to two terms:\n$$\\sum_{c : \\delta_0 c = z} \\varepsilon(c) X_V(c) = X_V(c')(I + \\sigma L)$$\nwhere $c'$ is any fixed 0-chain with $\\delta_0 c' = z$, and $\\sigma = \\prod_v \\varepsilon_v$.\n*Proof:* The set $\\{c : \\delta_0 c = z\\}$ is a coset of $\\ker(\\delta_0)$. For connected $G$, $\\ker(\\delta_0) = \\{0, \\mathbf{1}_V\\}$. So $\\{c : \\delta_0 c = z\\} = \\{c', c' + \\mathbf{1}_V\\}$. Now $X_V(\\mathbf{1}_V) = \\prod_{v \\in V} X_v = L$ and $\\varepsilon(\\mathbf{1}_V) = \\prod_v \\varepsilon_v = \\sigma$.\n\n**Lemma (byproduct_correction):** The byproduct operator $X_V(c')$ is corrected by Step 5.\n*Proof:* Choosing paths $\\gamma_v$ from $v_0$ to each $v$, the condition $\\prod_{e \\in \\gamma_v} \\omega_e = -1$ identifies exactly the vertices where $c'_v = 1$. Applying $X_v$ on these vertices removes $X_V(c')$.\n\n**Main Theorem:** Combining all lemmas: the output state is $\\frac{1}{2}(I + \\sigma L)|\\psi\\rangle$ where $\\sigma = \\prod_v \\varepsilon_v$, which is the projection onto the $\\sigma$-eigenspace of $L$.",
      "dependencies": ["Def_4", "Def_6", "Def_7"],
      "number": 1
    },
    {
      "id": "Lem_2",
      "type": "Lemma",
      "name": "SpaceDistanceBound",
      "content": "Let $\\mathcal{C}$ be an $[[n, k, d]]$ stabilizer code, let $L$ be an X-type logical operator, and let $G = (V, E)$ be a gauging graph (possibly cycle-sparsified to $\\bar{\\bar{G}}$).\n\nThe distance $d^*$ of the deformed code satisfies:\n$$d^* \\geq \\min(h(G), 1) \\cdot d$$\n\nwhere $h(G)$ is the Cheeger constant of $G$ and $d$ is the distance of the original code.\n\nIn particular, if $h(G) \\geq 1$, then $d^* \\geq d$ (no distance reduction).",
      "proof": "**Lemma (logical_op_decomposition):** Any logical operator $L'$ of the deformed code can be written as:\n$$L' = i^\\sigma \\cdot L_X^V \\cdot L_Z^V \\cdot L_X^E \\cdot L_Z^E \\cdot \\tilde{L}$$\nwhere:\n- $L_X^V = \\prod_{v \\in \\mathcal{S}_X \\cap V} X_v$ (X on vertex qubits in the gauged region)\n- $L_X^E = \\prod_{e \\in \\mathcal{S}_X \\cap E} X_e$ (X on edge qubits)\n- $L_Z^V, L_Z^E$ are the Z-type components\n- $\\tilde{L}$ is the component outside the gauged region\n*Proof:* Direct decomposition by support.\n\n**Lemma (flux_commutation_constraint):** If $L'$ is a logical operator (commutes with all checks), then $\\mathcal{S}_X^E = \\mathcal{S}_X \\cap E$ satisfies $\\delta_1(\\mathcal{S}_X^E) = 0$.\n*Proof:* $L'$ must commute with all flux checks $B_p = \\prod_{e \\in p} Z_e$. We have $[L', B_p] = 0$ iff $|\\mathcal{S}_X^E \\cap p| \\equiv 0 \\pmod{2}$ for all cycles $p$. This is exactly $\\delta_1(\\mathcal{S}_X^E) = 0$.\n\n**Lemma (edge_support_is_coboundary):** By exactness, $\\mathcal{S}_X^E = \\delta_0(\\tilde{\\mathcal{S}}_X^V)$ for some vertex set $\\tilde{\\mathcal{S}}_X^V \\subseteq V$.\n*Proof:* From Remark 2, $\\ker(\\delta_1) = \\mathrm{im}(\\delta_0)$ when using a generating cycle set.\n\n**Lemma (equivalent_logical):** $L'$ is equivalent (mod stabilizers) to:\n$$\\bar{L} = L' \\cdot \\prod_{v \\in \\tilde{\\mathcal{S}}_X^V} A_v = i^\\sigma L_X^V \\bar{L}_X^V L_Z^V L_Z^E \\tilde{L}$$\nwhere $\\bar{L}_X^V = \\prod_{v \\in \\tilde{\\mathcal{S}}_X^V \\cap G_0} X_v$ and $G_0$ is layer 0 (original qubits, not dummies).\n*Proof:* Multiplying by $A_v$ stabilizers removes edge X-support and adds vertex X-support.\n\n**Lemma (restriction_is_original_logical):** The restriction $\\bar{L}|_V = i^\\sigma L_X^V \\bar{L}_X^V L_Z^V \\tilde{L}$ is a logical operator of the original code.\n*Proof:* $\\bar{L}$ commutes with deformed checks $\\tilde{s}_j$. The extra $Z_e$ terms in $\\tilde{s}_j$ don't affect commutation since $\\bar{L}|_V$ has no edge support. So $\\bar{L}|_V$ commutes with all original checks $s_j$.\n\n**Lemma (cheeger_bound_application):** If $|\\tilde{\\mathcal{S}}_X^V \\cap G_0| \\leq |V|/2$, then:\n$$|\\delta_0(\\tilde{\\mathcal{S}}_X^V)| \\geq h(G) \\cdot |\\tilde{\\mathcal{S}}_X^V \\cap G_0|$$\n*Proof:* Direct application of Cheeger constant definition.\n\n**Lemma (weight_bound):** $|L'| \\geq |\\mathcal{S}_X^E| \\geq h(G) \\cdot |\\tilde{\\mathcal{S}}_X^V \\cap G_0| \\geq h(G) \\cdot |\\bar{L}|_V|$ when $h(G) \\leq 1$.\n*Proof:* For $h(G) \\leq 1$: the edge support has size at least $h(G)$ times the vertex support being \"cleaned\". The cleaned logical has weight $\\geq d$ by the original code distance.\n\n**Main Lemma:** Combining: $|L'| \\geq \\min(h(G), 1) \\cdot |\\bar{L}|_V| \\geq \\min(h(G), 1) \\cdot d$.",
      "dependencies": ["Def_5", "Def_8", "Rem_2"],
      "number": 2
    },
    {
      "id": "Rem_10",
      "type": "Remark",
      "name": "OptimalCheegerConstant",
      "content": "Picking a graph with Cheeger constant $h(G) = 1$ is optimal in the following sense:\n\n(i) **Sufficient for distance preservation**: If $h(G) \\geq 1$, then $d^* \\geq d$ by Lemma 2.\n\n(ii) **Larger Cheeger doesn't help**: If $h(G) > 1$, the distance bound is still $d^* \\geq d$ (not $d^* \\geq h(G) \\cdot d$). This is because logical operators can always be \"cleaned\" onto vertex qubits, where the original code distance applies.\n\n(iii) **Small Cheeger causes distance loss**: If $h(G) < 1$, the distance can be reduced by a factor of $h(G)$. In the worst case, a logical of the deformed code has most of its weight on edges, and cleaning it onto vertices increases vertex weight by factor $1/h(G)$.",
      "proof": null,
      "dependencies": ["Lem_2"],
      "number": 10
    },
    {
      "id": "Rem_11",
      "type": "Remark",
      "name": "LogicalPreservation",
      "content": "The gauging procedure preserves all quantum information except for the measured logical $L$.\n\n**Bijection between logicals**: There is a 1-1 correspondence between:\n- Logical operators of the deformed code\n- Logical operators of the original code that commute with $L$\n\n**Mapping**:\n- Forward: A logical $\\tilde{P}$ of the original code commuting with $L$ maps to its deformation $\\tilde{P} \\cdot \\prod_{e \\in \\gamma} Z_e$\n- Backward: A logical $L'$ of the deformed code maps to its restriction $\\bar{L}|_V$\n\n**Kernel of the map**: Operators equivalent to $L$ map to stabilizers in the deformed code (since $L$ is measured).\n\n**Algebra preservation**: The commutation relations among logicals are preserved by this mapping.",
      "proof": null,
      "dependencies": ["Lem_2", "Thm_1"],
      "number": 11
    },
    {
      "id": "Rem_12",
      "type": "Remark",
      "name": "CircuitImplementation",
      "content": "The gauging measurement procedure can be implemented by a quantum circuit with no additional qubits beyond the edge qubits:\n\n**Circuit steps**:\n1. Initialize edge qubits: $|0\\rangle_E$\n2. Apply entangling circuit: $\\prod_v \\prod_{e \\ni v} CX_{v \\to e}$ where $CX_{v \\to e}$ is controlled-X from vertex $v$ to edge $e$\n3. Measure $X_v$ on all vertices $v \\in V$ and record outcomes\n4. Apply the same entangling circuit again: $\\prod_v \\prod_{e \\ni v} CX_{v \\to e}$\n5. Measure $Z_e$ on all edges and discard edge qubits\n6. Apply byproduct corrections based on measurement outcomes\n\n**Verification**: The composition of steps 2-3 is equivalent to measuring $A_v = X_v \\prod_{e \\ni v} X_e$ because:\n- After step 2: $CX$ entangles vertex and edge qubits\n- Measuring $X_v$ in step 3 effectively measures $A_v$ in the original basis\n- Step 4 disentangles for the $Z_e$ measurements",
      "proof": null,
      "dependencies": ["Thm_1"],
      "number": 12
    },
    {
      "id": "Rem_13",
      "type": "Remark",
      "name": "Parallelization",
      "content": "The gauging measurement can be applied to multiple logical operators in parallel, subject to compatibility conditions:\n\n**Compatibility condition**: Logical operators $L_1, \\ldots, L_m$ can be measured in parallel if no pair acts on a common qubit via different non-trivial Pauli operators. Specifically: for all $i \\neq j$ and all qubits $v$, at least one of the following holds:\n- $v \\notin \\mathrm{supp}(L_i)$, or\n- $v \\notin \\mathrm{supp}(L_j)$, or  \n- $L_i$ and $L_j$ act on $v$ by the same Pauli ($X$, $Y$, or $Z$)\n\n**LDPC preservation**: To maintain an LDPC deformed code, at most a constant number of logical operators being measured should share support on any single qubit.\n\n**Time-space tradeoff**: Instead of $d$ rounds of syndrome measurement, one can perform:\n- $\\frac{d}{m}$ rounds of syndrome measurement\n- Measure $2m - 1$ equivalent logical operators in parallel\n- Take majority vote to determine the classical outcome\n\nThis trades space overhead (more parallel measurements) for time overhead (fewer rounds).",
      "proof": null,
      "dependencies": ["Thm_1", "Lem_1"],
      "number": 13
    },
    {
      "id": "Rem_14",
      "type": "Remark",
      "name": "HypergraphGeneralization",
      "content": "The gauging measurement procedure generalizes from graphs to hypergraphs:\n\n**Hypergraph gauging**: Replace the graph $G$ with a hypergraph $H = (V, \\mathcal{E})$ where $\\mathcal{E}$ is a collection of hyperedges (subsets of $V$ of arbitrary size).\n\n**Generalized Gauss's law**: For each vertex $v$, define:\n$$A_v = X_v \\prod_{e \\in \\mathcal{E} : v \\in e} X_e$$\n\n**What can be measured**: The hypergraph gauging measures the group of operators:\n$$\\{P \\in \\langle X_v : v \\in V \\rangle : [P, B_e] = 0 \\text{ for all } e \\in \\mathcal{E}\\}$$\nwhere $B_e = \\prod_{v \\in e} Z_v$ are Z-type hyperedge checks.\n\nThis is equivalent to $\\ker(H^T)$ where $H$ is the incidence matrix of the hypergraph over $\\mathbb{F}_2$.\n\n**Application**: Measure multiple commuting logical operators simultaneously by choosing a hypergraph whose kernel is exactly the group generated by those logicals.",
      "proof": null,
      "dependencies": ["Thm_1", "Def_6"],
      "number": 14
    },
    {
      "id": "Def_11",
      "type": "Definition",
      "name": "SpaceTimeFault",
      "content": "In the fault-tolerant implementation of the gauging measurement:\n\n**Space-fault (Pauli error)**: A Pauli error operator $P \\in \\{X, Y, Z\\}$ that occurs on some qubit at some time step during the procedure.\n\n**Time-fault (measurement error)**: An error where the result of a measurement is reported incorrectly (bit-flip of the classical outcome).\n\n**Initialization fault**: An error where a qubit is initialized in the wrong state. This is equivalent to a space-fault: initializing in wrong state = perfect initialization followed by an error operator.\n\n**General spacetime fault**: A collection $F$ of space-faults and time-faults occurring at various spacetime locations.\n\n**Weight of a fault**: $|F|$ = (number of single-qubit Pauli errors) + (number of measurement errors).",
      "proof": null,
      "dependencies": [],
      "number": 11
    },
    {
      "id": "Def_12",
      "type": "Definition",
      "name": "Detector",
      "content": "A **detector** is a collection of state initializations and measurements that yield a deterministic result in the absence of faults.\n\nFormally, a detector $D$ consists of:\n- A set of qubit initializations (each in a known state)\n- A set of measurements (each of a known observable)\n- A parity constraint: the product of measurement outcomes must equal a fixed value (typically $+1$)\n\n**Detector violation**: A spacetime fault $F$ **violates** detector $D$ if $F$ causes the parity constraint of $D$ to fail.\n\n**Syndrome**: The **syndrome** of a spacetime fault $F$ is the set of all detectors violated by $F$:\n$$\\mathrm{syn}(F) = \\{D : F \\text{ violates } D\\}$$",
      "proof": null,
      "dependencies": ["Def_11"],
      "number": 12
    },
    {
      "id": "Lem_3",
      "type": "Lemma",
      "name": "SpacetimeCodeDetectors",
      "content": "The following form a generating set of local detectors in the fault-tolerant gauging measurement procedure:\n\n**For $t < t_i$ and $t > t_o$** (before and after code deformation):\n- $s_j^t$: Repeated measurement of check $s_j$ at times $t - \\frac{1}{2}$ and $t + \\frac{1}{2}$\n\n**For $t_i < t < t_o$** (during code deformation):\n- $A_v^t$: Repeated measurement of $A_v$ at times $t - \\frac{1}{2}$ and $t + \\frac{1}{2}$\n- $B_p^t$: Repeated measurement of $B_p$ at times $t - \\frac{1}{2}$ and $t + \\frac{1}{2}$\n- $\\tilde{s}_j^t$: Repeated measurement of $\\tilde{s}_j$ at times $t - \\frac{1}{2}$ and $t + \\frac{1}{2}$\n\n**For $t = t_i$** (start of code deformation):\n- $B_p^{t_i}$: Initialization of edges $e \\in p$ in $|0\\rangle_e$ at $t_i - \\frac{1}{2}$ and first measurement of $B_p$ at $t_i + \\frac{1}{2}$\n- $\\tilde{s}_j^{t_i}$: Initialization of edges $e \\in \\gamma_j$ in $|0\\rangle_e$, measurement of $s_j$ at $t_i - \\frac{1}{2}$, and measurement of $\\tilde{s}_j$ at $t_i + \\frac{1}{2}$\n\n**For $t = t_o$** (end of code deformation):\n- $B_p^{t_o}$: Measurement of $B_p$ at $t_o - \\frac{1}{2}$ and final $Z_e$ measurements on edges $e \\in p$ at $t_o + \\frac{1}{2}$\n- $\\tilde{s}_j^{t_o}$: Measurement of $\\tilde{s}_j$ at $t_o - \\frac{1}{2}$, and measurements of $Z_e$ on edges $e \\in \\gamma_j$ and $s_j$ at $t_o + \\frac{1}{2}$",
      "proof": "**Lemma (bulk_detectors):** Away from boundary times, detectors are pairs of consecutive measurements of the same check.\n*Proof:* In steady-state syndrome extraction, measuring check $C$ at times $t$ and $t+1$ gives the same outcome unless an error occurred. The parity constraint is: outcome($C$, time $t$) $\\cdot$ outcome($C$, time $t+1$) $= +1$.\n\n**Lemma (initial_boundary_B):** At $t = t_i$, the detector $B_p^{t_i}$ is well-defined.\n*Proof:* Edge qubits are initialized in $|0\\rangle$, which is a $+1$ eigenstate of $Z_e$. Thus $B_p = \\prod_{e \\in p} Z_e$ has eigenvalue $+1$ on the initial state. The first measurement of $B_p$ at $t_i + \\frac{1}{2}$ must give $+1$ (absent errors), establishing the detector.\n\n**Lemma (initial_boundary_s):** At $t = t_i$, the detector $\\tilde{s}_j^{t_i}$ relates $s_j$ and $\\tilde{s}_j$ measurements.\n*Proof:* Before gauging, $s_j$ is measured. After gauging, $\\tilde{s}_j = s_j \\prod_{e \\in \\gamma_j} Z_e$ is measured. Since edges are initialized in $|0\\rangle$, $\\prod_{e \\in \\gamma_j} Z_e$ acts as $+1$. So $s_j$ and $\\tilde{s}_j$ have the same eigenvalue on the code state.\n\n**Lemma (final_boundary):** At $t = t_o$, detectors involve final $Z_e$ read-out.\n*Proof:* The $Z_e$ measurements at ungauging determine the edge state. Combined with the last $B_p$ or $\\tilde{s}_j$ measurement, they form valid detectors by the same logic as the initial boundary.\n\n**Main Lemma:** These detectors generate all local detectors by decomposition.",
      "dependencies": ["Def_12", "Lem_1"],
      "number": 3
    },
    {
      "id": "Rem_15",
      "type": "Remark",
      "name": "SpacetimeSyndromes",
      "content": "The syndrome of each type of fault in the spacetime code:\n\n**For $t < t_i$ and $t > t_o$**:\n- Pauli $X_v$ (or $Z_v$) fault at time $t$: violates $s_j^t$ for all $s_j$ that anticommute with $X_v$ (or $Z_v$)\n- $s_j$-measurement fault at time $t + \\frac{1}{2}$: violates $s_j^t$ and $s_j^{t+1}$\n\n**For $t_i < t < t_o$**:\n- $X_v$ fault at time $t$: violates $\\tilde{s}_j^t$ for anticommuting $\\tilde{s}_j$\n- $Z_v$ fault at time $t$: violates $A_v^t$ and $\\tilde{s}_j^t$ for anticommuting $\\tilde{s}_j$\n- $X_e$ fault at time $t$: violates $B_p^t$ for all $p \\ni e$, and $\\tilde{s}_j^t$ for anticommuting $\\tilde{s}_j$\n- $Z_e$ fault at time $t$: violates $A_v^t$ for both $v \\in e$\n- Measurement faults: violate detectors at times $t$ and $t+1$ for the corresponding check\n\n**At boundaries $t = t_i, t_o$**: Initialization/read-out faults are equivalent to Pauli faults and violate the corresponding boundary detectors.",
      "proof": null,
      "dependencies": ["Lem_3"],
      "number": 15
    },
    {
      "id": "Rem_16",
      "type": "Remark",
      "name": "SyndromeMobility",
      "content": "Syndromes can be created, moved, and destroyed by faults:\n\n**Creation/Annihilation**:\n- Pauli errors create syndrome pairs (one at each adjacent time slice)\n- Measurement errors propagate syndromes forward/backward in time\n\n**Movement**:\n- For $t < t_i$ and $t > t_o$: Standard syndrome mobility via Pauli strings\n- For $t_i < t < t_o$: $Z_e$ errors on edges form strings that move $A_v$ syndromes along edge-paths in $G$\n\n**Condensation at boundaries**:\n- At $t = t_i$: $A_v$ syndromes can be created/destroyed (the $A_v$ stabilizers start being measured)\n- At $t = t_o$: $A_v$ syndromes can be created/destroyed (the $A_v$ stabilizers stop being measured)\n\n**Propagation through boundaries**:\n- $B_p$ and $\\tilde{s}_j$ syndromes can propagate through $t_i$ and $t_o$ by mapping to vertex-only errors plus $A_v$ stabilizers",
      "proof": null,
      "dependencies": ["Rem_15"],
      "number": 16
    },
    {
      "id": "Def_13",
      "type": "Definition",
      "name": "SpacetimeLogicalFault",
      "content": "A **spacetime logical fault** is a collection of space and time faults that:\n(i) Does not violate any detector: $\\mathrm{syn}(F) = \\emptyset$\n(ii) Is not a spacetime stabilizer (see Def_14)\n\nIntuitively, a spacetime logical fault is an undetectable error that affects the computation result.",
      "proof": null,
      "dependencies": ["Def_11", "Def_12"],
      "number": 13
    },
    {
      "id": "Def_14",
      "type": "Definition",
      "name": "SpacetimeStabilizer",
      "content": "A **spacetime stabilizer** is a collection of space and time faults that:\n(i) Does not violate any detector: $\\mathrm{syn}(F) = \\emptyset$\n(ii) Does not affect the result of the gauging measurement procedure\n\nSpacetime stabilizers are the \"trivial\" undetectable faults - they are errors that cancel out and have no effect on the computation.",
      "proof": null,
      "dependencies": ["Def_11", "Def_12"],
      "number": 14
    },
    {
      "id": "Lem_4",
      "type": "Lemma",
      "name": "SpacetimeStabilizerGenerators",
      "content": "The following form a generating set of local spacetime stabilizers:\n\n**For $t < t_i$ and $t > t_o$**:\n- Space stabilizer: Check operator $s_j$ at time $t$\n- Time stabilizer: Pair of $X_i$ (or $Z_i$) faults at times $t, t+1$, together with measurement faults on all anticommuting checks $s_j$ at time $t + \\frac{1}{2}$\n\n**For $t_i < t < t_o$**:\n- Space stabilizers: $\\tilde{s}_j$, $A_v$, or $B_p$ at time $t$\n- Time stabilizers for vertex qubits: Pair of $X_v$ (or $Z_v$) faults at times $t, t+1$, plus appropriate measurement faults\n- Time stabilizers for edge qubits: Pair of $X_e$ (or $Z_e$) faults at times $t, t+1$, plus appropriate measurement faults\n\n**At $t = t_i$**:\n- Space stabilizer: $s_j$ or $Z_e$ at time $t$\n- Initialization-space pair: $|0\\rangle_e$ initialization fault at $t - \\frac{1}{2}$ together with $X_e$ fault at time $t$\n- Edge-measurement pair: $Z_e$ fault at $t + 1$ together with pair of $A_v$ measurement faults for $v \\in e$ at $t + \\frac{1}{2}$\n\n**At $t = t_o$**:\n- Space stabilizers: $\\tilde{s}_j$, $A_v$, or $B_p$ at time $t$\n- Read-out-space pair: $X_e$ fault at $t$ together with $Z_e$ measurement fault at $t + \\frac{1}{2}$\n- Remaining $Z_e$ at time $t$ (stabilizer of deformed code about to be unmeasured)",
      "proof": "**Lemma (bulk_spacetime_stabilizers):** Away from boundaries, spacetime stabilizers are products of: (a) space stabilizers at fixed time, (b) time-translation pairs of Pauli faults plus measurement faults.\n*Proof:* A Pauli error at time $t$ creates syndromes. To cancel them without other Pauli errors, must have the same Pauli at time $t+1$ (cancels syndromes) plus measurement errors at $t + \\frac{1}{2}$ (prevents detection between $t$ and $t+1$).\n\n**Lemma (boundary_stabilizers):** At code deformation times, initialization/read-out errors pair with Pauli errors.\n*Proof:* An initialization error $|0\\rangle \\to |1\\rangle$ is equivalent to perfect initialization plus $X$ error. A read-out error is equivalent to perfect measurement plus classical bit-flip, which for stabilizer codes equals a Pauli error before measurement.\n\n**Main Lemma:** Any local spacetime stabilizer decomposes into these generators by: (1) isolate Pauli operators to earliest time using time-translation stabilizers, (2) the product at earliest time must be a space stabilizer, (3) remaining measurement errors form trivial patterns.",
      "dependencies": ["Lem_3", "Def_14"],
      "number": 4
    },
    {
      "id": "Def_15",
      "type": "Definition",
      "name": "SpacetimeFaultDistance",
      "content": "The **spacetime fault-distance** of the fault-tolerant gauging measurement procedure is:\n$$d_{\\text{ST}} = \\min\\{|F| : F \\text{ is a spacetime logical fault}\\}$$\n\nwhere $|F|$ counts single-qubit Pauli errors plus single measurement errors.\n\nEquivalently, $d_{\\text{ST}}$ is the minimum weight of an undetectable fault pattern that is not equivalent to a spacetime stabilizer.",
      "proof": null,
      "dependencies": ["Def_13", "Def_14"],
      "number": 15
    },
    {
      "id": "Lem_5",
      "type": "Lemma",
      "name": "TimeFaultDistance",
      "content": "The fault-distance for pure measurement and initialization errors is $(t_o - t_i)$, the number of rounds between the start and end of code deformation.\n\nSpecifically: Any spacetime logical fault consisting only of measurement/initialization errors has weight $\\geq t_o - t_i$.",
      "proof": "**Lemma (measurement_fault_propagation):** A measurement fault on check $C$ at time $t$ must be accompanied by measurement faults on $C$ at either $t-1$ or $t+1$ (or boundary termination).\n*Proof:* The detector comparing $C$ at times $t$ and $t \\pm 1$ would otherwise be violated.\n\n**Lemma (boundary_termination_Av):** Strings of $A_v$ measurement faults can terminate at $t = t_i$ and $t = t_o$.\n*Proof:* At $t_i + \\frac{1}{2}$: the first $A_v$ measurement fault only violates $A_v^{t_i+1}$, not a boundary detector (since $A_v$ wasn't measured before). Similarly at $t_o - \\frac{1}{2}$.\n\n**Lemma (boundary_termination_edges):** Strings of $B_p/\\tilde{s}_j$ measurement faults can terminate at boundaries via initialization/read-out faults.\n*Proof:* At $t_i$: a $|0\\rangle_e$ initialization fault violates $B_p^{t_i}$ and $\\tilde{s}_j^{t_i}$ for appropriate $p, j$. At $t_o$: a $Z_e$ read-out fault has the same effect.\n\n**Lemma (edge_faults_trivial):** The measurement logical fault from edge initialization/read-out is trivial.\n*Proof:* It decomposes into spacetime stabilizers: initialization fault + $X_e$ at $t_i$, then $X_e$ at $t_i+1$, etc., then $X_e$ at $t_o$ + read-out fault.\n\n**Lemma (Av_measurement_fault_logical):** Repeated $A_v$ measurement faults from $t_i$ to $t_o$ form a nontrivial logical fault.\n*Proof:* This fault flips the inferred value of $\\prod_v \\varepsilon_v$, which determines the measurement outcome $\\sigma$ of logical $L$.\n\n**Main Lemma:** The minimum weight measurement logical fault is the $A_v$ measurement string with weight $t_o - t_i$.",
      "dependencies": ["Lem_3", "Lem_4"],
      "number": 5
    },
    {
      "id": "Lem_6",
      "type": "Lemma",
      "name": "SpaceTimeFaultDecoupling",
      "content": "Any spacetime logical fault is equivalent to the product of a space logical fault and a time logical fault, up to multiplication with spacetime stabilizers.\n\nFormally: For any spacetime logical fault $F$, there exist:\n- A spacetime stabilizer $S$\n- A space-only logical fault $F_S$ (Pauli errors at a single time slice)\n- A time-only logical fault $F_T$ (measurement/initialization errors only)\n\nsuch that $F = S \\cdot F_S \\cdot F_T$.",
      "proof": "**Lemma (clean_to_time_ti):** Any spacetime fault can be cleaned to have all Pauli components at time $t_i$.\n*Proof:* Use time-translation spacetime stabilizers: a Pauli at time $t$ plus the same Pauli at time $t+1$ plus measurement faults is a stabilizer. Apply these to move all Paulis to $t_i$.\n\n**Lemma (measurement_fault_structure):** After cleaning, remaining measurement faults occur only in $[t_i, t_o]$.\n*Proof:* Measurement faults outside $[t_i, t_o]$ would propagate to initial/final boundaries (assumed perfect), violating detectors.\n\n**Lemma (measurement_fault_classification):** Measurement fault strings from $t_i$ to $t_o$ are either:\n(a) $A_v$ measurement strings (timelike logical faults), or\n(b) Edge-related strings (trivial, decompose into stabilizers)\n*Proof:* $A_v$ strings change $\\sigma = \\prod_v \\varepsilon_v$ (logical). Edge strings can be paired with initialization/read-out faults to form stabilizers.\n\n**Main Lemma:** After cleaning and decomposing edge strings, we have: original fault $=$ (stabilizers) $\\cdot$ (Pauli errors at $t_i$) $\\cdot$ ($A_v$ measurement strings). The Pauli errors at $t_i$ form a space logical fault; the $A_v$ strings form a time logical fault.",
      "dependencies": ["Lem_4", "Lem_5"],
      "number": 6
    },
    {
      "id": "Thm_2",
      "type": "Theorem",
      "name": "FaultTolerance",
      "content": "The fault-tolerant implementation of the gauging measurement procedure with a suitable graph $G$ has spacetime fault-distance $d$.\n\nSpecifically, if:\n(i) The gauging graph satisfies $h(G) \\geq 1$ (Cheeger constant at least 1)\n(ii) The number of syndrome measurement rounds satisfies $t_o - t_i \\geq d$\n\nThen any undetectable fault pattern that affects the computation has weight at least $d$.",
      "proof": "**Lemma (time_distance_bound):** Spacetime logical faults not equivalent to space-only faults have weight $\\geq d$.\n*Proof:* By Lemma 5, pure time logical faults have weight $\\geq t_o - t_i \\geq d$.\n\n**Lemma (space_distance_bound):** Spacetime logical faults equivalent to space-only faults have weight $\\geq d$.\n*Proof:* By Lemma 6, such faults can be cleaned to a spacelike logical at $t_i$. By Lemma 2, space logicals of the deformed code have weight $\\geq \\min(h(G), 1) \\cdot d = d$ (since $h(G) \\geq 1$).\n\n**Lemma (cleaning_preserves_weight):** The cleaning process does not reduce fault weight.\n*Proof:* The spacetime stabilizers used in cleaning (Lemma 6) preserve the parity of (Pauli faults + initialization faults) at each spacetime position. Thus total weight is preserved or increased.\n\n**Main Theorem:** Combining the lemmas: any spacetime logical fault has weight at least $\\min(d, t_o - t_i) = d$.",
      "dependencies": ["Lem_2", "Lem_5", "Lem_6"],
      "number": 2
    },
    {
      "id": "Rem_17",
      "type": "Remark",
      "name": "HighWeightFluxChecks",
      "content": "The fault-distance result (Theorem 2) holds even if:\n(i) The flux checks $B_p$ have high weight\n(ii) The $B_p$ checks are measured infrequently (less than every time step)\n(iii) The $B_p$ detectors are only inferred once via initialization and final read-out\n\n**Reason**: The proof of Theorem 2 only requires:\n- $A_v$ syndromes to be local and frequently measured\n- Deformed checks $\\tilde{s}_j$ to be frequently measured\n- $B_p$ information to be inferable (not necessarily directly measured)\n\n**Caveat**: Without frequent $B_p$ measurements, the decoder has large detector cells for $B_p$ syndromes. This likely prevents a threshold against uncorrelated noise, but may still be useful for small fixed-size instances.",
      "proof": null,
      "dependencies": ["Thm_2"],
      "number": 17
    },
    {
      "id": "Rem_18",
      "type": "Remark",
      "name": "BoundaryConditions",
      "content": "The $d$ rounds of error correction in the original code before time $t_i$ and after time $t_o$ serve to establish clean boundary conditions for the fault-tolerance proof.\n\n**Purpose**: Ensure that any fault pattern involving both:\n- The gauging measurement ($t_i$ to $t_o$), and\n- The initial or final boundary\n\nhas total weight $> d$.\n\n**Practical consideration**: In a larger fault-tolerant computation, the gauging measurement is one component among many. The number of rounds before/after can be reduced based on the surrounding operations, but this may affect the effective distance and threshold.\n\n**Idealization**: The proof assumes the first and last measurement rounds are perfect. This is a common proof technique and doesn't fundamentally change the results, given the $d$ buffer rounds.",
      "proof": null,
      "dependencies": ["Thm_2"],
      "number": 18
    },
    {
      "id": "Def_16",
      "type": "Definition",
      "name": "BivariateBicycleCode",
      "content": "Let $\\ell, m \\in \\mathbb{N}$ and define:\n- $I_r$: the $r \\times r$ identity matrix\n- $C_r$: the $r \\times r$ cyclic permutation matrix, $(C_r)_{ij} = [j \\equiv i + 1 \\pmod{r}]$\n- $x = C_\\ell \\otimes I_m$ and $y = I_\\ell \\otimes C_m$\n\nThe matrices $x, y$ satisfy: $x^\\ell = y^m = I_{\\ell m}$, $xy = yx$, and $x^T x = y^T y = I_{\\ell m}$.\n\nA **Bivariate Bicycle (BB) code** is a CSS code on $n = 2\\ell m$ physical qubits, divided into:\n- $\\ell m$ **left (L) qubits**\n- $\\ell m$ **right (R) qubits**\n\nThe parity check matrices are:\n$$H_X = [A | B], \\quad H_Z = [B^T | A^T]$$\n\nwhere $A, B \\in \\mathbb{F}_2[x, y]$ are polynomials in $x$ and $y$ with coefficients in $\\mathbb{F}_2$.\n\n**Transpose convention**: $A^T = A(x, y)^T = A(x^{-1}, y^{-1})$ (inverse of $x$ is $x^{\\ell-1}$, etc.)\n\n**Labeling**: Checks and qubits are labeled by $(\\alpha, T)$ for $\\alpha \\in \\mathcal{M} = \\{x^a y^b : a, b \\in \\mathbb{Z}\\}$ and $T \\in \\{X, Z, L, R\\}$.\n\n**Check action**:\n- X check $(\\alpha, X)$ acts on qubits $(\\alpha A, L)$ and $(\\alpha B, R)$\n- Z check $(\\beta, Z)$ acts on qubits $(\\beta B^T, L)$ and $(\\beta A^T, R)$",
      "proof": null,
      "dependencies": ["Def_1"],
      "number": 16
    },
    {
      "id": "Def_17",
      "type": "Definition",
      "name": "GrossCode",
      "content": "The **Gross code** is the $[[144, 12, 12]]$ Bivariate Bicycle code with parameters:\n- $\\ell = 12$, $m = 6$\n- $A = x^3 + y^2 + y$\n- $B = y^3 + x^2 + x$\n\nThe name comes from \"gross\" = 12 dozen = 144.\n\n**Logical operators**: A basis of logical X operators is given by:\n- $\\overline{X}_\\alpha = X(\\alpha f, 0)$ where $f = 1 + x + x^2 + x^3 + x^6 + x^7 + x^8 + x^9 + (x + x^5 + x^7 + x^{11})y^3$\n- $\\overline{X}'_\\beta = X(\\beta g, \\beta h)$ where:\n  - $g = x + x^2 y + (1 + x)y^2 + x^2 y^3 + y^4$\n  - $h = 1 + (1 + x)y + y^2 + (1 + x)y^3$\n\nThe logical Z operators are obtained by the BB code symmetry:\n- $\\overline{Z}_\\beta = Z(\\beta h^T, \\beta g^T)$\n- $\\overline{Z}'_\\alpha = Z(0, \\alpha f^T)$\n\n**Weight**: $|\\overline{X}_\\alpha| = |f| = 12$ (weight 12 logical).",
      "proof": null,
      "dependencies": ["Def_16"],
      "number": 17
    },
    {
      "id": "Def_18",
      "type": "Definition",
      "name": "DoubleGrossCode",
      "content": "The **Double Gross code** is the $[[288, 12, 18]]$ Bivariate Bicycle code with parameters:\n- $\\ell = 12$, $m = 12$\n- $A = x^3 + y^7 + y^2$\n- $B = y^3 + x^2 + x$\n\n**Logical operators**: The weight-18 logical X operators are:\n$$\\overline{X}_\\alpha = X(\\alpha f, 0)$$\nwhere:\n$$f = 1 + x + x^2 + x^7 + x^8 + x^9 + x^{10} + x^{11} + (1 + x^6 + x^8 + x^{10})y^3 + (x^5 + x^6 + x^9 + x^{10})y^6 + (x^4 + x^8)y^9$$\n\n**Weight**: $|\\overline{X}_\\alpha| = |f| = 18$.",
      "proof": null,
      "dependencies": ["Def_16"],
      "number": 18
    },
    {
      "id": "Prop_1",
      "type": "Proposition",
      "name": "GrossCodeGaugingConstruction",
      "content": "For the Gross code $[[144, 12, 12]]$, there exists a gauging graph $G$ to measure $\\overline{X}_\\alpha$ with the following properties:\n\n(i) **Vertices**: 12 vertices corresponding to the qubits in support of $\\overline{X}_\\alpha$ (the monomials in $f$)\n\n(ii) **Matching edges (18 total)**: For each Z check overlapping the logical, connect vertices $\\gamma, \\delta \\in f$ if they participate in the same Z check, i.e., $\\gamma = B_i^T B_j \\delta$ for some monomials $B_i, B_j \\in B$\n\n(iii) **Expansion edges (4 additional)**: Add edges to increase expansion until deformed code has distance 12. One valid choice:\n$(x^2, x^5 y^3), (x^2, x^6), (x^5 y^3, x^{11} y^3), (x^7 y^3, x^{11} y^3)$\n\n(iv) **Cycle basis**: $G$ has 12 vertices, 22 edges, so cycle rank = $22 - 12 + 1 = 11$. However, due to dependencies in BB code checks, only 7 independent $B_p$ checks are needed.\n\n(v) **Overhead**: 12 new X checks ($A_v$), 7 new Z checks ($B_p$), 22 new qubits (edges). Total auxiliary: 41.\n\n(vi) **Maximum degree**: All checks have weight $\\leq 7$, all qubits have degree $\\leq 7$.",
      "proof": "**Lemma (matching_ensures_sparse_M):** Connecting vertices in the same Z check ensures each row of matching matrix $M$ has weight 1.\n*Proof:* By construction, each pair in a Z check's support is connected by an edge. So deforming the check requires traversing at most one edge.\n\n**Lemma (expansion_preserves_distance):** Random edge additions were tested until deformed code distance = 12.\n*Proof:* Use BP+OSD decoder for upper bounds on distance, integer programming for exact distance verification.\n\n**Lemma (redundant_cycles):** Only 7 of the 11 cycle basis elements give independent $B_p$ checks.\n*Proof:* Let $S$ = submatrix of $H_Z$ for checks overlapping $\\overline{X}_\\alpha$, $C$ = remaining checks. The dimension of $\\{u : \\exists v, uS + vC = 0\\}$ equals row\\_nullity$(H_Z)$ - row\\_nullity$(C) = 4$. So 4 cycles are redundant.\n\n**Lemma (specific_cycles):** The 7 independent cycles are listed explicitly (see paper for vertex sequences).\n*Proof:* Direct verification that these cycles span the needed flux operators.\n\n**Main Proposition:** The construction achieves distance-preserving gauging measurement with 41 auxiliary components.",
      "dependencies": ["Def_17", "Lem_2"],
      "number": 1
    },
    {
      "id": "Prop_2",
      "type": "Proposition",
      "name": "DoubleGrossCodeGaugingConstruction",
      "content": "For the Double Gross code $[[288, 12, 18]]$, there exists a gauging graph $G$ to measure $\\overline{X}_\\alpha$ with:\n\n(i) **Vertices**: 18 vertices (support of $\\overline{X}_\\alpha$)\n\n(ii) **Matching edges**: 27 edges from Z check overlaps\n\n(iii) **Expansion edges**: 7 additional edges (including one multi-edge) to achieve distance 18. One valid choice:\n$(x^4 y^9, x^9 y^6), (y^3, x^{11}), (x^7, x^{10} y^6), (x^8 y^3, x^{10} y^6), (1, x^8), (x^2, x^6 y^3)$ twice\n\n(iv) **Cycle basis**: 13 independent cycles needed (out of 34 - 18 + 1 = 17 total)\n\n(v) **Overhead**: 18 new X checks, 13 new Z checks, 34 new qubits. Total: 65.\n\n(vi) **Maximum degree**: All checks have weight $\\leq 7$, all qubits have degree $\\leq 7$.",
      "proof": "The proof follows the same structure as Proposition 1, with explicit verification of distance preservation and cycle independence for the Double Gross code parameters.",
      "dependencies": ["Def_18", "Lem_2"],
      "number": 2
    },
    {
      "id": "Rem_19",
      "type": "Remark",
      "name": "RelationToLatticeSurgery",
      "content": "The gauging measurement generalizes surface code lattice surgery:\n\n**Surface code recovery**: Consider logical operators $\\overline{X}_1 \\otimes \\overline{X}_2$ on the right and left edges of two adjacent surface code patches. Choosing the gauging graph $G$ as a **ladder** joining the edge qubits results in:\n- The deformed code is a single larger surface code on the union of the patches\n- The final edge measurement step is standard lattice surgery\n\n**Non-adjacent patches**: For surface codes not directly adjacent, add a grid of **dummy vertices** between them in the gauging graph.\n\n**Extension to general codes**: The same procedure works for any pair of matching logical X operators on two code blocks, provided:\n- Each code block has the same choice of $G$ satisfying desiderata (ii) and (iii) from Remark 8\n- \"Bridge\" edges connect the two copies of $G$\n\n**Distance preservation**: The gauging measurement preserves distance when individual logicals have minimal weight and contain no sub-logical operators.",
      "proof": null,
      "dependencies": ["Thm_1", "Rem_8"],
      "number": 19
    },
    {
      "id": "Rem_20",
      "type": "Remark",
      "name": "RelationToShorMeasurement",
      "content": "The gauging measurement can recover Shor-style logical measurement:\n\n**Shor-style setup**: Entangle an auxiliary GHZ state to the code via transversal CX gates, then measure X on auxiliary qubits.\n\n**Gauging equivalent**: Use a graph $G$ with:\n- A **dummy vertex** for each qubit in $\\mathrm{supp}(L)$, each connected by an edge to the corresponding code qubit\n- A **connected subgraph** on the dummy vertices\n\n**Process**: If we measure the edges of the connected subgraph first (projecting dummies into a GHZ state), then measure the remaining edges, the result is equivalent to Shor-style measurement with $X$ measurements commuted backward through CX gates.",
      "proof": null,
      "dependencies": ["Thm_1"],
      "number": 20
    },
    {
      "id": "Rem_21",
      "type": "Remark",
      "name": "RelationToCohenEtAl",
      "content": "The generalized (hypergraph) gauging measurement recovers the Cohen et al. scheme:\n\n**Cohen et al. construction** (from reference [cohen2022low]):\n- Restrict Z-type checks to support of an irreducible X logical\n- Add $d$ layers of dummy vertices for each qubit in $\\mathrm{supp}(L)$\n- Connect copies of each vertex via line graphs\n- Join vertices in each layer via a copy of the hypergraph\n\n**Gauging interpretation**: This is exactly the generalized gauging measurement applied to the hypergraph defined by the restricted Z checks, with the specified layering structure.\n\n**Cross et al. modification**: Use fewer than $d$ layers, exploiting expansion in the logical's Tanner subgraph.\n\n**Product measurement**: The procedures in both references for measuring products of irreducible logicals are captured by adding edges between the corresponding ancilla graphs.",
      "proof": null,
      "dependencies": ["Rem_14", "Thm_1"],
      "number": 21
    },
    {
      "id": "Rem_22",
      "type": "Remark",
      "name": "CSSCodeInitialization",
      "content": "The generalized (hypergraph) gauging measurement can implement CSS code initialization:\n\n**Standard CSS initialization**: Prepare $|0\\rangle^{\\otimes n}$, then measure X-type checks.\n\n**Gauging interpretation**:\n- Start with a trivial code having one dummy vertex per X-type check\n- Apply generalized gauging using the hypergraph corresponding to Z-type checks\n- The \"ungauging\" step performs Z measurement on all qubits (read-out)\n\n**Steane-style measurement**: Combine initialization gauging with a pairwise XX gauging measurement between data and ancilla blocks:\n1. Initialize ancilla block via gauging (as above)\n2. Apply gauging measurement of $XX$ on matching qubit pairs\n3. Ungauge to read out Z on all ancilla qubits\n\nThis recovers Steane's method for fault-tolerant syndrome extraction.",
      "proof": null,
      "dependencies": ["Rem_14"],
      "number": 22
    },
    {
      "id": "Cor_1",
      "type": "Corollary",
      "name": "QubitOverheadBound",
      "content": "The gauging measurement procedure for an arbitrary Pauli operator $L$ of weight $W$ has worst-case qubit overhead $O(W \\log^2 W)$.\n\nSpecifically, the number of auxiliary qubits (edge qubits in $\\bar{\\bar{G}}$) satisfies:\n$$|E_{\\bar{\\bar{G}}}| = O(W \\log^2 W)$$\n\nMoreover, the deformed code is LDPC with check weight and qubit degree bounded by constants (depending on the original code's LDPC parameters).",
      "proof": "**Lemma (graph_construction):** By Remark 9, a suitable graph $G_0$ with $|V| = W$ and $h(G_0) \\geq 1$ can be constructed with $|E_{G_0}| = O(W)$ edges.\n*Proof:* Use matching edges plus constant-degree expander edges.\n\n**Lemma (decongestion_bound):** The Freedman-Hastings decongestion lemma gives $R = O(\\log^2 W)$ layers for cycle-sparsification.\n*Proof:* This is the main result of [freedman2021building].\n\n**Lemma (total_edge_count):** The cycle-sparsified graph has:\n$$|E_{\\bar{\\bar{G}}}| = |E_{G_0}| + R \\cdot |V| + (\\text{cellulation edges}) = O(W) + O(\\log^2 W) \\cdot O(W) + O(W \\log^2 W) = O(W \\log^2 W)$$\n*Proof:* Inter-layer edges: $R \\cdot |V| = O(W \\log^2 W)$. Cellulation adds $O(1)$ edges per cycle, with $O(W)$ cycles, so $O(W)$ total.\n\n**Main Corollary:** The qubit overhead equals the edge count: $O(W \\log^2 W)$.",
      "dependencies": ["Rem_9", "Def_10", "Rem_6"],
      "number": 1
    },
    {
      "id": "Rem_23",
      "type": "Remark",
      "name": "NonabelianGeneralization",
      "content": "The gauging measurement procedure can be generalized beyond Pauli operators:\n\n**Finite group generalization**: The procedure applies to any representation of a finite group $G$ by operators with tensor product factorization. This includes:\n- Qudit systems (using $\\mathbb{Z}_d$ instead of $\\mathbb{Z}_2$)\n- Non-Pauli operators (e.g., Clifford operators in topological codes)\n- Magic state preparation via measurement of non-Clifford operators\n\n**Nonabelian case**: For nonabelian groups, measuring local charges does not fix a definite global charge. The total charge is a superposition consistent with local outcomes.\n\n**Example**: Measurement of Clifford operators in topological codes (see [Davydova2024]) uses similar gauging ideas to produce magic states.",
      "proof": null,
      "dependencies": ["Thm_1"],
      "number": 23
    },
    {
      "id": "Lem_7",
      "type": "Lemma",
      "name": "GaussLawConstraint",
      "content": "Let $G = (V, E)$ be a gauging graph for X-type logical operator $L = \\prod_{v \\in \\mathcal{L}} X_v$. The Gauss's law operators $\\{A_v\\}_{v \\in V}$ satisfy the constraint:\n$$\\prod_{v \\in V} A_v = L$$\n\nThis means the product of all $A_v$ measurement outcomes equals the measurement outcome of $L$:\n$$\\prod_{v \\in V} \\varepsilon_v = \\sigma$$\nwhere $\\varepsilon_v \\in \\{\\pm 1\\}$ is the outcome of measuring $A_v$ and $\\sigma$ is the eigenvalue of $L$.",
      "proof": "**Lemma (edge_cancellation):** In the product $\\prod_{v \\in V} A_v$, each edge qubit $X_e$ appears exactly twice.\n*Proof:* Each edge $e = \\{u, w\\}$ has exactly two endpoints. So $X_e$ appears in $A_u$ and $A_w$, and nowhere else.\n\n**Lemma (X_squared_identity):** $X_e^2 = I$ for all edges $e$.\n*Proof:* Standard Pauli algebra.\n\n**Main Lemma:** $\\prod_{v \\in V} A_v = \\prod_{v \\in V} \\left(X_v \\prod_{e \\ni v} X_e\\right) = \\prod_{v \\in V} X_v \\cdot \\prod_{e \\in E} X_e^2 = L \\cdot I = L$.",
      "dependencies": ["Def_6"],
      "number": 7
    },
    {
      "id": "Def_19",
      "type": "Definition",
      "name": "CSSCode",
      "content": "A **CSS (Calderbank-Shor-Steane) code** is a stabilizer code where every stabilizer generator is either purely X-type or purely Z-type.\n\nFormally, an $[[n, k, d]]$ CSS code is specified by two classical linear codes:\n- $C_X \\subseteq \\mathbb{F}_2^n$ with parity check matrix $H_X$\n- $C_Z \\subseteq \\mathbb{F}_2^n$ with parity check matrix $H_Z$\n\nsatisfying the **CSS condition**: $H_X H_Z^T = 0$ (equivalently, $C_Z^\\perp \\subseteq C_X$).\n\n**Stabilizer generators**:\n- X-type: $\\{\\prod_{i : (H_X)_{j,i} = 1} X_i\\}$ for each row $j$ of $H_X$\n- Z-type: $\\{\\prod_{i : (H_Z)_{j,i} = 1} Z_i\\}$ for each row $j$ of $H_Z$\n\n**Code parameters**:\n- $n$ = number of physical qubits\n- $k = \\dim(C_X) + \\dim(C_Z) - n$ = number of logical qubits\n- $d = \\min(d_X, d_Z)$ where $d_X = \\min\\{|c| : c \\in C_X \\setminus C_Z^\\perp\\}$ and $d_Z = \\min\\{|c| : c \\in C_Z \\setminus C_X^\\perp\\}$",
      "proof": null,
      "dependencies": ["Def_1"],
      "number": 19
    },
    {
      "id": "Lem_8",
      "type": "Lemma",
      "name": "CommutationConditionPauli",
      "content": "Let $P = i^{\\sigma_P} \\prod_v X_v^{a_v} Z_v^{b_v}$ and $Q = i^{\\sigma_Q} \\prod_v X_v^{c_v} Z_v^{d_v}$ be two Pauli operators.\n\nThen $P$ and $Q$ commute ($[P, Q] = 0$) if and only if:\n$$\\sum_v (a_v d_v + b_v c_v) \\equiv 0 \\pmod{2}$$\n\nEquivalently, using support notation:\n$$|\\mathcal{S}_X(P) \\cap \\mathcal{S}_Z(Q)| + |\\mathcal{S}_Z(P) \\cap \\mathcal{S}_X(Q)| \\equiv 0 \\pmod{2}$$\n\nThis is the **symplectic inner product** condition.",
      "proof": "**Lemma (single_qubit_anticommutation):** On a single qubit, $X$ and $Z$ anticommute: $XZ = -ZX$.\n*Proof:* Direct calculation using Pauli matrices.\n\n**Lemma (commutation_accumulation):** When computing $PQ$ vs $QP$, each site $v$ where $P$ acts by $X$ (or $Y$) and $Q$ acts by $Z$ (or $Y$) contributes a factor of $-1$.\n*Proof:* If $P$ has $X$ factor at $v$ and $Q$ has $Z$ factor at $v$, swapping their order gives $-1$.\n\n**Main Lemma:** Total sign from swapping = $(-1)^{\\sum_v (a_v d_v + b_v c_v)}$. Commutation requires this to be $+1$, i.e., exponent even.",
      "dependencies": ["Rem_1"],
      "number": 8
    },
    {
      "id": "Prop_3",
      "type": "Proposition",
      "name": "FluxOperatorCommutation",
      "content": "The flux operators $\\{B_p\\}_{p \\in C}$ commute with all Gauss's law operators $\\{A_v\\}_{v \\in V}$:\n$$[A_v, B_p] = 0 \\quad \\text{for all } v \\in V, p \\in C$$",
      "proof": "**Lemma (support_intersection):** The X-support of $A_v$ on edge qubits is $\\{e : v \\in e\\}$ (edges incident to $v$). The Z-support of $B_p$ on edge qubits is $p$ (edges in the cycle).\n*Proof:* By definition of $A_v = X_v \\prod_{e \\ni v} X_e$ and $B_p = \\prod_{e \\in p} Z_e$.\n\n**Lemma (cycle_incidence_parity):** For any vertex $v$ and cycle $p$: $|\\{e \\in p : v \\in e\\}| \\equiv 0 \\pmod{2}$.\n*Proof:* A cycle visits each vertex an even number of times (entering and leaving). So $v$ is incident to an even number of edges in $p$.\n\n**Main Proposition:** By Lemma 8 (symplectic inner product), $[A_v, B_p] = 0$ iff $|\\mathcal{S}_X(A_v) \\cap \\mathcal{S}_Z(B_p)| \\equiv 0 \\pmod{2}$. This equals $|\\{e \\in p : v \\in e\\}| \\equiv 0$ by the cycle parity lemma.",
      "dependencies": ["Def_6", "Def_7", "Lem_8"],
      "number": 3
    },
    {
      "id": "Def_20",
      "type": "Definition",
      "name": "SubsystemCode",
      "content": "A **subsystem code** is a generalization of a stabilizer code where the code space factors as:\n$$\\mathcal{C} = \\mathcal{C}_{\\text{logical}} \\otimes \\mathcal{C}_{\\text{gauge}}$$\n\n**Components**:\n- **Gauge group** $\\mathcal{G}$: A (generally non-abelian) subgroup of the Pauli group\n- **Stabilizer group** $\\mathcal{S} = Z(\\mathcal{G}) \\cap \\mathcal{G}$: The center of the gauge group intersected with itself (abelian)\n- **Code space**: Simultaneous $+1$ eigenspace of all stabilizers in $\\mathcal{S}$\n- **Gauge qubits**: Degrees of freedom in $\\mathcal{C}_{\\text{gauge}}$, not used for logical information\n\n**Gauge fixing**: A subsystem code can be converted to a stabilizer code by measuring gauge operators, collapsing $\\mathcal{C}_{\\text{gauge}}$ to a definite state.\n\nThe deformed code after gauging is a subsystem code when $|E| > |V| - 1$, with gauge degrees of freedom on the edge qubits.",
      "proof": null,
      "dependencies": ["Def_1"],
      "number": 20
    },
    {
      "id": "Rem_24",
      "type": "Remark",
      "name": "AlgorithmCorrectness",
      "content": "Algorithm 1 (Gauging measurement procedure) produces the correct post-measurement state up to a byproduct operator $X_V(c')$.\n\n**Byproduct determination**: The byproduct $c' \\in C_0(G; \\mathbb{Z}_2)$ is determined by the $Z_e$ measurement outcomes $\\{\\omega_e\\}$:\n$$c' = \\text{any 0-chain satisfying } \\delta_0(c') = z$$\nwhere $z_e = \\frac{1 - \\omega_e}{2} \\in \\{0, 1\\}$ encodes the measurement outcome.\n\n**Constructive determination**: Given a spanning tree $T$ of $G$ rooted at $v_0$:\n- For each vertex $v \\neq v_0$, let $\\gamma_v$ be the unique path in $T$ from $v_0$ to $v$\n- Set $c'_v = \\bigoplus_{e \\in \\gamma_v} z_e$ (parity of outcomes along path)\n- Set $c'_{v_0} = 0$\n\nThis gives $\\delta_0(c') = z$ because tree paths have the required boundary property.",
      "proof": null,
      "dependencies": ["Thm_1"],
      "number": 24
    },
    {
      "id": "Lem_9",
      "type": "Lemma",
      "name": "CycleRankFormula",
      "content": "For a connected graph $G = (V, E)$, the **cycle rank** (also called **cyclomatic number** or **first Betti number**) is:\n$$\\beta_1(G) = |E| - |V| + 1$$\n\nThis equals:\n(i) The dimension of $\\ker(\\partial_1)$ (space of 1-cycles)\n(ii) The number of edges not in any spanning tree\n(iii) The minimum number of edges that must be removed to make $G$ acyclic",
      "proof": "**Lemma (spanning_tree_edges):** A spanning tree of $G$ has exactly $|V| - 1$ edges.\n*Proof:* A tree on $n$ vertices has $n - 1$ edges. A spanning tree includes all $|V|$ vertices.\n\n**Lemma (non_tree_edges_create_cycles):** Each edge $e \\notin T$ (where $T$ is a spanning tree) creates a unique fundamental cycle.\n*Proof:* Adding $e$ to $T$ creates exactly one cycle, since $T$ is connected and acyclic.\n\n**Lemma (fundamental_cycles_span):** The fundamental cycles form a basis for the cycle space.\n*Proof:* They are linearly independent (each contains a unique non-tree edge). Any cycle can be written as a symmetric difference of fundamental cycles.\n\n**Main Lemma:** Number of non-tree edges = $|E| - (|V| - 1) = |E| - |V| + 1 = \\beta_1(G)$.",
      "dependencies": ["Def_4"],
      "number": 9
    },
    {
      "id": "Def_21",
      "type": "Definition",
      "name": "TannerGraph",
      "content": "The **Tanner graph** of a stabilizer code is a bipartite graph $T = (Q \\cup C, E_T)$ where:\n- $Q$ = set of qubit nodes (one per physical qubit)\n- $C$ = set of check nodes (one per stabilizer generator)\n- $E_T$ = edges connecting qubit $q$ to check $c$ iff $c$ acts non-trivially on $q$\n\n**For CSS codes**: The Tanner graph can be split into X-type and Z-type subgraphs:\n- $T_X$: connects qubits to X-type checks\n- $T_Z$: connects qubits to Z-type checks\n\n**LDPC condition**: A code is LDPC iff its Tanner graph has bounded degree (both qubit and check degrees bounded by constants).\n\n**Deformed code Tanner graph** (Figure 1 in paper): Shows the structure after gauging, with additional Gauss's law checks $\\mathcal{A}$, flux checks $\\mathcal{B}$, and edge qubits $\\mathcal{E}$.",
      "proof": null,
      "dependencies": ["Def_1"],
      "number": 21
    },
    {
      "id": "Rem_25",
      "type": "Remark",
      "name": "MatchingMatrixM",
      "content": "The **matching matrix** $M$ in the deformed code Tanner graph (Figure 1) encodes how original checks are deformed by paths in $G$.\n\n**Structure**: $M$ is a binary matrix with:\n- Rows indexed by checks in $\\mathcal{S}$ (checks with Z-support on $L$)\n- Columns indexed by edges in $G$\n- $M_{j,e} = 1$ iff edge $e$ is in the deforming path $\\gamma_j$ for check $s_j$\n\n**Optimization goal**: Choose paths $\\{\\gamma_j\\}$ to minimize:\n- Row weight of $M$ (path lengths)\n- Column weight of $M$ (edge participation in multiple paths)\n\n**Perfect matching approach**: When $|\\mathcal{S}_{Z,j} \\cap V| = 2$ for all checks $s_j \\in \\mathcal{S}$, a $\\mathbb{Z}_2$-perfect-matching ensures each row of $M$ has weight 1.",
      "proof": null,
      "dependencies": ["Lem_1", "Def_9"],
      "number": 25
    },
    {
      "id": "Lem_10",
      "type": "Lemma",
      "name": "RedundantCyclesInBBCode",
      "content": "For a Bivariate Bicycle code with parity check matrices $H_X = [A|B]$ and $H_Z = [B^T|A^T]$, when measuring logical $\\overline{X}_\\alpha$ supported on left qubits, the number of redundant cycles in the gauging graph is:\n$$\\dim\\{u : \\exists v, uS + vC = 0\\} = \\mathrm{row\\_nullity}(H_Z) - \\mathrm{row\\_nullity}(C)$$\n\nwhere:\n- $S$ = submatrix of $H_Z$ with rows for checks overlapping $\\overline{X}_\\alpha$\n- $C$ = submatrix of $H_Z$ with rows for checks not overlapping $\\overline{X}_\\alpha$",
      "proof": "**Lemma (cycle_from_check_relation):** If $uS + vC = 0$ for vectors $u, v$, then the product of checks $\\prod_{j : u_j = 1} \\tilde{s}_j \\cdot \\prod_{j : v_j = 1} s_j$ has support only on edge qubits.\n*Proof:* The $uS + vC = 0$ condition means the Z-supports cancel on original qubits. After deformation, only edge Z-support remains.\n\n**Lemma (edge_support_is_cycle):** The edge support of this product is a cycle in $G$.\n*Proof:* The product is a stabilizer (product of stabilizers). It has no original qubit support. So it must be a product of $B_p$ operators, meaning its edge support is a union of cycles.\n\n**Main Lemma:** The dimension of redundant cycles equals the dimension of solutions $(u, v)$ to $uS + vC = 0$, which is row\\_nullity$(H_Z)$ - row\\_nullity$(C)$.",
      "dependencies": ["Def_16", "Lem_1"],
      "number": 10
    },
    {
      "id": "Cor_2",
      "type": "Corollary",
      "name": "GrossCodeRedundantCycles",
      "content": "For the Gross code $[[144, 12, 12]]$ with logical $\\overline{X}_\\alpha$ (weight 12), the gauging graph $G$ with 12 vertices and 22 edges has:\n- Cycle rank: $22 - 12 + 1 = 11$\n- Redundant cycles: $4$\n- Independent flux checks needed: $11 - 4 = 7$",
      "proof": "**Direct calculation**: Apply Lemma 10 to the Gross code parameters:\n- row\\_nullity$(H_Z) = 144 - (144 - 12)/2 = 78$ (from $k = 12$)\n- row\\_nullity$(C)$ computed from the submatrix of checks not overlapping $\\overline{X}_\\alpha$\n- Difference = $4$",
      "dependencies": ["Lem_10", "Def_17"],
      "number": 2
    },
    {
      "id": "Rem_26",
      "type": "Remark",
      "name": "DecoderRequirements",
      "content": "Decoding the fault-tolerant gauging measurement requires handling several types of syndromes:\n\n**Syndrome types**:\n(i) $A_v$ syndromes: Created by $Z$ errors on vertex and edge qubits\n(ii) $B_p$ syndromes: Created by $X$ errors on edge qubits\n(iii) $\\tilde{s}_j$ syndromes: Created by both $X$ and $Z$ errors on vertex and edge qubits\n\n**Decoder approaches**:\n- **General-purpose**: Belief propagation with ordered statistics post-processing (BP+OSD)\n- **Structured**: Matching on $A_v$ syndromes (similar to surface code), combined with code-specific decoding for $\\tilde{s}_j$\n\n**Open question**: Designing decoders that exploit the structure of the gauging measurement for improved performance.",
      "proof": null,
      "dependencies": ["Thm_2"],
      "number": 26
    },
    {
      "id": "Rem_27",
      "type": "Remark",
      "name": "ComparisonToPriorWork",
      "content": "Comparison of qubit overhead for logical measurement schemes:\n\n**Cohen et al. [cohen2022low]**: Overhead $\\Theta(Wd)$ where $W$ = logical weight, $d$ = code distance\n- For good codes with $d = \\Theta(n)$: overhead $\\Theta(n^2)$\n\n**Cross et al. [cross2024linear]**: Overhead $\\Theta(W)$ when:\n- Sufficient expansion in the logical's Tanner subgraph\n- Low-weight auxiliary gauge-fixing checks exist\n\n**This work (gauging measurement)**: Overhead $O(W \\log^2 W)$\n- Always achievable via cycle-sparsification\n- Often better in practice (e.g., Gross code: 41 vs larger overhead for prior methods)\n\n**Key advantage**: The flexibility in choosing the gauging graph $G$ allows optimization for specific code instances.",
      "proof": null,
      "dependencies": ["Cor_1", "Prop_1"],
      "number": 27
    },
    {
      "id": "Prop_4",
      "type": "Proposition",
      "name": "BBCodeSymmetry",
      "content": "Bivariate Bicycle codes have a symmetry between left and right qubits that relates X-type and Z-type logical operators:\n\nIf $\\overline{X} = X(p, q)$ is a logical X operator (acting on left qubits $(p, L)$ and right qubits $(q, R)$), then:\n$$\\overline{Z} = Z(q^T, p^T)$$\nis the corresponding logical Z operator, where $p^T = p(x^{-1}, y^{-1})$.\n\n**Consequence for gauging**: A gauging graph construction for measuring $\\overline{X}_\\alpha = X(\\alpha f, 0)$ also works for measuring $\\overline{Z}'_\\alpha = Z(0, \\alpha f^T)$ with the roles of left and right qubits swapped.",
      "proof": "**Lemma (parity_check_symmetry):** $H_X = [A|B]$ and $H_Z = [B^T|A^T]$ implies: if $H_X \\cdot (p, q)^T = 0$, then $H_Z \\cdot (q^T, p^T)^T = 0$.\n*Proof:* $H_Z \\cdot (q^T, p^T)^T = B^T q^T + A^T p^T = (qB + pA)^T = (H_X \\cdot (p, q)^T)^T = 0$.\n\n**Lemma (commutation_preserved):** The symplectic inner product is preserved: $\\langle X(p,q), Z(r,s) \\rangle = \\langle X(s^T, r^T), Z(q^T, p^T) \\rangle$.\n*Proof:* Both equal $p \\cdot r + q \\cdot s$ (dot product mod 2).\n\n**Main Proposition:** The symmetry $(p, q) \\mapsto (q^T, p^T)$ preserves the logical operator structure, swapping X and Z types.",
      "dependencies": ["Def_16"],
      "number": 4
    }
  ]
}
