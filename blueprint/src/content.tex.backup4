%==============================================================================
% Auto-generated by autoinformalization
% Library: gauging_ldpc
% Generated: 2026-02-01 21:40:47
%==============================================================================

\chapter{Introduction}

This document contains the informal mathematical content derived from the
Lean 4 formalization in the \texttt{gauging_ldpc} library.


%--- Rem_1: Vertex Set Partition ---
\begin{remark}[Vertex Set Partition]
\label{rem:vertex__set__partition}
\lean{GaugingLDPC.VertexPartition}
\leanok

Let $\mathcal{G} = (\mathcal{G}_0, \mathcal{G}_1, \mathcal{G}_2)$ be a cell complex (gauging graph) where $\mathcal{G}_0$ is the set of vertices, $\mathcal{G}_1$ is the set of edges, and $\mathcal{G}_2$ is the set of 2-cells (plaquettes). Let $\mathbb{F}_w$ be the finite field with $w$ elements. For each vertex $v \in \mathcal{G}_0$, we define $\Sigma(v)$ to be a subset of matter qudits of the original quantum error-correcting code. The collection $\{\Sigma(v)\}_{v \in \mathcal{G}_0}$ forms a partition of the matter qudits, meaning:

\begin{enumerate}
    \item \textbf{Disjointness}: $\Sigma(v) \cap \Sigma(w) = \emptyset$ for all $v \neq w$ in $\mathcal{G}_0$.
    \item \textbf{Covering}: $\bigcup_{v \in \mathcal{G}_0} \Sigma(v)$ equals the set of all matter qudits.
\end{enumerate}

A \emph{cell complex} is a structure $\mathcal{G}$ consisting of:
\begin{itemize}
    \item A finite type $\mathcal{G}_0$ of vertices (0-cells),
    \item A type $\mathcal{G}_1$ of edges (1-cells),
    \item A type $\mathcal{G}_2$ of plaquettes (2-cells).
\end{itemize}

A \emph{vertex partition} for a cell complex $\mathcal{G}$ and a set $M$ of matter qudits consists of:
\begin{itemize}
    \item An assignment $\Sigma : \mathcal{G}_0 \to \mathcal{P}(M)$ sending each vertex to its set of matter qudits,
    \item An indexed partition structure ensuring that $\{\Sigma(v)\}_{v \in \mathcal{G}_0}$ forms a partition of $M$.
\end{itemize}

The indexed partition structure from Mathlib provides:
\begin{itemize}
    \item If $q \in \Sigma(i)$ and $q \in \Sigma(j)$, then $i = j$ (disjointness),
    \item The union $\bigcup_v \Sigma(v)$ is the entire set $M$ (covering).
\end{itemize}
\end{remark}

\begin{proof}
\leanok
No proof needed for remarks.
\end{proof}

\begin{lemma}[Pairwise Disjointness]
\label{lem:pairwise_disjoint}
\lean{GaugingLDPC.VertexPartition.pairwiseDisjoint}
\leanok
\uses{rem:vertex__set__partition}

For distinct vertices $v \neq w$, we have $\Sigma(v) \cap \Sigma(w) = \emptyset$. That is, the sets $\{\Sigma(v)\}_{v \in \mathcal{G}_0}$ are pairwise disjoint.
\end{lemma}

\begin{proof}
\leanok

This follows directly from the disjointness property of the underlying indexed partition structure.
\end{proof}

\begin{lemma}[Intersection is Empty]
\label{lem:inter_eq_empty}
\lean{GaugingLDPC.VertexPartition.inter_eq_empty}
\leanok
\uses{lem:pairwise_disjoint}

For any vertices $v, w \in \mathcal{G}_0$ with $v \neq w$, we have $\Sigma(v) \cap \Sigma(w) = \emptyset$.
\end{lemma}

\begin{proof}
\leanok
\uses{lem:pairwise_disjoint}
Let $v \neq w$ be given. From the pairwise disjointness lemma, we obtain that $\Sigma(v)$ and $\Sigma(w)$ are disjoint. By the equivalence between disjointness and having empty intersection, the result follows.
\end{proof}

\begin{lemma}[Union Covers All Qudits]
\label{lem:iunion_eq_univ}
\lean{GaugingLDPC.VertexPartition.iUnion_eq_univ}
\leanok
\uses{rem:vertex__set__partition}

The union of all $\Sigma(v)$ equals the set of all matter qudits:
\[
\bigcup_{v \in \mathcal{G}_0} \Sigma(v) = M.
\]
\end{lemma}

\begin{proof}
\leanok

This follows directly from the covering property of the underlying indexed partition structure.
\end{proof}

\begin{lemma}[Existence of Containing Set]
\label{lem:exists_mem}
\lean{GaugingLDPC.VertexPartition.exists_mem}
\leanok
\uses{rem:vertex__set__partition}

Every matter qudit belongs to some $\Sigma(v)$: for all $q \in M$, there exists $v \in \mathcal{G}_0$ such that $q \in \Sigma(v)$.
\end{lemma}

\begin{proof}
\leanok

This follows directly from the existence property of the underlying indexed partition structure.
\end{proof}

\begin{definition}[Index Function]
\label{def:index}
\lean{GaugingLDPC.VertexPartition.index}
\leanok
\uses{rem:vertex__set__partition}

The \emph{index function} $\mathrm{index} : M \to \mathcal{G}_0$ assigns each qudit to its unique vertex, i.e., for each qudit $q$, $\mathrm{index}(q)$ is the unique vertex $v$ such that $q \in \Sigma(v)$.
\end{definition}

\begin{lemma}[Membership Characterization]
\label{lem:mem_iff_index_eq}
\lean{GaugingLDPC.VertexPartition.mem_iff_index_eq}
\leanok
\uses{def:index, rem:vertex__set__partition}

A qudit $q$ belongs to $\Sigma(v)$ if and only if $\mathrm{index}(q) = v$:
\[
q \in \Sigma(v) \iff \mathrm{index}(q) = v.
\]
\end{lemma}

\begin{proof}
\leanok

This follows directly from the membership characterization of the underlying indexed partition structure.
\end{proof}

\begin{lemma}[Qudit Belongs to Its Index]
\label{lem:mem_index}
\lean{GaugingLDPC.VertexPartition.mem_index}
\leanok
\uses{def:index, rem:vertex__set__partition}

Each qudit belongs to $\Sigma$ of its index: for all $q \in M$, we have $q \in \Sigma(\mathrm{index}(q))$.
\end{lemma}

\begin{proof}
\leanok

This follows directly from the membership property of the underlying indexed partition structure.
\end{proof}

\begin{lemma}[Uniqueness of Vertex]
\label{lem:eq_of_mem}
\lean{GaugingLDPC.VertexPartition.eq_of_mem}
\leanok
\uses{rem:vertex__set__partition}

If a qudit $q$ is in both $\Sigma(v)$ and $\Sigma(w)$, then $v = w$.
\end{lemma}

\begin{proof}
\leanok

This follows directly from the uniqueness property of the underlying indexed partition structure.
\end{proof}

\begin{definition}[Parts of the Partition]
\label{def:parts}
\lean{GaugingLDPC.VertexPartition.parts}
\leanok
\uses{rem:vertex__set__partition}

The \emph{parts} of the partition is the range of $\Sigma$ viewed as a set of sets:
\[
\mathrm{parts} := \{\Sigma(v) : v \in \mathcal{G}_0\}.
\]
\end{definition}

\begin{theorem}[Is Partition]
\label{thm:is_partition_of_nonempty}
\lean{GaugingLDPC.VertexPartition.isPartition_of_nonempty}
\leanok
\uses{def:parts, def:index, lem:mem_index, lem:eq_of_mem}

If all $\Sigma(v)$ are nonempty, then the parts form a set partition in the sense of Mathlib's \texttt{Setoid.IsPartition}. That is:
\begin{enumerate}
    \item $\emptyset \notin \mathrm{parts}$,
    \item For every qudit $q$, there exists a unique $s \in \mathrm{parts}$ such that $q \in s$.
\end{enumerate}
\end{theorem}

\begin{proof}
\leanok
\uses{def:parts, def:index, lem:mem_index, lem:eq_of_mem}
We prove both conditions of the partition definition.

For the first condition, suppose for contradiction that $\emptyset \in \mathrm{parts}$. Then there exists some vertex $v$ such that $\Sigma(v) = \emptyset$. But by hypothesis, $\Sigma(v)$ is nonempty, which is a contradiction. Hence $\emptyset \notin \mathrm{parts}$.

For the second condition, let $q$ be any qudit. We claim that $\Sigma(\mathrm{index}(q))$ is the unique element of $\mathrm{parts}$ containing $q$. First, $\Sigma(\mathrm{index}(q)) \in \mathrm{parts}$ since $\mathrm{index}(q)$ is a vertex, and $q \in \Sigma(\mathrm{index}(q))$ by the property that each qudit belongs to $\Sigma$ of its index. For uniqueness, suppose $s \in \mathrm{parts}$ with $q \in s$. Then $s = \Sigma(w)$ for some vertex $w$, and $q \in \Sigma(w)$. Rewriting, we have $q \in \Sigma(w)$. By the uniqueness lemma, since $q \in \Sigma(w)$ and $q \in \Sigma(\mathrm{index}(q))$, we conclude $w = \mathrm{index}(q)$, and hence $s = \Sigma(\mathrm{index}(q))$.
\end{proof}

\begin{definition}[Representative Qudit]
\label{def:some}
\lean{GaugingLDPC.VertexPartition.some}
\leanok
\uses{rem:vertex__set__partition}

Each vertex $v$ has a \emph{representative qudit} $\mathrm{some}(v) \in \Sigma(v)$.
\end{definition}

\begin{lemma}[Index Equality from Same Membership]
\label{lem:index_eq_of_mem_same}
\lean{GaugingLDPC.VertexPartition.index_eq_of_mem_same}
\leanok
\uses{def:index, lem:mem_iff_index_eq}

Two qudits in the same $\Sigma(v)$ have the same index: if $q_1, q_2 \in \Sigma(v)$, then $\mathrm{index}(q_1) = \mathrm{index}(q_2)$.
\end{lemma}

\begin{proof}
\leanok
\uses{lem:mem_iff_index_eq}
Suppose $q_1, q_2 \in \Sigma(v)$. By the membership characterization lemma, $q_1 \in \Sigma(v)$ implies $\mathrm{index}(q_1) = v$, and $q_2 \in \Sigma(v)$ implies $\mathrm{index}(q_2) = v$. Rewriting with these equalities, we obtain $\mathrm{index}(q_1) = \mathrm{index}(q_2)$.
\end{proof}

\begin{definition}[Induced Setoid]
\label{def:to_setoid}
\lean{GaugingLDPC.VertexPartition.toSetoid}
\leanok
\uses{rem:vertex__set__partition}

The partition induces a \emph{setoid} (equivalence relation) on the matter qudits, where two qudits are equivalent if and only if they belong to the same $\Sigma(v)$.
\end{definition}

\begin{lemma}[Setoid Equivalence Characterization]
\label{lem:to_setoid_equiv_iff}
\lean{GaugingLDPC.VertexPartition.toSetoid_equiv_iff}
\leanok
\uses{def:to_setoid, def:index}

Two qudits $q_1, q_2$ are equivalent under the induced setoid if and only if they have the same index:
\[
q_1 \sim q_2 \iff \mathrm{index}(q_1) = \mathrm{index}(q_2).
\]
\end{lemma}

\begin{proof}
\leanok

This holds by reflexivity (definitional equality).
\end{proof}

\begin{definition}[Equivalence to Quotient]
\label{def:equiv_quotient}
\lean{GaugingLDPC.VertexPartition.equivQuotient}
\leanok
\uses{rem:vertex__set__partition}

There is a canonical equivalence between the set of vertices $\mathcal{G}_0$ and the quotient of $M$ by the induced setoid (the set of equivalence classes).
\end{definition}

\begin{definition}[Projection to Quotient]
\label{def:proj}
\lean{GaugingLDPC.VertexPartition.proj}
\leanok
\uses{rem:vertex__set__partition}

The \emph{projection} $\mathrm{proj} : M \to M/{\sim}$ sends each qudit to its equivalence class.
\end{definition}

\begin{lemma}[Projection Equality]
\label{lem:proj_eq_of_mem_same}
\lean{GaugingLDPC.VertexPartition.proj_eq_of_mem_same}
\leanok
\uses{def:proj, lem:index_eq_of_mem_same}

Qudits in the same $\Sigma(v)$ project to the same equivalence class: if $q_1, q_2 \in \Sigma(v)$, then $\mathrm{proj}(q_1) = \mathrm{proj}(q_2)$.
\end{lemma}

\begin{proof}
\leanok
\uses{lem:index_eq_of_mem_same}
Simplifying using the definition of projection and the characterization of equality in the quotient, it suffices to show $\mathrm{index}(q_1) = \mathrm{index}(q_2)$. This follows directly from the lemma that two qudits in the same $\Sigma(v)$ have the same index.
\end{proof}

\begin{lemma}[Projection Fiber]
\label{lem:proj_fiber}
\lean{GaugingLDPC.VertexPartition.proj_fiber}
\leanok
\uses{def:proj, def:equiv_quotient, rem:vertex__set__partition}

The fiber of the projection over a vertex's equivalence class is exactly $\Sigma(v)$:
\[
\mathrm{proj}^{-1}(\{[v]\}) = \Sigma(v).
\]
\end{lemma}

\begin{proof}
\leanok
\uses{def:equiv_quotient}
By extensionality, it suffices to show that for any qudit $q$, $q$ is in the preimage if and only if $q \in \Sigma(v)$. Simplifying using the definitions of preimage, singleton membership, projection, and equivalence, we prove both directions.

For the forward direction, suppose $\mathrm{proj}(q) = [v]$. By the membership characterization, we need to show $\mathrm{index}(q) = v$. We have that $[\mathrm{index}(q)] = [v]$ in the quotient, and since the equivalence is a bijection (and hence injective), we conclude $\mathrm{index}(q) = v$.

For the backward direction, suppose $q \in \Sigma(v)$. By the membership characterization, $\mathrm{index}(q) = v$. Rewriting with this equality and using the property that $\mathrm{proj}(q) = [\mathrm{index}(q)]$, we obtain $\mathrm{proj}(q) = [v]$.
\end{proof}

%--- Rem_2: Chain Complex Notation ---
\begin{remark}[Chain Complex Notation]
\label{rem:chain__complex__notation}
\lean{GaugingLDPC}
\leanok

Let $\mathcal{G}$ be a connected graph. The \emph{chain complex} of $\mathcal{G}$ with coefficients in a field $A$ (typically $A = \mathbb{F}_p$ for prime $p$) consists of:

\begin{enumerate}
    \item \textbf{Chain groups}: $C_1(\mathcal{G}, A)$ is the $A$-vector space with basis the edges of $\mathcal{G}$, and $C_0(\mathcal{G}, A)$ is the $A$-vector space with basis the vertices of $\mathcal{G}$.
    
    \item \textbf{Boundary map}: $\partial_1: C_1(\mathcal{G}, A) \to C_0(\mathcal{G}, A)$ is the linear map defined on basis elements by $\partial_1(e) = v_+ - v_-$ where $e$ is an edge with endpoints $v_+$ and $v_-$ (with fixed orientation).
    
    \item \textbf{Augmentation map}: $\varepsilon: C_0(\mathcal{G}, A) \to A$ is the linear map defined by $\varepsilon(v) = 1$ for all vertices $v$. For a general chain $c = \sum_i c_i v_i$, we have $\varepsilon(c) = \sum_i c_i$.
    
    \item \textbf{Augmented sequence}: $C_1(\mathcal{G}) \xrightarrow{\partial_1} C_0(\mathcal{G}) \xrightarrow{\varepsilon} A \to 0$.
\end{enumerate}

An \emph{oriented graph} is specified by a structure $(V, E, \mathrm{source}, \mathrm{target})$ where:
\begin{itemize}
    \item $V$ is a finite type of vertices,
    \item $E$ is a finite type of edges,
    \item $\mathrm{source}: E \to V$ assigns the source vertex of each edge,
    \item $\mathrm{target}: E \to V$ assigns the target vertex of each edge,
    \item For all edges $e$, $\mathrm{source}(e) \neq \mathrm{target}(e)$.
\end{itemize}

The chain groups are formalized as:
\begin{itemize}
    \item $C_0(\mathcal{G}, A) = V \to_0 A$ (finitely supported functions from vertices to $A$),
    \item $C_1(\mathcal{G}, A) = E \to_0 A$ (finitely supported functions from edges to $A$).
\end{itemize}

The boundary of a single edge $e$ is defined as:
\[
\partial_1(e) = \mathbf{1}_{\mathrm{target}(e)} - \mathbf{1}_{\mathrm{source}(e)}
\]
where $\mathbf{1}_v$ denotes the basis element for vertex $v$.

The fundamental chain complex property is $\varepsilon \circ \partial_1 = 0$, which follows from:
\[
\varepsilon(\partial_1(e)) = \varepsilon(v_+ - v_-) = \varepsilon(v_+) - \varepsilon(v_-) = 1 - 1 = 0.
\]

This implies $\mathrm{im}(\partial_1) \subseteq \ker(\varepsilon)$.

\end{remark}

\begin{proof}
\leanok
No proof needed for remarks.
\end{proof}

%--- Rem_3: Symmetry Action and Abelian Group Structure ---
\begin{remark}[Symmetry Action and Abelian Group Structure]
\label{rem:symmetry__action_and__abelian__group__structure}
\lean{GaugingLDPC.SymmetryGroup, GaugingLDPC.OperatorAlgebra, GaugingLDPC.SymmetryAction, GaugingLDPC.OnsiteSymmetryOp, GaugingLDPC.CharacterGroup}
\leanok

Let $A = \mathbb{Z}_p$ be a cyclic group of prime order $p$ acting as an on-site symmetry on the Hilbert space of a quantum code. The symmetry action is described by:

\begin{enumerate}
    \item \textbf{Symmetry Group}: The symmetry group $A = \mathbb{Z}_p$ is the cyclic group of prime order $p$, modeled as an additive group. It satisfies:
    \begin{itemize}
        \item $A$ is cyclic: every element $g \in A$ can be written as $g = n \cdot 1$ for some $n \in \mathbb{N}$.
        \item $|A| = p$.
        \item Every element has additive order dividing $p$.
    \end{itemize}
    
    \item \textbf{Automorphism}: For each $g \in A$, there is an automorphism $\varphi_g$ of the operator algebra $R$ acting on the code's Hilbert space. A symmetry action is a map $\varphi: A \to \mathrm{Aut}(R)$ satisfying:
    \begin{itemize}
        \item $\varphi(g_1 + g_2) = \varphi(g_1) \circ \varphi(g_2)$ (homomorphism property)
        \item $\varphi(0) = \mathrm{id}$ (identity preservation)
    \end{itemize}
    
    \item \textbf{On-site symmetry operator}: $\mathsf{T}$ denotes the generator of the symmetry, an element of the operator algebra $R$ satisfying:
    \begin{itemize}
        \item $\mathsf{T}$ is invertible (a unit in $R$)
        \item $\mathsf{T}^p = \mathbf{1}$ (identity)
        \item The powers $\mathsf{T}^0, \mathsf{T}^1, \ldots, \mathsf{T}^{p-1}$ represent the action of each group element
    \end{itemize}
    For a subset $\Sigma(v)$ of qudits, $\mathsf{T}|_{\Sigma(v)}$ denotes the restriction of $\mathsf{T}$ to act only on qudits in $\Sigma(v)$, still satisfying $(\mathsf{T}|_{\Sigma(v)})^p = \mathbf{1}$.
    
    \item \textbf{Character group}: The character group $\hat{A} = \mathrm{Hom}(A, \mathbb{C}^*)$ consists of group homomorphisms from $A$ to the multiplicative group of nonzero complex numbers. For $A = \mathbb{Z}_p$:
    \begin{itemize}
        \item Characters are multiplicative: $\chi(g_1 + g_2) = \chi(g_1) \cdot \chi(g_2)$
        \item $\chi(0) = 1$ for all characters $\chi$
        \item $\chi(-g) = \chi(g)^{-1}$
        \item The standard characters are $\chi_k(g) = e^{2\pi i k g / p}$ for $k = 0, 1, \ldots, p-1$
        \item $|\hat{A}| = p$, so $\hat{A} \cong A$
        \item Character values are $p$-th roots of unity: $\chi(g)^p = 1$ for all $\chi \in \hat{A}$, $g \in A$
    \end{itemize}
    
    \item \textbf{Duality pairing}: For $g \in A$ and $\chi \in \hat{A}$, the duality pairing is $\langle g, \chi \rangle = \chi(g) \in \mathbb{C}^*$. This pairing satisfies:
    \begin{itemize}
        \item $\langle g_1 + g_2, \chi \rangle = \langle g_1, \chi \rangle \cdot \langle g_2, \chi \rangle$
        \item For standard characters: $\langle g, \chi_k \rangle = e^{2\pi i k g / p}$
    \end{itemize}
    
    \item \textbf{Symmetry eigenvalues}: Given an on-site symmetry $\mathsf{T}$ and a character $\chi_k$, if $\mathsf{T}$ acts as $e^{2\pi i g / p}$ on a state (corresponding to charge $g$), then $\chi_k$ gives eigenvalue $e^{2\pi i k g / p}$. The trivial character ($k = 0$) always gives eigenvalue $1$, and the identity element ($g = 0$) always has eigenvalue $1$ under any character.
\end{enumerate}
\end{remark}

\begin{proof}
\leanok
No proof needed for remarks.
\end{proof}

%--- Def_1: Charge Projection (Single Site) ---
\begin{definition}[Charge Projection (Single Site)]
\label{def:charge__projection_(_single__site)}
\lean{GaugingLDPC.chargeProjection}
\leanok
\uses{rem:symmetry__action_and__abelian__group__structure}

Let $A = \mathbb{Z}_p$ be an Abelian symmetry group acting via automorphisms $\varphi_g$ on the operator algebra $R$ of a local Hilbert space. Let $\hat{A}$ denote the character group of $A$. For any operator $O \in R$ and character $\chi \in \hat{A}$, the \textbf{charge-$\chi$ component} (or charge projection) of $O$ is defined as:
\[
\llbracket O \rrbracket_\chi := \frac{1}{|A|} \sum_{g \in A} \overline{\chi(g)} \varphi_g(O)
\]
where $|A| = p$ is the order of the group and $\overline{\chi(g)}$ denotes the complex conjugate of $\chi(g)$.

More precisely, given a symmetry action $\sigma : \mathbb{Z}_p \to \mathrm{Aut}(R)$ and a character $\chi \in \hat{\mathbb{Z}}_p$, the charge projection is:
\[
\llbracket O \rrbracket_\chi = \frac{1}{p} \sum_{g \in \mathbb{Z}_p} \overline{\chi(g)} \cdot \sigma_g(O)
\]
\end{definition}

\begin{definition}[Character Conjugate Value]
\label{def:char_conj_value}
\lean{GaugingLDPC.charConjValue}
\leanok
\uses{rem:symmetry__action_and__abelian__group__structure}

For a character $\chi \in \hat{\mathbb{Z}}_p$ and group element $g \in \mathbb{Z}_p$, the \textbf{complex conjugate of the character value} is defined as:
\[
\overline{\chi(g)} := \mathrm{conj}(\chi(g))
\]
For unitary characters (with values on the unit circle), we have $\overline{\chi(g)} = \chi(g)^{-1} = \chi(-g)$.
\end{definition}

\begin{lemma}[Conjugate of $\chi(0)$ is 1]
\label{lem:char_conj_value_zero}
\lean{GaugingLDPC.charConjValue_zero}
\leanok
\uses{def:char_conj_value}

For any character $\chi \in \hat{\mathbb{Z}}_p$, we have $\overline{\chi(0)} = 1$.
\end{lemma}

\begin{proof}
\leanok
\uses{def:char_conj_value}

By definition, $\overline{\chi(0)} = \mathrm{conj}(\chi(0))$. Since $\chi(0) = 1$ for any character (as $\chi$ is a homomorphism), we have $\mathrm{conj}(1) = 1$.
\end{proof}

\begin{lemma}[Conjugate Preserves Multiplication Structure]
\label{lem:char_conj_value_add}
\lean{GaugingLDPC.charConjValue_add}
\leanok
\uses{def:char_conj_value}

For any character $\chi \in \hat{\mathbb{Z}}_p$ and group elements $g_1, g_2 \in \mathbb{Z}_p$:
\[
\overline{\chi(g_1 + g_2)} = \overline{\chi(g_1)} \cdot \overline{\chi(g_2)}
\]
\end{lemma}

\begin{proof}
\leanok
\uses{def:char_conj_value, rem:symmetry__action_and__abelian__group__structure}

By the character multiplication property $\chi(g_1 + g_2) = \chi(g_1) \cdot \chi(g_2)$, and using that complex conjugation preserves multiplication, we have:
\[
\overline{\chi(g_1 + g_2)} = \overline{\chi(g_1) \cdot \chi(g_2)} = \overline{\chi(g_1)} \cdot \overline{\chi(g_2)}
\]
\end{proof}

\begin{lemma}[Conjugate Character Value Equals Negative Argument]
\label{lem:char_conj_value_eq_neg}
\lean{GaugingLDPC.charConjValue_eq_neg}
\leanok
\uses{def:char_conj_value, rem:symmetry__action_and__abelian__group__structure}

For any character $\chi \in \hat{\mathbb{Z}}_p$ and group element $g \in \mathbb{Z}_p$:
\[
\overline{\chi(g)} = \chi(-g)
\]
\end{lemma}

\begin{proof}
\leanok
\uses{def:char_conj_value, rem:symmetry__action_and__abelian__group__structure}

We first establish that $\chi(g) \cdot \chi(-g) = 1$. By the character multiplication property:
\[
\chi(g) \cdot \chi(-g) = \chi(g + (-g)) = \chi(0) = 1
\]
Thus $\chi(-g) = \chi(g)^{-1}$.

For character values (which are $p$-th roots of unity), we have $(\chi(g))^p = 1$. Since $p \neq 0$ (as $p$ is prime), this implies $\|\chi(g)\| = 1$, i.e., $\chi(g)$ lies on the unit circle.

For complex numbers on the unit circle, we have $z^{-1} = \overline{z}$. Therefore:
\[
\overline{\chi(g)} = \chi(g)^{-1} = \chi(-g)
\]
\end{proof}

\begin{lemma}[Standard Character Conjugate Formula]
\label{lem:char_conj_value_standard_char}
\lean{GaugingLDPC.charConjValue_standardChar}
\leanok
\uses{def:char_conj_value, rem:symmetry__action_and__abelian__group__structure}

For the standard character $\chi_k$ indexed by $k \in \mathbb{Z}_p$ and any $g \in \mathbb{Z}_p$:
\[
\overline{\chi_k(g)} = \chi_{-k}(g)
\]
\end{lemma}

\begin{proof}
\leanok
\uses{lem:char_conj_value_eq_neg, rem:symmetry__action_and__abelian__group__structure}

By Lemma~\ref{lem:char_conj_value_eq_neg}, $\overline{\chi_k(g)} = \chi_k(-g)$.

The standard character is defined as $\chi_k(g) = \exp(2\pi i \cdot k \cdot g / p)$. We need to show that $\chi_k(-g) = \chi_{-k}(g)$.

The key observation is that in $\mathbb{Z}_p$, we have $k \cdot (-g) = (-k) \cdot g$.

For the exponential function, we use the periodicity property: $\exp(2\pi i \cdot a / p)$ only depends on $a \mod p$. For any natural number $a$, we can write $a = p \cdot (a \div p) + (a \mod p)$, so:
\[
\exp(2\pi i \cdot a / p) = \exp(2\pi i \cdot (a \div p)) \cdot \exp(2\pi i \cdot (a \mod p) / p) = 1 \cdot \exp(2\pi i \cdot (a \mod p) / p)
\]

Since $(k \cdot (-g)).val \equiv ((-k) \cdot g).val \pmod{p}$, we conclude:
\[
\chi_k(-g) = \exp(2\pi i \cdot k \cdot (-g) / p) = \exp(2\pi i \cdot (-k) \cdot g / p) = \chi_{-k}(g)
\]
\end{proof}

\begin{definition}[Charge Projection by Index]
\label{def:charge_projection_by_index}
\lean{GaugingLDPC.chargeProjectionByIndex}
\leanok
\uses{def:charge__projection_(_single__site), rem:symmetry__action_and__abelian__group__structure}

The \textbf{charge-$k$ component} of an operator $O$ using the $k$-th standard character $\chi_k$ is:
\[
\llbracket O \rrbracket_k := \llbracket O \rrbracket_{\chi_k} = \frac{1}{p} \sum_{g=0}^{p-1} e^{-2\pi i k g / p} \varphi_g(O)
\]
This is simply the charge projection with respect to the standard character indexed by $k \in \mathbb{Z}_p$.
\end{definition}

\begin{lemma}[Charge Projection is Additive]
\label{lem:charge_projection_add}
\lean{GaugingLDPC.chargeProjection_add}
\leanok
\uses{def:charge__projection_(_single__site)}

For any character $\chi$ and operators $O_1, O_2 \in R$:
\[
\llbracket O_1 + O_2 \rrbracket_\chi = \llbracket O_1 \rrbracket_\chi + \llbracket O_2 \rrbracket_\chi
\]
\end{lemma}

\begin{proof}
\leanok
\uses{def:charge__projection_(_single__site)}

By unfolding the definition of charge projection:
\[
\llbracket O_1 + O_2 \rrbracket_\chi = \frac{1}{p} \sum_{g \in \mathbb{Z}_p} \overline{\chi(g)} \cdot \varphi_g(O_1 + O_2)
\]
Since each $\varphi_g$ is a ring automorphism, we have $\varphi_g(O_1 + O_2) = \varphi_g(O_1) + \varphi_g(O_2)$. Using linearity of scalar multiplication and distributivity of sums:
\[
= \frac{1}{p} \sum_{g \in \mathbb{Z}_p} \left(\overline{\chi(g)} \cdot \varphi_g(O_1) + \overline{\chi(g)} \cdot \varphi_g(O_2)\right) = \llbracket O_1 \rrbracket_\chi + \llbracket O_2 \rrbracket_\chi
\]
\end{proof}

\begin{lemma}[Charge Projection with Trivial Character]
\label{lem:charge_projection_trivial_char}
\lean{GaugingLDPC.chargeProjection_trivialChar}
\leanok
\uses{def:charge__projection_(_single__site), def:char_conj_value}

For the trivial character $\chi = 1$ and any operator $O \in R$:
\[
\llbracket O \rrbracket_1 = \frac{1}{p} \sum_{g \in \mathbb{Z}_p} \varphi_g(O)
\]
That is, the charge projection with the trivial character gives the $G$-average of $O$.
\end{lemma}

\begin{proof}
\leanok
\uses{def:charge__projection_(_single__site), def:char_conj_value}

By definition of charge projection:
\[
\llbracket O \rrbracket_1 = \frac{1}{p} \sum_{g \in \mathbb{Z}_p} \overline{1(g)} \cdot \varphi_g(O)
\]
Since the trivial character satisfies $1(g) = 1$ for all $g$, we have $\overline{1(g)} = 1$, so:
\[
\llbracket O \rrbracket_1 = \frac{1}{p} \sum_{g \in \mathbb{Z}_p} 1 \cdot \varphi_g(O) = \frac{1}{p} \sum_{g \in \mathbb{Z}_p} \varphi_g(O)
\]
\end{proof}

\begin{lemma}[Charge Projection by Index Zero]
\label{lem:charge_projection_by_index_zero}
\lean{GaugingLDPC.chargeProjectionByIndex_zero}
\leanok
\uses{def:charge_projection_by_index, lem:charge_projection_trivial_char}

For any operator $O \in R$:
\[
\llbracket O \rrbracket_0 = \frac{1}{p} \sum_{g \in \mathbb{Z}_p} \varphi_g(O)
\]
\end{lemma}

\begin{proof}
\leanok
\uses{def:charge_projection_by_index, lem:charge_projection_trivial_char, rem:symmetry__action_and__abelian__group__structure}

The standard character $\chi_0$ at index $0$ is the trivial character, since $\chi_0(g) = e^{2\pi i \cdot 0 \cdot g / p} = 1$ for all $g$. By extensionality, $\chi_0 = 1$. The result then follows from Lemma~\ref{lem:charge_projection_trivial_char}.
\end{proof}

\begin{lemma}[Charge Projection of Zero]
\label{lem:charge_projection_zero}
\lean{GaugingLDPC.chargeProjection_zero}
\leanok
\uses{def:charge__projection_(_single__site)}

For any character $\chi$:
\[
\llbracket 0 \rrbracket_\chi = 0
\]
\end{lemma}

\begin{proof}
\leanok
\uses{def:charge__projection_(_single__site)}

By definition of charge projection:
\[
\llbracket 0 \rrbracket_\chi = \frac{1}{p} \sum_{g \in \mathbb{Z}_p} \overline{\chi(g)} \cdot \varphi_g(0)
\]
Since $\varphi_g$ is a ring homomorphism, $\varphi_g(0) = 0$ for all $g$. Therefore each term in the sum is $\overline{\chi(g)} \cdot 0 = 0$, and the entire sum is zero.
\end{proof}

\begin{lemma}[Charge Projection of One]
\label{lem:charge_projection_one}
\lean{GaugingLDPC.chargeProjection_one}
\leanok
\uses{def:charge__projection_(_single__site), def:char_conj_value}

For any character $\chi$:
\[
\llbracket 1 \rrbracket_\chi = \frac{1}{p} \sum_{g \in \mathbb{Z}_p} \overline{\chi(g)} \cdot 1
\]
\end{lemma}

\begin{proof}
\leanok
\uses{def:charge__projection_(_single__site)}

By definition of charge projection:
\[
\llbracket 1 \rrbracket_\chi = \frac{1}{p} \sum_{g \in \mathbb{Z}_p} \overline{\chi(g)} \cdot \varphi_g(1)
\]
Since $\varphi_g$ is a ring automorphism, $\varphi_g(1) = 1$ for all $g$. The result follows.
\end{proof}

\begin{theorem}[Character Sum Formula]
\label{thm:character_sum_eq}
\lean{GaugingLDPC.character_sum_eq}
\leanok
\uses{rem:symmetry__action_and__abelian__group__structure}

For any character $\chi \in \hat{\mathbb{Z}}_p$:
\[
\sum_{g \in \mathbb{Z}_p} \chi(g) = \begin{cases} p & \text{if } \chi = 1 \\ 0 & \text{if } \chi \neq 1 \end{cases}
\]
\end{theorem}

\begin{proof}
\leanok
\uses{rem:symmetry__action_and__abelian__group__structure}

\textbf{Case 1:} If $\chi = 1$ (the trivial character), then $\chi(g) = 1$ for all $g \in \mathbb{Z}_p$. Thus:
\[
\sum_{g \in \mathbb{Z}_p} \chi(g) = \sum_{g \in \mathbb{Z}_p} 1 = |\mathbb{Z}_p| = p
\]

\textbf{Case 2:} If $\chi \neq 1$, then there exists $g_0 \in \mathbb{Z}_p$ such that $\chi(g_0) \neq 1$. Let $S = \sum_{g \in \mathbb{Z}_p} \chi(g)$.

By the bijection $g \mapsto g + g_0$ on $\mathbb{Z}_p$:
\[
\sum_{g \in \mathbb{Z}_p} \chi(g + g_0) = \sum_{g \in \mathbb{Z}_p} \chi(g) = S
\]

On the other hand, using the character multiplication property:
\[
\sum_{g \in \mathbb{Z}_p} \chi(g + g_0) = \sum_{g \in \mathbb{Z}_p} \chi(g) \cdot \chi(g_0) = \chi(g_0) \cdot S
\]

Therefore $S = \chi(g_0) \cdot S$, which implies $(1 - \chi(g_0)) \cdot S = 0$.

Since $\chi(g_0) \neq 1$, we have $1 - \chi(g_0) \neq 0$, and thus $S = 0$.
\end{proof}

\begin{corollary}[Conjugate Character Sum Formula]
\label{cor:character_conj_sum_eq}
\lean{GaugingLDPC.character_conj_sum_eq}
\leanok
\uses{def:char_conj_value, thm:character_sum_eq, lem:char_conj_value_eq_neg}

For any character $\chi \in \hat{\mathbb{Z}}_p$:
\[
\sum_{g \in \mathbb{Z}_p} \overline{\chi(g)} = \begin{cases} p & \text{if } \chi = 1 \\ 0 & \text{if } \chi \neq 1 \end{cases}
\]
\end{corollary}

\begin{proof}
\leanok
\uses{lem:char_conj_value_eq_neg, thm:character_sum_eq}

By Lemma~\ref{lem:char_conj_value_eq_neg}, we have $\overline{\chi(g)} = \chi(-g)$ for all $g$. Therefore:
\[
\sum_{g \in \mathbb{Z}_p} \overline{\chi(g)} = \sum_{g \in \mathbb{Z}_p} \chi(-g)
\]

By the bijection $g \mapsto -g$ on $\mathbb{Z}_p$:
\[
\sum_{g \in \mathbb{Z}_p} \chi(-g) = \sum_{g \in \mathbb{Z}_p} \chi(g)
\]

The result now follows from Theorem~\ref{thm:character_sum_eq}.
\end{proof}

%--- Def_2: Charge Projection (Multi Site Distribution) ---
\begin{definition}[Multi-Site Charge Projection]
\label{def:charge__projection_(_multi__site__distribution)}
\lean{GaugingLDPC.multiSiteChargeProjection}
\leanok
\uses{def:charge__projection_(_single__site)}

Let $A = \mathbb{Z}_p$ be an Abelian symmetry group and let $C_0$ denote the set of vertices (sites) of the gauging graph $\mathcal{G}$. For a \emph{charge distribution} $\boldsymbol{\chi} \in \hat{A}^{C_0}$ (assigning a character to each vertex) and an operator $O$, the \emph{multi-site charge projection} is defined as:
\[
\llbracket O \rrbracket_{\boldsymbol{\chi}} := \frac{1}{|A|^{|C_0|}} \sum_{\mathbf{g} \in A^{C_0}} \overline{\boldsymbol{\chi}(\mathbf{g})} \varphi_{\mathbf{g}}(O)
\]
where:
\begin{itemize}
\item $\mathbf{g} = (g_v)_{v \in C_0} \in A^{C_0}$ is a tuple of group elements, one for each vertex
\item $\varphi_{\mathbf{g}} = \prod_{v \in C_0} \varphi_{g_v}^{(v)}$ is the product of local symmetry actions
\item $\boldsymbol{\chi}(\mathbf{g}) = \prod_{v \in C_0} \chi_v(g_v)$ where $\chi_v$ is the character assigned to vertex $v$
\end{itemize}
\end{definition}

\begin{definition}[Charge Distribution]
\label{def:charge_distribution}
\lean{GaugingLDPC.ChargeDistribution}
\leanok

A \emph{charge distribution} assigns a character $\chi_v \in \hat{A}$ to each vertex $v \in C_0$. This is an element of $\hat{A}^{C_0}$, the product of character groups.
\end{definition}

\begin{definition}[Trivial Charge Distribution]
\label{def:trivial_charge_distribution}
\lean{GaugingLDPC.ChargeDistribution.trivial}
\leanok
\uses{def:charge_distribution}

The \emph{trivial charge distribution} assigns the trivial character to every vertex.
\end{definition}

\begin{definition}[Standard Charge Distribution by Index]
\label{def:standard_charge_distribution_by_index}
\lean{GaugingLDPC.ChargeDistribution.standardByIndex}
\leanok
\uses{def:charge_distribution}

The \emph{standard charge distribution by index} is defined for an index function $k : C_0 \to \mathbb{Z}_p$, assigning the $k_v$-th standard character $\chi_{k_v}$ to each vertex $v$.
\end{definition}

\begin{definition}[Group Tuple]
\label{def:group_tuple}
\lean{GaugingLDPC.GroupTuple}
\leanok

A \emph{group tuple} is an element $\mathbf{g} = (g_v)_{v \in C_0} \in A^{C_0}$, consisting of one group element for each vertex.
\end{definition}

\begin{definition}[Multi-Site Symmetry Action]
\label{def:multi_site_symmetry_action}
\lean{GaugingLDPC.MultiSiteSymmetryAction}
\leanok
\uses{def:charge__projection_(_single__site)}

A \emph{multi-site symmetry action} provides a local symmetry action $\varphi^{(v)}$ for each vertex $v$, such that the local actions commute pairwise: for all $v_1, v_2 \in C_0$ and all $g_1, g_2 \in A$,
\[
\varphi_{g_1}^{(v_1)} \circ \varphi_{g_2}^{(v_2)} = \varphi_{g_2}^{(v_2)} \circ \varphi_{g_1}^{(v_1)}.
\]
The product action is $\varphi_{\mathbf{g}} = \prod_{v \in C_0} \varphi_{g_v}^{(v)}$.
\end{definition}

\begin{definition}[Multi-Site Character Value]
\label{def:multi_site_character_value}
\lean{GaugingLDPC.multiSiteCharacterValue}
\leanok
\uses{def:charge_distribution, def:group_tuple}

The \emph{multi-site character value} $\boldsymbol{\chi}(\mathbf{g})$ evaluates the charge distribution on a tuple of group elements:
\[
\boldsymbol{\chi}(\mathbf{g}) = \prod_{v \in C_0} \chi_v(g_v).
\]
\end{definition}

\begin{definition}[Multi-Site Conjugate Character Value]
\label{def:multi_site_char_conj_value}
\lean{GaugingLDPC.multiSiteCharConjValue}
\leanok
\uses{def:multi_site_character_value, def:charge__projection_(_single__site)}

The \emph{conjugate of the multi-site character value} is
\[
\overline{\boldsymbol{\chi}(\mathbf{g})} = \prod_{v \in C_0} \overline{\chi_v(g_v)}.
\]
\end{definition}

\begin{definition}[Multi-Site Charge Projection by Index]
\label{def:multi_site_charge_projection_by_index}
\lean{GaugingLDPC.multiSiteChargeProjectionByIndex}
\leanok
\uses{def:charge__projection_(_multi__site__distribution), def:standard_charge_distribution_by_index}

The \emph{multi-site charge-$\mathbf{k}$ component} using index assignments $k : C_0 \to \mathbb{Z}_p$ is defined using the explicit formula with standard characters:
\[
\llbracket O \rrbracket_{\mathbf{k}} = \frac{1}{p^{|C_0|}} \sum_{\mathbf{g} \in \mathbb{Z}_p^{C_0}} \exp\left(-\frac{2\pi i}{p} \sum_{v \in C_0} k_v g_v\right) \varphi_{\mathbf{g}}(O).
\]
\end{definition}

\begin{lemma}[Multi-Site Charge Projection of Zero]
\label{lem:multi_site_charge_projection_zero}
\lean{GaugingLDPC.multiSiteChargeProjection_zero}
\leanok
\uses{def:charge__projection_(_multi__site__distribution)}

For any charge distribution $\boldsymbol{\chi}$ and nonempty $C_0$, the multi-site charge projection of the zero operator is zero:
\[
\llbracket 0 \rrbracket_{\boldsymbol{\chi}} = 0.
\]
\end{lemma}

\begin{proof}
\leanok
\uses{def:charge__projection_(_multi__site__distribution)}

Expanding the definition of multi-site charge projection, we have
\[
\llbracket 0 \rrbracket_{\boldsymbol{\chi}} = \frac{1}{|A|^{|C_0|}} \sum_{\mathbf{g} \in A^{C_0}} \overline{\boldsymbol{\chi}(\mathbf{g})} \varphi_{\mathbf{g}}(0).
\]
Since the product action $\varphi_{\mathbf{g}}$ is a ring automorphism, we have $\varphi_{\mathbf{g}}(0) = 0$ for all $\mathbf{g}$. Therefore the sum consists entirely of zero terms, giving $\llbracket 0 \rrbracket_{\boldsymbol{\chi}} = 0$.
\end{proof}

\begin{lemma}[Multi-Site Charge Projection with Trivial Distribution]
\label{lem:multi_site_charge_projection_trivial_dist}
\lean{GaugingLDPC.multiSiteChargeProjection_trivialDist}
\leanok
\uses{def:charge__projection_(_multi__site__distribution), def:trivial_charge_distribution}

The multi-site charge projection with the trivial distribution gives the $A^{C_0}$-average:
\[
\llbracket O \rrbracket_{\mathbf{1}} = \frac{1}{p^{|C_0|}} \sum_{\mathbf{g} \in A^{C_0}} \varphi_{\mathbf{g}}(O).
\]
\end{lemma}

\begin{proof}
\leanok
\uses{def:charge__projection_(_multi__site__distribution), def:trivial_charge_distribution}

Expanding the definition, we have
\[
\llbracket O \rrbracket_{\mathbf{1}} = \frac{1}{p^{|C_0|}} \sum_{\mathbf{g} \in A^{C_0}} \overline{\mathbf{1}(\mathbf{g})} \varphi_{\mathbf{g}}(O).
\]
For the trivial distribution, $\overline{\mathbf{1}(\mathbf{g})} = 1$ for all $\mathbf{g}$. Applying this to each term in the sum, we obtain the result.
\end{proof}

\begin{lemma}[Group Tuple Cardinality]
\label{lem:group_tuple_card}
\lean{GaugingLDPC.groupTuple_card}
\leanok
\uses{def:group_tuple}

The cardinality of the group tuple space is $|A^{C_0}| = |A|^{|C_0|} = p^{|C_0|}$.
\end{lemma}

\begin{proof}
\leanok
\uses{def:group_tuple}

This follows by the definition of the group tuple as a product type and the standard cardinality formula for function spaces: $|A^{C_0}| = |A|^{|C_0|}$. Since $A = \mathbb{Z}_p$, we have $|A| = p$.
\end{proof}

\begin{lemma}[Conjugate Multi-Site Character Value as Exponential Sum]
\label{lem:multi_site_char_conj_value_exp_sum}
\lean{GaugingLDPC.multiSiteCharConjValue_standardByIndex_exp_sum}
\leanok
\uses{def:multi_site_char_conj_value, def:standard_charge_distribution_by_index}

For standard characters, the conjugate multi-site character value can be written as:
\[
\overline{\boldsymbol{\chi}(\mathbf{g})} = \exp\left(-\frac{2\pi i}{p} \sum_{v \in C_0} k_v g_v\right).
\]
\end{lemma}

\begin{proof}
\leanok
\uses{def:multi_site_char_conj_value, def:standard_charge_distribution_by_index}

Starting from the definition, the conjugate multi-site character value for standard characters is
\[
\overline{\boldsymbol{\chi}(\mathbf{g})} = \prod_{v \in C_0} \exp\left(\frac{2\pi i}{p} (-k_v) g_v\right).
\]
For each factor, when $k_v \neq 0$, we use the fact that $(-k_v) \equiv p - k_v \pmod{p}$, so
\[
\exp\left(\frac{2\pi i}{p} (p - k_v) g_v\right) = \exp(2\pi i g_v) \cdot \exp\left(-\frac{2\pi i}{p} k_v g_v\right).
\]
Since $g_v$ is a natural number, $\exp(2\pi i g_v) = 1$. Therefore each factor equals $\exp\left(-\frac{2\pi i}{p} k_v g_v\right)$.

Using the identity $\prod_v \exp(a_v) = \exp(\sum_v a_v)$, we obtain
\[
\overline{\boldsymbol{\chi}(\mathbf{g})} = \exp\left(-\frac{2\pi i}{p} \sum_{v \in C_0} k_v g_v\right).
\]
\end{proof}

\begin{theorem}[Multi-Site Projection Reduces to Single-Site]
\label{thm:multi_site_charge_projection_singleton}
\lean{GaugingLDPC.multiSiteChargeProjection_singleton}
\leanok
\uses{def:charge__projection_(_multi__site__distribution), def:charge__projection_(_single__site)}

When $C_0$ has a single element, the multi-site projection reduces to single-site projection:
\[
\llbracket O \rrbracket_{\boldsymbol{\chi}} = \llbracket O \rrbracket_{\chi},
\]
where $\chi$ is the character assigned to the unique vertex.
\end{theorem}

\begin{proof}
\leanok
\uses{def:charge__projection_(_multi__site__distribution), def:charge__projection_(_single__site)}

In the singleton case, $|C_0| = 1$, so $p^{|C_0|} = p$. The sum over $A^{C_0}$ is equivalent to a sum over $A$, since $A^{\{*\}} \cong A$. For the conjugate character value, we have
\[
\overline{\boldsymbol{\chi}(\mathbf{g})} = \prod_{v \in C_0} \overline{\chi_v(g_v)} = \overline{\chi(g)}
\]
by the product over a singleton. Similarly, the product action reduces to
\[
\varphi_{\mathbf{g}}(O) = \prod_{v \in C_0} \varphi_{g_v}^{(v)}(O) = \varphi_g(O).
\]
Reindexing the sum using the equivalence $A^{C_0} \cong A$, we obtain exactly the single-site charge projection formula.
\end{proof}

%--- Lem_1: Covariance Property of Charge Components ---
\begin{definition}[Scalar-Fixing Property for Multi-Site Symmetry Actions]
\label{def:multi_site_symmetry_action_fixes_scalars}
\lean{GaugingLDPC.MultiSiteSymmetryAction.FixesScalars}
\leanok
\uses{def:charge__projection_(_multi__site__distribution)}

A multi-site symmetry action $\sigma$ \emph{fixes scalars} if every automorphism in the composed automorphism preserves elements of $\operatorname{algebraMap} \mathbb{C} R$. Formally, for all $g \in A^{C_0}$ and all $c \in \mathbb{C}$,
\[
\sigma_g(\operatorname{algebraMap}_{\mathbb{C},R}(c)) = \operatorname{algebraMap}_{\mathbb{C},R}(c).
\]
This is a physically natural assumption: the symmetry acts on quantum degrees of freedom, not on classical coefficients.
\end{definition}

\begin{lemma}[Local Product Commutativity]
\label{lem:local_product_commute}
\lean{GaugingLDPC.local_product_commute}
\leanok
\uses{def:charge__projection_(_multi__site__distribution)}

For a multi-site symmetry action $\sigma$, group tuples $g, h \in A^{C_0}$, and distinct vertices $v_1 \neq v_2$, the products of local automorphisms commute:
\[
\phi_{v_1}(g_{v_1}) \cdot \phi_{v_1}(h_{v_1}) \cdot \phi_{v_2}(g_{v_2}) \cdot \phi_{v_2}(h_{v_2}) = \phi_{v_2}(g_{v_2}) \cdot \phi_{v_2}(h_{v_2}) \cdot \phi_{v_1}(g_{v_1}) \cdot \phi_{v_1}(h_{v_1}).
\]
\end{lemma}

\begin{proof}
\leanok
\uses{def:charge__projection_(_multi__site__distribution)}

We use the commutativity relations from $\sigma$. Let $c_1, c_2, c_3, c_4$ denote the commutativity conditions: $c_1$ states $\phi_{v_1}(g_{v_1}) \cdot \phi_{v_2}(g_{v_2}) = \phi_{v_2}(g_{v_2}) \cdot \phi_{v_1}(g_{v_1})$, and similarly for the other combinations. We establish the following intermediate steps:
\begin{enumerate}
\item $\phi_{v_1}(h_{v_1}) \cdot \phi_{v_2}(g_{v_2}) = \phi_{v_2}(g_{v_2}) \cdot \phi_{v_1}(h_{v_1})$ (from $c_4$),
\item $\phi_{v_1}(g_{v_1}) \cdot \phi_{v_2}(g_{v_2}) = \phi_{v_2}(g_{v_2}) \cdot \phi_{v_1}(g_{v_1})$ (from $c_1$),
\item $\phi_{v_1}(g_{v_1}) \cdot \phi_{v_2}(h_{v_2}) = \phi_{v_2}(h_{v_2}) \cdot \phi_{v_1}(g_{v_1})$ (from $c_3$),
\item $\phi_{v_1}(h_{v_1}) \cdot \phi_{v_2}(h_{v_2}) = \phi_{v_2}(h_{v_2}) \cdot \phi_{v_1}(h_{v_1})$ (from $c_2$).
\end{enumerate}

The proof proceeds by a calculation using associativity of multiplication and these commutativity relations:
\begin{align*}
&\phi_{v_1}(g_{v_1}) \cdot \phi_{v_1}(h_{v_1}) \cdot \phi_{v_2}(g_{v_2}) \cdot \phi_{v_2}(h_{v_2}) \\
&= \phi_{v_1}(g_{v_1}) \cdot (\phi_{v_1}(h_{v_1}) \cdot \phi_{v_2}(g_{v_2})) \cdot \phi_{v_2}(h_{v_2}) \\
&= \phi_{v_1}(g_{v_1}) \cdot (\phi_{v_2}(g_{v_2}) \cdot \phi_{v_1}(h_{v_1})) \cdot \phi_{v_2}(h_{v_2}) \quad \text{(by step 1)} \\
&= (\phi_{v_1}(g_{v_1}) \cdot \phi_{v_2}(g_{v_2})) \cdot \phi_{v_1}(h_{v_1}) \cdot \phi_{v_2}(h_{v_2}) \\
&= (\phi_{v_2}(g_{v_2}) \cdot \phi_{v_1}(g_{v_1})) \cdot \phi_{v_1}(h_{v_1}) \cdot \phi_{v_2}(h_{v_2}) \quad \text{(by step 2)} \\
&= \phi_{v_2}(g_{v_2}) \cdot (\phi_{v_1}(g_{v_1}) \cdot \phi_{v_1}(h_{v_1})) \cdot \phi_{v_2}(h_{v_2}) \\
&= \phi_{v_2}(g_{v_2}) \cdot \phi_{v_1}(g_{v_1}) \cdot (\phi_{v_1}(h_{v_1}) \cdot \phi_{v_2}(h_{v_2})) \\
&= \phi_{v_2}(g_{v_2}) \cdot \phi_{v_1}(g_{v_1}) \cdot (\phi_{v_2}(h_{v_2}) \cdot \phi_{v_1}(h_{v_1})) \quad \text{(by step 4)} \\
&= \phi_{v_2}(g_{v_2}) \cdot (\phi_{v_1}(g_{v_1}) \cdot \phi_{v_2}(h_{v_2})) \cdot \phi_{v_1}(h_{v_1}) \\
&= \phi_{v_2}(g_{v_2}) \cdot (\phi_{v_2}(h_{v_2}) \cdot \phi_{v_1}(g_{v_1})) \cdot \phi_{v_1}(h_{v_1}) \quad \text{(by step 3)} \\
&= \phi_{v_2}(g_{v_2}) \cdot \phi_{v_2}(h_{v_2}) \cdot \phi_{v_1}(g_{v_1}) \cdot \phi_{v_1}(h_{v_1}).
\end{align*}
\end{proof}

\begin{lemma}[Product Action Compatibility with Addition]
\label{lem:product_action_add}
\lean{GaugingLDPC.MultiSiteSymmetryAction.productAction_add}
\leanok
\uses{def:charge__projection_(_multi__site__distribution), lem:local_product_commute}

The product action is compatible with group addition: for group tuples $g, h \in A^{C_0}$ and operator $O \in R$,
\[
\varphi_{g+h}(O) = \varphi_g(\varphi_h(O)).
\]
This follows from the fact that each local action is a group homomorphism.
\end{lemma}

\begin{proof}
\leanok
\uses{lem:local_product_commute, def:charge__projection_(_multi__site__distribution)}

By definition of the product action and composed automorphism, we expand both sides. First, we use that $\phi_v(g_v + h_v) = \phi_v(g_v) \cdot \phi_v(h_v)$ from the homomorphism property of the local action at each vertex $v$.

We then establish that the noncommutative product over vertices of $\phi_v(g_v + h_v)$ equals the noncommutative product of $\phi_v(g_v) \cdot \phi_v(h_v)$ using the congruence property.

Define $f(v) = \phi_v(g_v)$ and $fg(v) = \phi_v(h_v)$. We verify the pairwise commutativity conditions:
\begin{itemize}
\item $f$ has pairwise commuting values by the automorphisms commute property,
\item $fg$ has pairwise commuting values by the same property,
\item $fg(v_1)$ commutes with $f(v_2)$ for distinct $v_1, v_2$ by the actions commute property.
\end{itemize}

Using the noncommutative product distribution lemma, we obtain:
\[
\prod_v^{\text{nc}} (\phi_v(g_v) \cdot \phi_v(h_v)) = \left(\prod_v^{\text{nc}} \phi_v(g_v)\right) \cdot \left(\prod_v^{\text{nc}} \phi_v(h_v)\right).
\]
The result follows by applying this to $O$.
\end{proof}

\begin{lemma}[Product Action Preserves Addition]
\label{lem:product_action_add_op}
\lean{GaugingLDPC.MultiSiteSymmetryAction.productAction_add_op}
\leanok
\uses{def:charge__projection_(_multi__site__distribution)}

The product action preserves addition of operators: for $g \in A^{C_0}$ and $O_1, O_2 \in R$,
\[
\varphi_g(O_1 + O_2) = \varphi_g(O_1) + \varphi_g(O_2).
\]
\end{lemma}

\begin{proof}
\leanok
\uses{def:charge__projection_(_multi__site__distribution)}

By definition of the product action and the fact that ring automorphisms preserve addition, this follows directly from $\operatorname{map\_add}$.
\end{proof}

\begin{lemma}[Character Value at Negation]
\label{lem:multi_site_character_value_neg}
\lean{GaugingLDPC.multiSiteCharacterValue_neg}
\leanok
\uses{def:charge__projection_(_multi__site__distribution)}

For a charge distribution $\chi$ and group tuple $g \in A^{C_0}$, the multi-site character value at the negation satisfies:
\[
\boldsymbol{\chi}(-g) = \boldsymbol{\chi}(g)^{-1}.
\]
\end{lemma}

\begin{proof}
\leanok
\uses{def:charge__projection_(_multi__site__distribution)}

By definition of the multi-site character value as a product over vertices, we have:
\[
\boldsymbol{\chi}(-g) = \prod_{v \in C_0} \chi_v(-g_v).
\]
Rewriting using the inverse distribution over products, this equals $\prod_{v \in C_0} \chi_v(g_v)^{-1}$. The result follows from the character group property that $\chi_v(-g_v) = \chi_v(g_v)^{-1}$ for each vertex.
\end{proof}

\begin{lemma}[Conjugate Character Value at Difference]
\label{lem:multi_site_char_conj_value_sub}
\lean{GaugingLDPC.multiSiteCharConjValue_sub}
\leanok
\uses{def:charge__projection_(_multi__site__distribution), lem:multi_site_character_value_neg}

For a charge distribution $\chi$ and group tuples $k, g \in A^{C_0}$, the conjugate character value at $k - g$ satisfies:
\[
\overline{\boldsymbol{\chi}}(k - g) = \overline{\boldsymbol{\chi}}(k) \cdot \boldsymbol{\chi}(g).
\]
\end{lemma}

\begin{proof}
\leanok
\uses{def:charge__projection_(_multi__site__distribution)}

We first note that $k - g = k + (-g)$, so by the multiplicative property of the conjugate character value:
\[
\overline{\boldsymbol{\chi}}(k - g) = \overline{\boldsymbol{\chi}}(k) \cdot \overline{\boldsymbol{\chi}}(-g).
\]

We now show that $\overline{\boldsymbol{\chi}}(-g) = \boldsymbol{\chi}(g)$. By definition, the conjugate character value is:
\[
\overline{\boldsymbol{\chi}}(-g) = \prod_{v \in C_0} \overline{\chi_v(-g_v)}.
\]

For each vertex $v$, we use the character group property $\chi_v(-g_v) = \chi_v(g_v)^{-1}$, so:
\[
\overline{\chi_v(-g_v)} = \overline{\chi_v(g_v)^{-1}} = \overline{\chi_v(g_v)}^{-1}.
\]

Since $\chi_v(g_v)$ is a $p$-th root of unity (as $\chi_v(g_v)^p = 1$), we have $\|\chi_v(g_v)\| = 1$. For complex numbers of unit norm, $\overline{z}^{-1} = z$. Therefore:
\[
\overline{\chi_v(g_v)}^{-1} = \chi_v(g_v).
\]

Taking the product over all vertices yields $\overline{\boldsymbol{\chi}}(-g) = \boldsymbol{\chi}(g)$, completing the proof.
\end{proof}

\begin{lemma}[Covariance Property of Charge Components]
\label{lem:covariance__property_of__charge__components}
\lean{GaugingLDPC.multiSiteChargeProjection_covariance}
\leanok
\uses{def:charge__projection_(_multi__site__distribution), lem:product_action_add, lem:multi_site_char_conj_value_sub}

Let $O$ be an operator and $[\![O]\!]_{\boldsymbol{\chi}}$ be its charge-$\boldsymbol{\chi}$ component. Assume the symmetry action $\sigma$ fixes scalars. Then the charge component satisfies the \textbf{covariance property} under the symmetry action:
\[
\varphi_{\mathbf{g}}([\![O]\!]_{\boldsymbol{\chi}}) = \boldsymbol{\chi}(\mathbf{g}) \cdot [\![O]\!]_{\boldsymbol{\chi}}
\]
for all $\mathbf{g} \in A^{C_0}$.

In other words, $[\![O]\!]_{\boldsymbol{\chi}}$ is an \textbf{eigen-operator} of the symmetry action with eigenvalue $\boldsymbol{\chi}(\mathbf{g})$.
\end{lemma}

\begin{proof}
\leanok
\uses{def:charge__projection_(_multi__site__distribution), lem:product_action_add, lem:multi_site_char_conj_value_sub}

We expand the charge projection definition and proceed in several steps.

\textbf{Step 1:} Distribute the automorphism over scalar multiplication and sum. Using linearity:
\[
\varphi_g([\![O]\!]_{\boldsymbol{\chi}}) = \varphi_g\left(\frac{1}{p^{|C_0|}} \sum_{h \in A^{C_0}} \overline{\boldsymbol{\chi}}(h) \cdot \varphi_h(O)\right).
\]
By the ring automorphism properties, this distributes to:
\[
= \frac{1}{p^{|C_0|}} \sum_{h \in A^{C_0}} \varphi_g(\overline{\boldsymbol{\chi}}(h)) \cdot \varphi_g(\varphi_h(O)).
\]

\textbf{Step 2:} Use the group property $\varphi_g \circ \varphi_h = \varphi_{g+h}$. By the product action compatibility lemma, $\varphi_g(\varphi_h(O)) = \varphi_{g+h}(O)$.

\textbf{Step 3:} Change of variables. Let $k = g + h$, so $h = k - g$. The sum over $h$ becomes a sum over $k$:
\[
= \frac{1}{p^{|C_0|}} \sum_{k \in A^{C_0}} \varphi_g(\overline{\boldsymbol{\chi}}(k - g)) \cdot \varphi_k(O).
\]

\textbf{Step 4:} Use character multiplicativity. By the conjugate character subtraction lemma:
\[
\overline{\boldsymbol{\chi}}(k - g) = \overline{\boldsymbol{\chi}}(k) \cdot \boldsymbol{\chi}(g).
\]

\textbf{Step 5:} Factor out $\boldsymbol{\chi}(g)$ using the scalar-fixing property. Since $\sigma$ fixes scalars:
\[
\varphi_g(\overline{\boldsymbol{\chi}}(k) \cdot \boldsymbol{\chi}(g)) = \overline{\boldsymbol{\chi}}(k) \cdot \boldsymbol{\chi}(g).
\]

\textbf{Step 6:} Rearrange and factor. We obtain:
\[
= \frac{1}{p^{|C_0|}} \sum_{k \in A^{C_0}} \overline{\boldsymbol{\chi}}(k) \cdot \boldsymbol{\chi}(g) \cdot \varphi_k(O).
\]

Since $\boldsymbol{\chi}(g)$ is independent of the summation index $k$, we factor it out:
\[
= \boldsymbol{\chi}(g) \cdot \frac{1}{p^{|C_0|}} \sum_{k \in A^{C_0}} \overline{\boldsymbol{\chi}}(k) \cdot \varphi_k(O) = \boldsymbol{\chi}(g) \cdot [\![O]\!]_{\boldsymbol{\chi}}.
\]

The final equality uses the scalar-fixing property for the $(p^{|C_0|})^{-1}$ factor and ring commutativity.
\end{proof}

\begin{lemma}[Charge Projection as Eigen-Operator]
\label{lem:charge_projection_eigenoperator}
\lean{GaugingLDPC.multiSiteChargeProjection_eigenoperator}
\leanok
\uses{def:charge__projection_(_multi__site__distribution), lem:covariance__property_of__charge__components}

For a multi-site symmetry action $\sigma$ that fixes scalars, a charge distribution $\chi$, and an operator $O$, the charge-$\chi$ component is an eigen-operator: for all $g \in A^{C_0}$,
\[
\varphi_g([\![O]\!]_{\boldsymbol{\chi}}) = \boldsymbol{\chi}(g) \cdot [\![O]\!]_{\boldsymbol{\chi}}.
\]
\end{lemma}

\begin{proof}
\leanok
\uses{lem:covariance__property_of__charge__components}

This follows immediately from the covariance property lemma applied to each $g$.
\end{proof}

\begin{lemma}[Covariance for Index-Based Projection]
\label{lem:charge_projection_by_index_covariance}
\lean{GaugingLDPC.multiSiteChargeProjectionByIndex_covariance}
\leanok
\uses{def:charge__projection_(_multi__site__distribution), lem:covariance__property_of__charge__components}

For a multi-site symmetry action $\sigma$ that fixes scalars, a charge index $k : C_0 \to \mathbb{Z}/p\mathbb{Z}$, and an operator $O$, the index-based charge projection satisfies the covariance property:
\[
\varphi_g([\![O]\!]_k) = \boldsymbol{\chi}_k(g) \cdot [\![O]\!]_k
\]
where $\boldsymbol{\chi}_k$ is the standard charge distribution associated with index $k$.
\end{lemma}

\begin{proof}
\leanok
\uses{def:charge__projection_(_multi__site__distribution), lem:covariance__property_of__charge__components}

By definition, the index-based projection equals the charge projection with the standard distribution by index. The result follows by applying the main covariance theorem.
\end{proof}

\begin{lemma}[Trivial Distribution Gives Invariant Projection]
\label{lem:charge_projection_invariant_trivial}
\lean{GaugingLDPC.multiSiteChargeProjection_invariant_trivialDist}
\leanok
\uses{def:charge__projection_(_multi__site__distribution), lem:covariance__property_of__charge__components}

For a multi-site symmetry action $\sigma$ that fixes scalars and the trivial charge distribution, the charge projection is invariant under symmetry:
\[
\varphi_g([\![O]\!]_{\mathbf{1}}) = [\![O]\!]_{\mathbf{1}}
\]
for all $g \in A^{C_0}$.
\end{lemma}

\begin{proof}
\leanok
\uses{lem:covariance__property_of__charge__components}

By the covariance theorem, $\varphi_g([\![O]\!]_{\mathbf{1}}) = \mathbf{1}(g) \cdot [\![O]\!]_{\mathbf{1}}$. Since the trivial character satisfies $\mathbf{1}(g) = 1$ for all $g$, we have $\varphi_g([\![O]\!]_{\mathbf{1}}) = 1 \cdot [\![O]\!]_{\mathbf{1}} = [\![O]\!]_{\mathbf{1}}$.
\end{proof}

\begin{lemma}[Identity Action Fixes Charge Projection]
\label{lem:charge_projection_eigenvalue_at_zero}
\lean{GaugingLDPC.multiSiteChargeProjection_eigenvalue_at_zero}
\leanok
\uses{def:charge__projection_(_multi__site__distribution), lem:covariance__property_of__charge__components}

For a multi-site symmetry action $\sigma$ that fixes scalars, any charge distribution $\chi$, and any operator $O$:
\[
\varphi_{\mathbf{0}}([\![O]\!]_{\boldsymbol{\chi}}) = [\![O]\!]_{\boldsymbol{\chi}}.
\]
\end{lemma}

\begin{proof}
\leanok
\uses{lem:covariance__property_of__charge__components}

By the covariance theorem with $g = \mathbf{0}$, we have $\varphi_{\mathbf{0}}([\![O]\!]_{\boldsymbol{\chi}}) = \boldsymbol{\chi}(\mathbf{0}) \cdot [\![O]\!]_{\boldsymbol{\chi}}$. Since $\boldsymbol{\chi}(\mathbf{0}) = 1$ (the character evaluated at the identity element), the result follows.
\end{proof}

\begin{lemma}[Eigenvalue Multiplicativity]
\label{lem:charge_projection_eigenvalue_mul}
\lean{GaugingLDPC.multiSiteChargeProjection_eigenvalue_mul}
\leanok
\uses{def:charge__projection_(_multi__site__distribution)}

The eigenvalue of the charge projection is multiplicative in $g$: for a charge distribution $\chi$ and group tuples $g_1, g_2 \in A^{C_0}$,
\[
\boldsymbol{\chi}(g_1 + g_2) = \boldsymbol{\chi}(g_1) \cdot \boldsymbol{\chi}(g_2).
\]
\end{lemma}

\begin{proof}
\leanok
\uses{def:charge__projection_(_multi__site__distribution)}

This follows directly from the multiplicative property of the multi-site character value.
\end{proof}

%--- Lem_2: Completeness of Charge Expansion ---
\begin{lemma}[Single-Site Character Orthogonality]
\label{lem:single_site_character_orthogonality}
\lean{GaugingLDPC.singleSiteCharacter_orthogonality}
\leanok
\uses{def:charge__projection_(_single__site)}

For any $g \in A$, the sum over all characters satisfies the orthogonality relation:
\[
\sum_{\chi \in \hat{A}} \chi(g) = \begin{cases} p & \text{if } g = 0 \\ 0 & \text{otherwise} \end{cases}
\]
\end{lemma}

\begin{proof}
\leanok

We consider two cases based on whether $g = 0$.

\textbf{Case 1: $g = 0$.} When $g = 0$, all characters evaluate to $1$ at the identity: $\chi(0) = 1$ for all $\chi \in \hat{A}$. By simplification using the character evaluation at zero and the cardinality of the character group (which equals $|A| = p$ for $A = \mathbb{Z}_p$), we obtain:
\[
\sum_{\chi \in \hat{A}} \chi(0) = \sum_{\chi \in \hat{A}} 1 = |\hat{A}| = p.
\]

\textbf{Case 2: $g \neq 0$.} We use the shifting argument with the standard character $\chi_1 = \chi_{\text{std}}(1)$.

First, we establish that $\chi_1(g) \neq 1$ for $g \neq 0$. Since $\chi_1(g) = \exp(2\pi i \cdot g/p)$, and $0 < g < p$ (as elements of $\mathbb{Z}_p$), the exponent $g/p$ lies in the open interval $(0, 1)$. By the characterization of $\exp(z) = 1$ (which holds if and only if $z = 2\pi i n$ for some integer $n$), and since $g/p$ is not an integer, we have $\chi_1(g) \neq 1$.

Let $S = \sum_{\chi \in \hat{A}} \chi(g)$. We compute:
\[
\sum_{\chi \in \hat{A}} (\chi_1 \cdot \chi)(g) = \chi_1(g) \cdot \sum_{\chi \in \hat{A}} \chi(g) = \chi_1(g) \cdot S.
\]

By reindexing $\chi \mapsto \chi_1^{-1} \cdot \chi$ (which is a bijection on $\hat{A}$), we obtain:
\[
\sum_{\chi \in \hat{A}} (\chi_1 \cdot \chi)(g) = \sum_{\chi \in \hat{A}} \chi(g) = S.
\]

Combining these, we get $S = \chi_1(g) \cdot S$, which implies $(1 - \chi_1(g)) \cdot S = 0$. Since $\chi_1(g) \neq 1$, we have $1 - \chi_1(g) \neq 0$, and thus $S = 0$.
\end{proof}

\begin{lemma}[Single-Site Conjugate Character Orthogonality]
\label{lem:single_site_character_conj_orthogonality}
\lean{GaugingLDPC.singleSiteCharacterConj_orthogonality}
\leanok
\uses{def:charge__projection_(_single__site), lem:single_site_character_orthogonality}

For any $g \in A$, the sum over conjugated characters satisfies:
\[
\sum_{\chi \in \hat{A}} \overline{\chi(g)} = \begin{cases} p & \text{if } g = 0 \\ 0 & \text{otherwise} \end{cases}
\]
\end{lemma}

\begin{proof}
\leanok
\uses{lem:single_site_character_orthogonality}

Rewriting $\overline{\chi(g)} = \chi(-g)$, we have:
\[
\sum_{\chi \in \hat{A}} \overline{\chi(g)} = \sum_{\chi \in \hat{A}} \chi(-g).
\]

By reindexing via the bijection $\chi \mapsto \chi^{-1}$ (using the identity $\chi(-g) = \chi^{-1}(g)$), we obtain:
\[
\sum_{\chi \in \hat{A}} \chi(-g) = \sum_{\chi \in \hat{A}} \chi(g).
\]

The result then follows from the single-site character orthogonality (Lemma~\ref{lem:single_site_character_orthogonality}).
\end{proof}

\begin{lemma}[Multi-Site Character Orthogonality]
\label{lem:multi_site_character_conj_orthogonality}
\lean{GaugingLDPC.multiSiteCharacterConj_orthogonality}
\leanok
\uses{def:charge__projection_(_multi__site__distribution), lem:single_site_character_conj_orthogonality}

For any $\mathbf{g} \in A^{C_0}$, the multi-site character orthogonality relation states:
\[
\sum_{\boldsymbol{\chi} \in \hat{A}^{C_0}} \overline{\boldsymbol{\chi}(\mathbf{g})} = \begin{cases} p^{|C_0|} & \text{if } \mathbf{g} = \mathbf{0} \\ 0 & \text{otherwise} \end{cases}
\]
where $\boldsymbol{\chi}(\mathbf{g}) = \prod_{v \in C_0} \chi_v(g_v)$.
\end{lemma}

\begin{proof}
\leanok
\uses{lem:single_site_character_conj_orthogonality}

Expanding the definition of the multi-site character:
\[
\sum_{\boldsymbol{\chi} \in \hat{A}^{C_0}} \overline{\boldsymbol{\chi}(\mathbf{g})} = \sum_{\boldsymbol{\chi} \in \hat{A}^{C_0}} \prod_{v \in C_0} \overline{\chi_v(g_v)}.
\]

Using the interchange of sum and product (Fubini's theorem for finite sums), we obtain:
\[
\sum_{\boldsymbol{\chi} \in \hat{A}^{C_0}} \prod_{v \in C_0} \overline{\chi_v(g_v)} = \prod_{v \in C_0} \sum_{\chi_v \in \hat{A}} \overline{\chi_v(g_v)}.
\]

Applying single-site orthogonality at each vertex $v$:
\[
\sum_{\chi_v \in \hat{A}} \overline{\chi_v(g_v)} = \begin{cases} p & \text{if } g_v = 0 \\ 0 & \text{otherwise} \end{cases}
\]

We consider two cases:

\textbf{Case 1: $\mathbf{g} = \mathbf{0}$.} For all $v \in C_0$, we have $g_v = 0$. Thus:
\[
\prod_{v \in C_0} p = p^{|C_0|}.
\]

\textbf{Case 2: $\mathbf{g} \neq \mathbf{0}$.} There exists some $v_0 \in C_0$ with $g_{v_0} \neq 0$. By applying the property that a product with a zero factor equals zero, the entire product vanishes.
\end{proof}

\begin{lemma}[Completeness of Charge Expansion]
\label{lem:completeness_of__charge__expansion}
\lean{GaugingLDPC.chargeProjection_sum_completeness}
\leanok
\uses{lem:charge_projection_sum_completeness_add}

Let $O$ be any operator on the Hilbert space. The charge decomposition is \textbf{complete}, meaning:
\[
\sum_{\boldsymbol{\chi} \in \hat{A}^{C_0}} \llbracket O \rrbracket_{\boldsymbol{\chi}} = O
\]
where the sum runs over all possible charge distributions $\boldsymbol{\chi}$.
\end{lemma}

\begin{proof}
\leanok
\uses{lem:multi_site_character_conj_orthogonality}

\textbf{Step 1: Expand the definition.} Unfolding the definition of the charge projection:
\[
\sum_{\boldsymbol{\chi} \in \hat{A}^{C_0}} \llbracket O \rrbracket_{\boldsymbol{\chi}} = \sum_{\boldsymbol{\chi}} \frac{1}{|A|^{|C_0|}} \sum_{\mathbf{g} \in A^{C_0}} \overline{\boldsymbol{\chi}(\mathbf{g})} \cdot \varphi_{\mathbf{g}}(O).
\]

\textbf{Step 2: Interchange order of summation.} By distributing the scalar multiplication and exchanging the order of summation:
\[
= \sum_{\mathbf{g} \in A^{C_0}} \frac{1}{|A|^{|C_0|}} \left( \sum_{\boldsymbol{\chi}} \overline{\boldsymbol{\chi}(\mathbf{g})} \right) \cdot \varphi_{\mathbf{g}}(O).
\]

\textbf{Step 3: Apply character orthogonality.} By the multi-site character orthogonality relation:
\[
\sum_{\boldsymbol{\chi} \in \hat{A}^{C_0}} \overline{\boldsymbol{\chi}(\mathbf{g})} = \begin{cases} |A|^{|C_0|} & \text{if } \mathbf{g} = \mathbf{0} \\ 0 & \text{otherwise} \end{cases}
\]

We note that $|A|^{|C_0|} = p^{|C_0|} \neq 0$ since $p$ is prime.

\textbf{Step 4: Simplify using the delta function.} Substituting this into the sum:
\[
= \sum_{\mathbf{g}} \frac{1}{p^{|C_0|}} \cdot \delta_{\mathbf{g}, \mathbf{0}} \cdot p^{|C_0|} \cdot \varphi_{\mathbf{g}}(O).
\]

For $\mathbf{g} = \mathbf{0}$, the factors $p^{|C_0|}$ and $(p^{|C_0|})^{-1}$ cancel, leaving $\varphi_{\mathbf{0}}(O)$. For $\mathbf{g} \neq \mathbf{0}$, the term vanishes.

Thus the sum collapses to:
\[
= \varphi_{\mathbf{0}}(O).
\]

\textbf{Step 5: Apply zero-action identity.} By the property of the symmetry action, $\varphi_{\mathbf{0}}(O) = O$ (the zero group element acts as the identity).
\end{proof}

\begin{lemma}[Completeness for Index-Based Projections]
\label{lem:charge_projection_by_index_sum_completeness}
\lean{GaugingLDPC.chargeProjectionByIndex_sum_completeness}
\leanok
\uses{def:charge__projection_(_multi__site__distribution), lem:completeness_of__charge__expansion}

The sum over all index-based charge projections recovers the original operator:
\[
\sum_{k : C_0 \to \mathbb{Z}_p} \llbracket O \rrbracket_k = O
\]
\end{lemma}

\begin{proof}
\leanok
\uses{lem:completeness_of__charge__expansion}

We use the equivalence $\mathbb{Z}_p \simeq \text{AddChar}(\mathbb{Z}_p, \mathbb{C}^\times)$ from Pontryagin duality, which extends to an equivalence $E : (C_0 \to \mathbb{Z}_p) \simeq \hat{A}^{C_0}$ sending $k$ to the standard character distribution indexed by $k$.

First, we verify that for all $k$, $E(k) = \chi_{\text{std}}^k$ where $\chi_{\text{std}}^k$ is the standard character distribution indexed by $k$. This follows from the explicit formula for the additive character on $\mathbb{Z}_p$: for each vertex $v$ and group element $g$:
\[
E(k)_v(g) = \exp\left(\frac{2\pi i \cdot k_v \cdot g}{p}\right) = \chi_{\text{std}}(k_v)(g).
\]

Using this equivalence to reindex the sum:
\[
\sum_{k : C_0 \to \mathbb{Z}_p} \llbracket O \rrbracket_{\chi_{\text{std}}^k} = \sum_{\boldsymbol{\chi} \in \hat{A}^{C_0}} \llbracket O \rrbracket_{\boldsymbol{\chi}} = O
\]
where the last equality follows from the completeness theorem (Lemma~\ref{lem:completeness_of__charge__expansion}).
\end{proof}

\begin{corollary}[Charge Decomposition Recovers Operator]
\label{cor:charge_projection_recovers_operator}
\lean{GaugingLDPC.chargeProjection_recovers_operator}
\leanok
\uses{lem:completeness_of__charge__expansion}

The charge decomposition recovers the operator:
\[
O = \sum_{\boldsymbol{\chi} \in \hat{A}^{C_0}} \llbracket O \rrbracket_{\boldsymbol{\chi}}
\]
\end{corollary}

\begin{proof}
\leanok
\uses{lem:completeness_of__charge__expansion}

This follows directly by symmetry from the completeness theorem (Lemma~\ref{lem:completeness_of__charge__expansion}).
\end{proof}

\begin{corollary}[Completeness via Zero-Action Identity]
\label{cor:charge_projection_sum_eq_product_action_zero}
\lean{GaugingLDPC.chargeProjection_sum_eq_productAction_zero}
\leanok
\uses{lem:completeness_of__charge__expansion}

The sum over all charge projections equals the zero-action on the operator:
\[
\sum_{\boldsymbol{\chi} \in \hat{A}^{C_0}} \llbracket O \rrbracket_{\boldsymbol{\chi}} = \varphi_{\mathbf{0}}(O)
\]
\end{corollary}

\begin{proof}
\leanok
\uses{lem:completeness_of__charge__expansion}

By the completeness theorem, the left-hand side equals $O$. By the property of the symmetry action, $\varphi_{\mathbf{0}}(O) = O$. Thus both sides equal $O$.
\end{proof}

\begin{lemma}[Partial Reconstruction via Subset Sum]
\label{lem:charge_projection_sum_subset}
\lean{GaugingLDPC.chargeProjection_sum_subset}
\leanok
\uses{lem:completeness_of__charge__expansion}

For any subset $S \subseteq \hat{A}^{C_0}$ of charge distributions:
\[
\sum_{\boldsymbol{\chi} \in S} \llbracket O \rrbracket_{\boldsymbol{\chi}} = O - \sum_{\boldsymbol{\chi} \in S^c} \llbracket O \rrbracket_{\boldsymbol{\chi}}
\]
\end{lemma}

\begin{proof}
\leanok
\uses{lem:completeness_of__charge__expansion}

By the completeness theorem:
\[
\sum_{\boldsymbol{\chi} \in \hat{A}^{C_0}} \llbracket O \rrbracket_{\boldsymbol{\chi}} = O.
\]

Splitting the full sum into $S$ and $S^c$ parts using the disjoint union $\hat{A}^{C_0} = S \sqcup S^c$:
\[
\sum_{\boldsymbol{\chi} \in S} \llbracket O \rrbracket_{\boldsymbol{\chi}} + \sum_{\boldsymbol{\chi} \in S^c} \llbracket O \rrbracket_{\boldsymbol{\chi}} = O.
\]

By ring arithmetic, if $a + b = c$ then $a = c - b$. Applying this:
\[
\sum_{\boldsymbol{\chi} \in S} \llbracket O \rrbracket_{\boldsymbol{\chi}} = O - \sum_{\boldsymbol{\chi} \in S^c} \llbracket O \rrbracket_{\boldsymbol{\chi}}.
\]
\end{proof}

\begin{lemma}[Completeness Respects Addition]
\label{lem:charge_projection_sum_completeness_add}
\lean{GaugingLDPC.chargeProjection_sum_completeness_add}
\leanok
\uses{lem:completeness_of__charge__expansion}

The completeness identity respects addition:
\[
\sum_{\boldsymbol{\chi}} \llbracket O_1 + O_2 \rrbracket_{\boldsymbol{\chi}} = \left(\sum_{\boldsymbol{\chi}} \llbracket O_1 \rrbracket_{\boldsymbol{\chi}}\right) + \left(\sum_{\boldsymbol{\chi}} \llbracket O_2 \rrbracket_{\boldsymbol{\chi}}\right)
\]
\end{lemma}

\begin{proof}
\leanok
\uses{lem:completeness_of__charge__expansion}

By applying the completeness theorem to each side: the left-hand side equals $O_1 + O_2$, and the right-hand side equals $O_1 + O_2$. Thus both sides are equal.
\end{proof}

\begin{lemma}[Completeness Respects Scalar Multiplication]
\label{lem:charge_projection_sum_completeness_smul}
\lean{GaugingLDPC.chargeProjection_sum_completeness_smul}
\leanok
\uses{lem:completeness_of__charge__expansion}

The completeness identity respects scalar multiplication: for any scalar $c \in \mathbb{C}$,
\[
\sum_{\boldsymbol{\chi}} \llbracket c \cdot O \rrbracket_{\boldsymbol{\chi}} = c \cdot \sum_{\boldsymbol{\chi}} \llbracket O \rrbracket_{\boldsymbol{\chi}}
\]
\end{lemma}

\begin{proof}
\leanok
\uses{lem:completeness_of__charge__expansion}

By applying the completeness theorem to each side: the left-hand side equals $c \cdot O$, and the right-hand side equals $c \cdot O$. Thus both sides are equal.
\end{proof}

%--- Def_3: Symmetrized Operator (Orbit Average) ---
\begin{definition}[Symmetrized Operator (Orbit Average)]
\label{def:symmetrized__operator_(_orbit__average)}
\lean{GaugingLDPC.symmetrizedOperator}
\leanok
\uses{def:charge__projection_(_single__site)}

Let $A$ be an Abelian symmetry group acting on operators via automorphisms $\varphi_g$. For any operator (or stabilizer) $S$, the \textbf{symmetrized operator} (also called orbit average) is defined as:
\[
\overline{S} := \frac{1}{|A|} \sum_{g \in A} \varphi_g(S)
\]

This is the average of $S$ over its orbit under the symmetry group action. The normalization factor $1/|A| = 1/p$ ensures the result is properly scaled.
\end{definition}

\begin{theorem}[Symmetrizing Zero Gives Zero]
\label{thm:symmetrized_operator_zero}
\lean{GaugingLDPC.symmetrizedOperator_zero}
\leanok
\uses{def:symmetrized__operator_(_orbit__average)}

For any ring $R$ with $\mathbb{C}$-algebra structure and symmetry action $\sigma$, we have $\overline{0} = 0$.
\end{theorem}

\begin{proof}
\leanok

By unfolding the definition of symmetrized operator, we have $\overline{0} = p^{-1} \cdot \sum_{g \in A} \varphi_g(0)$. Since each $\varphi_g$ is a ring homomorphism, $\varphi_g(0) = 0$ for all $g$. Thus the sum is zero, and scalar multiplication by zero gives zero.
\end{proof}

\begin{theorem}[Symmetrizing One Gives One]
\label{thm:symmetrized_operator_one}
\lean{GaugingLDPC.symmetrizedOperator_one}
\leanok
\uses{def:symmetrized__operator_(_orbit__average)}

For any ring $R$ with $\mathbb{C}$-algebra structure and symmetry action $\sigma$, we have $\overline{1} = 1$.
\end{theorem}

\begin{proof}
\leanok

By unfolding the definition, $\overline{1} = p^{-1} \cdot \sum_{g \in A} \varphi_g(1)$. Since each $\varphi_g$ is a ring automorphism, $\varphi_g(1) = 1$ for all $g$. The sum over all $g \in A$ of the constant 1 equals $|A| = p$. Thus $\overline{1} = p^{-1} \cdot p \cdot 1 = 1$, where we use that $(p : \mathbb{C}) \neq 0$ since $p$ is prime.
\end{proof}

\begin{theorem}[Symmetrization is Additive]
\label{thm:symmetrized_operator_add}
\lean{GaugingLDPC.symmetrizedOperator_add}
\leanok
\uses{def:symmetrized__operator_(_orbit__average)}

For any operators $S_1, S_2 \in R$:
\[
\overline{S_1 + S_2} = \overline{S_1} + \overline{S_2}
\]
\end{theorem}

\begin{proof}
\leanok

By unfolding the definition, $\overline{S_1 + S_2} = p^{-1} \cdot \sum_{g \in A} \varphi_g(S_1 + S_2)$. Since each $\varphi_g$ is a ring homomorphism, $\varphi_g(S_1 + S_2) = \varphi_g(S_1) + \varphi_g(S_2)$. Distributing the sum and scalar multiplication yields the result.
\end{proof}

\begin{definition}[Orbit Function]
\label{def:orbit_fun}
\lean{GaugingLDPC.orbitFun}
\leanok
\uses{def:symmetrized__operator_(_orbit__average)}

The orbit of an operator $S$ under the symmetry action is defined as the function:
\[
O^T(S) : A \to R, \quad g \mapsto \varphi_g(S)
\]

This defines the orbit $O^T(S) = \{\varphi_g(S) : g \in A\}$ of $S$ under the symmetry group.
\end{definition}

\begin{theorem}[Orbit Function at Identity]
\label{thm:orbit_fun_zero}
\lean{GaugingLDPC.orbitFun_zero}
\leanok
\uses{def:orbit_fun}

The orbit function at $g = 0$ gives back the original element: $O^T(S)(0) = S$.
\end{theorem}

\begin{proof}
\leanok

By definition of the orbit function, $O^T(S)(0) = \varphi_0(S)$. Since $\sigma$ maps 0 to the identity automorphism, this equals $S$.
\end{proof}

\begin{theorem}[Orbit Function Equivariance]
\label{thm:orbit_fun_add}
\lean{GaugingLDPC.orbitFun_add}
\leanok
\uses{def:orbit_fun}

The orbit function is equivariant: for all $g, h \in A$,
\[
O^T(S)(g + h) = \varphi_g(O^T(S)(h))
\]
\end{theorem}

\begin{proof}
\leanok

By definition of the orbit function, $O^T(S)(g + h) = \varphi_{g+h}(S)$. Since $\sigma$ is a group homomorphism, $\varphi_{g+h} = \varphi_g \circ \varphi_h$. Applying this to $S$ gives $\varphi_g(\varphi_h(S)) = \varphi_g(O^T(S)(h))$.
\end{proof}

\begin{theorem}[Symmetrized Operator is Invariant]
\label{thm:symmetrized_operator_invariant}
\lean{GaugingLDPC.symmetrizedOperator_invariant}
\leanok
\uses{def:symmetrized__operator_(_orbit__average)}

Assume the symmetry action commutes with $\mathbb{C}$-scalars, i.e., $\varphi_g(c \cdot x) = c \cdot \varphi_g(x)$ for all $c \in \mathbb{C}$. Then the symmetrized operator is invariant under the symmetry action: for all $h \in A$ and operators $S$,
\[
\varphi_h(\overline{S}) = \overline{S}
\]
\end{theorem}

\begin{proof}
\leanok

By unfolding the definition, $\varphi_h(\overline{S}) = \varphi_h(p^{-1} \cdot \sum_{g \in A} \varphi_g(S))$. Using the scalar commutation hypothesis, this equals $p^{-1} \cdot \varphi_h(\sum_{g \in A} \varphi_g(S))$. Since $\varphi_h$ distributes over sums, this becomes $p^{-1} \cdot \sum_{g \in A} \varphi_h(\varphi_g(S)) = p^{-1} \cdot \sum_{g \in A} \varphi_{g+h}(S)$.

We now reindex the sum by the bijection $g \mapsto g + h$ with inverse $g \mapsto g + (-h)$. These are valid bijections on the finite group $A$, and we verify: $(g + h) + (-h) = g$ and $g + (-h) + h = g$. The reindexed sum equals $\sum_{g' \in A} \varphi_{g'}(S) = \sum_{g \in A} \varphi_g(S)$, which gives $\overline{S}$.
\end{proof}

\begin{corollary}[Symmetrized Operator is Fixed Point]
\label{cor:symmetrized_operator_fixed}
\lean{GaugingLDPC.symmetrizedOperator_fixed}
\leanok
\uses{thm:symmetrized_operator_invariant}

Under the scalar commutation hypothesis, $\overline{S}$ is a fixed point of all automorphisms $\varphi_g$.
\end{corollary}

\begin{proof}
\leanok
\uses{thm:symmetrized_operator_invariant}
This follows immediately from Theorem~\ref{thm:symmetrized_operator_invariant} by taking $h = g$ for arbitrary $g \in A$.
\end{proof}

\begin{theorem}[Symmetrization is Idempotent]
\label{thm:symmetrized_operator_idempotent}
\lean{GaugingLDPC.symmetrizedOperator_idempotent}
\leanok
\uses{def:symmetrized__operator_(_orbit__average), thm:symmetrized_operator_invariant}

Under the scalar commutation hypothesis, symmetrizing an already symmetric operator gives the same result:
\[
\overline{\overline{S}} = \overline{S}
\]
\end{theorem}

\begin{proof}
\leanok
\uses{thm:symmetrized_operator_invariant}
By unfolding the definition, $\overline{\overline{S}} = p^{-1} \cdot \sum_{g \in A} \varphi_g(\overline{S})$. By the invariance property (Theorem~\ref{thm:symmetrized_operator_invariant}), $\varphi_g(\overline{S}) = \overline{S}$ for all $g$. Thus the sum equals $|A| \cdot \overline{S} = p \cdot \overline{S}$. Multiplying by $p^{-1}$ and using that $(p : \mathbb{C}) \neq 0$ since $p$ is prime, we get $\overline{\overline{S}} = \overline{S}$.
\end{proof}

\begin{theorem}[Symmetrized Operator Equals Trivial Charge Projection]
\label{thm:symmetrized_operator_eq_charge_projection_trivial}
\lean{GaugingLDPC.symmetrizedOperator_eq_chargeProjection_trivial}
\leanok
\uses{def:symmetrized__operator_(_orbit__average), def:charge__projection_(_single__site)}

The symmetrized operator equals the charge projection with trivial character (charge 0):
\[
\overline{S} = [S]_{\chi=1} = [S]_0
\]

This shows that symmetrization extracts the ``charge-0'' or ``symmetric'' component.
\end{theorem}

\begin{proof}
\leanok
\uses{def:charge__projection_(_single__site)}
By unfolding both definitions, $\overline{S} = p^{-1} \cdot \sum_{g \in A} \varphi_g(S)$ and $[S]_1 = p^{-1} \cdot \sum_{g \in A} \overline{\chi_1(g)} \cdot \varphi_g(S)$. For the trivial character $\chi = 1$, we have $\chi_1(g) = 1$ for all $g$, so $\overline{\chi_1(g)} = 1$. Thus the two expressions are equal.
\end{proof}

\begin{theorem}[Symmetrized Operator Equals Zero-Index Charge Projection]
\label{thm:symmetrized_operator_eq_charge_projection_by_index_zero}
\lean{GaugingLDPC.symmetrizedOperator_eq_chargeProjectionByIndex_zero}
\leanok
\uses{thm:symmetrized_operator_eq_charge_projection_trivial, def:charge__projection_(_single__site)}

The symmetrized operator equals the charge projection by index 0:
\[
\overline{S} = [S]_0
\]
\end{theorem}

\begin{proof}
\leanok
\uses{thm:symmetrized_operator_eq_charge_projection_trivial}
By rewriting with Theorem~\ref{thm:symmetrized_operator_eq_charge_projection_trivial}, it suffices to show that the trivial character equals the standard character at index 0. By extensionality, for any $g \in A$, the standard character at index 0 satisfies $\chi_0(g) = 1$, which equals the trivial character.
\end{proof}

\begin{definition}[Multi-Site Symmetrized Operator]
\label{def:symmetrized_operator_multi_site}
\lean{GaugingLDPC.symmetrizedOperatorMultiSite}
\leanok
\uses{def:symmetrized__operator_(_orbit__average), def:charge__projection_(_multi__site__distribution)}

The multi-site symmetrized operator (orbit average) under product symmetry action is defined as:
\[
\overline{S} := \frac{1}{|A|^{|C_0|}} \sum_{\mathbf{g} \in A^{C_0}} \varphi_{\mathbf{g}}(S)
\]

This averages $S$ over all configurations of symmetry group elements on all vertices.
\end{definition}

\begin{theorem}[Multi-Site Symmetrizing Zero Gives Zero]
\label{thm:symmetrized_operator_multi_site_zero}
\lean{GaugingLDPC.symmetrizedOperatorMultiSite_zero}
\leanok
\uses{def:symmetrized_operator_multi_site}

For any multi-site symmetry action $\sigma$, $\overline{0} = 0$.
\end{theorem}

\begin{proof}
\leanok

By unfolding the definition, $\overline{0} = (p^{|C_0|})^{-1} \cdot \sum_{\mathbf{g} \in A^{C_0}} \varphi_{\mathbf{g}}(0)$. Since the product action maps 0 to 0, each term is zero, so the sum is zero, and scalar multiplication by zero gives zero.
\end{proof}

\begin{theorem}[Multi-Site Symmetrization is Additive]
\label{thm:symmetrized_operator_multi_site_add}
\lean{GaugingLDPC.symmetrizedOperatorMultiSite_add}
\leanok
\uses{def:symmetrized_operator_multi_site}

For any operators $S_1, S_2 \in R$:
\[
\overline{S_1 + S_2} = \overline{S_1} + \overline{S_2}
\]
\end{theorem}

\begin{proof}
\leanok

By unfolding the definition, the product action and composed automorphism preserve addition. Distributing the sum and scalar multiplication yields the result.
\end{proof}

\begin{theorem}[Multi-Site Symmetrized Operator Equals Trivial Charge Distribution Projection]
\label{thm:symmetrized_operator_multi_site_eq_charge_projection_trivial}
\lean{GaugingLDPC.symmetrizedOperatorMultiSite_eq_chargeProjection_trivial}
\leanok
\uses{def:symmetrized_operator_multi_site, def:charge__projection_(_multi__site__distribution)}

The multi-site symmetrized operator equals the multi-site charge projection with trivial charge distribution:
\[
\overline{S} = [S]_{\text{trivial}}
\]
\end{theorem}

\begin{proof}
\leanok
\uses{def:charge__projection_(_multi__site__distribution)}
By unfolding both definitions, we need to show that the summands are equal. For the trivial charge distribution, the multi-site character conjugate value equals 1, so scalar multiplication by 1 gives the same result as no scalar multiplication.
\end{proof}

\begin{theorem}[Multi-Site Symmetrized Operator Equals Zero-Index Charge Projection]
\label{thm:symmetrized_operator_multi_site_eq_charge_projection_by_index_zero}
\lean{GaugingLDPC.symmetrizedOperatorMultiSite_eq_chargeProjectionByIndex_zero}
\leanok
\uses{thm:symmetrized_operator_multi_site_eq_charge_projection_trivial, def:charge__projection_(_multi__site__distribution)}

The multi-site symmetrized operator equals the multi-site charge projection by zero index function:
\[
\overline{S} = [S]_{(v \mapsto 0)}
\]
\end{theorem}

\begin{proof}
\leanok
\uses{thm:symmetrized_operator_multi_site_eq_charge_projection_trivial}
By rewriting with Theorem~\ref{thm:symmetrized_operator_multi_site_eq_charge_projection_trivial}, it suffices to show that the trivial charge distribution equals the standard charge distribution by index at the zero function. This follows from the fact that the standard charge distribution at the zero index equals the trivial distribution.
\end{proof}

\begin{definition}[Multi-Site Orbit Function]
\label{def:orbit_multi_site_fun}
\lean{GaugingLDPC.orbitMultiSiteFun}
\leanok
\uses{def:symmetrized_operator_multi_site}

The orbit function for multi-site action is defined as:
\[
O^T(S) : A^{C_0} \to R, \quad \mathbf{g} \mapsto \varphi_{\mathbf{g}}(S)
\]
\end{definition}

\begin{theorem}[Multi-Site Orbit Function at Zero]
\label{thm:orbit_multi_site_fun_zero}
\lean{GaugingLDPC.orbitMultiSiteFun_zero}
\leanok
\uses{def:orbit_multi_site_fun}

The multi-site orbit function at $\mathbf{g} = \mathbf{0}$ gives back the original element: $O^T(S)(\mathbf{0}) = S$.
\end{theorem}

\begin{proof}
\leanok

This follows from the product action at the zero tuple returning the original element.
\end{proof}

\begin{theorem}[Multi-Site Symmetrization Reduces to Single-Site for Singleton]
\label{thm:symmetrized_operator_multi_site_singleton}
\lean{GaugingLDPC.symmetrizedOperatorMultiSite_singleton}
\leanok
\uses{def:symmetrized_operator_multi_site, def:symmetrized__operator_(_orbit__average), def:charge__projection_(_multi__site__distribution)}

When $C_0$ has a single element, multi-site symmetrization reduces to single-site symmetrization:
\[
\overline{S}_{\text{multi}} = \overline{S}_{\text{single}}
\]
\end{theorem}

\begin{proof}
\leanok
\uses{thm:symmetrized_operator_multi_site_eq_charge_projection_trivial, thm:symmetrized_operator_eq_charge_projection_trivial}
By rewriting with Theorems~\ref{thm:symmetrized_operator_multi_site_eq_charge_projection_trivial} and \ref{thm:symmetrized_operator_eq_charge_projection_trivial}, both sides equal the respective trivial charge projections. The result then follows from the singleton reduction property of multi-site charge projection.
\end{proof}

\begin{lemma}[Normalization Factor for Single-Site Symmetrization]
\label{lem:symmetrized_operator_normalization}
\lean{GaugingLDPC.symmetrizedOperator_normalization}
\leanok

The normalization factor satisfies $(p : \mathbb{C})^{-1} \cdot (p : \mathbb{C}) = 1$.
\end{lemma}

\begin{proof}
\leanok

Since $p$ is prime, $(p : \mathbb{C}) \neq 0$. The result follows from the inverse multiplication property.
\end{proof}

\begin{lemma}[Normalization Factor for Multi-Site Symmetrization]
\label{lem:symmetrized_operator_multi_site_normalization}
\lean{GaugingLDPC.symmetrizedOperatorMultiSite_normalization}
\leanok

The normalization factor satisfies $((p : \mathbb{C})^{|C_0|})^{-1} \cdot (p : \mathbb{C})^{|C_0|} = 1$.
\end{lemma}

\begin{proof}
\leanok

Since $p$ is prime, $(p : \mathbb{C}) \neq 0$, hence $(p : \mathbb{C})^{|C_0|} \neq 0$. The result follows from the inverse multiplication property.
\end{proof}

\begin{lemma}[Orbit of Zero Operator is Zero]
\label{lem:orbit_fun_zero_operator}
\lean{GaugingLDPC.orbitFun_zero_operator}
\leanok
\uses{def:orbit_fun}

For any $g \in A$, the orbit of zero is zero: $O^T(0)(g) = 0$.
\end{lemma}

\begin{proof}
\leanok

By definition of the orbit function, $O^T(0)(g) = \varphi_g(0)$. Since each $\varphi_g$ is a ring homomorphism, this equals 0.
\end{proof}

\begin{lemma}[Multi-Site Orbit of Zero Operator is Zero]
\label{lem:orbit_multi_site_fun_zero_operator}
\lean{GaugingLDPC.orbitMultiSiteFun_zero_operator}
\leanok
\uses{def:orbit_multi_site_fun}

For any $\mathbf{g} \in A^{C_0}$, the multi-site orbit of zero is zero: $O^T(0)(\mathbf{g}) = 0$.
\end{lemma}

\begin{proof}
\leanok

This follows from the product action mapping zero to zero.
\end{proof}

\begin{lemma}[Cardinality of Symmetry Group]
\label{lem:symmetrized_operator_card_factor}
\lean{GaugingLDPC.symmetrizedOperator_card_factor}
\leanok

The cardinality of the symmetry group equals $p$: $|A| = p$.
\end{lemma}

\begin{proof}
\leanok

This follows from the cardinality property of $\mathbb{Z}/p\mathbb{Z}$.
\end{proof}

\begin{lemma}[Cardinality of Product Group]
\label{lem:symmetrized_operator_multi_site_card_factor}
\lean{GaugingLDPC.symmetrizedOperatorMultiSite_card_factor}
\leanok

The cardinality of the product group equals $p^{|C_0|}$: $|A^{C_0}| = p^{|C_0|}$.
\end{lemma}

\begin{proof}
\leanok

This follows from the cardinality of function spaces: $|\text{Fin}(C_0) \to A| = |A|^{|C_0|}$.
\end{proof}

%--- Thm_1: Vanishing of Reduced Zeroth Homology for Connected Graphs ---
\begin{definition}[Connected Oriented Graph]
\label{def:is_connected}
\lean{GaugingLDPC.IsConnected}
\leanok

An oriented graph $G = (V, E)$ is \emph{connected} if:
\begin{enumerate}
\item The graph has at least one vertex (i.e., $V \neq \emptyset$).
\item For any two vertices $u, v \in V$, there exists a 1-chain $\gamma \in C_1(G, A)$ such that
\[
\partial_1(\gamma) = v - u,
\]
where $v - u$ denotes the formal difference $\delta_v - \delta_u$ in the free module $C_0(G, A)$.
\end{enumerate}
\end{definition}

\begin{theorem}[Image of Boundary in Kernel of Augmentation]
\label{thm:im_boundary_le_ker_augmentation}
\lean{GaugingLDPC.im_boundary_le_ker_augmentation}
\leanok

The image of the boundary map is contained in the kernel of the augmentation map:
\[
\operatorname{im}(\partial_1) \subseteq \ker(\epsilon).
\]
This is the chain complex property $\epsilon \circ \partial_1 = 0$.
\end{theorem}

\begin{proof}
\leanok

This follows directly from the chain complex property established in the chain complex notation (the composition $\epsilon \circ \partial_1 = 0$).
\end{proof}

\begin{definition}[Charge-Neutral 0-Chain]
\label{def:is_charge_neutral}
\lean{GaugingLDPC.IsChargeNeutral}
\leanok

A 0-chain $c \in C_0(G, A)$ is \emph{charge-neutral} if it lies in the kernel of the augmentation map, i.e., the sum of its coefficients is zero:
\[
\epsilon(c) = \sum_{v \in V} c(v) = 0.
\]
\end{definition}

\begin{lemma}[Charge-Neutral Equivalence]
\label{lem:is_charge_neutral_iff_mem_ker}
\lean{GaugingLDPC.isChargeNeutral_iff_mem_ker}
\leanok
\uses{def:is_charge_neutral}

A 0-chain $c$ is charge-neutral if and only if $c \in \ker(\epsilon)$.
\end{lemma}

\begin{proof}
\leanok
\uses{def:is_charge_neutral}

By simplification using the definitions of charge-neutral and kernel membership, we have that $c$ is charge-neutral (i.e., $\epsilon(c) = 0$) if and only if $c \in \ker(\epsilon)$.
\end{proof}

\begin{lemma}[Vertex Difference in Range of Boundary]
\label{lem:difference_mem_range_boundary}
\lean{GaugingLDPC.difference_mem_range_boundary}
\leanok
\uses{def:is_connected}

Let $G$ be a connected graph. For any two vertices $u, v \in V$, the difference $(v - u)$ as a 0-chain is in the image of the boundary map:
\[
\delta_v - \delta_u \in \operatorname{im}(\partial_1).
\]
\end{lemma}

\begin{proof}
\leanok
\uses{def:is_connected}

From the connectivity assumption, we obtain a 1-chain $\gamma$ satisfying $\partial_1(\gamma) = \delta_v - \delta_u$. This directly witnesses that $\delta_v - \delta_u \in \operatorname{im}(\partial_1)$.
\end{proof}

\begin{lemma}[Vertex Minus Root in Range]
\label{lem:vertex_minus_root_mem_range}
\lean{GaugingLDPC.vertex_minus_root_mem_range}
\leanok
\uses{def:is_connected, lem:difference_mem_range_boundary}

Let $G$ be a connected graph. For any root vertex $r \in V$ and any vertex $v \in V$:
\[
\delta_v - \delta_r \in \operatorname{im}(\partial_1).
\]
\end{lemma}

\begin{proof}
\leanok
\uses{lem:difference_mem_range_boundary}

This follows directly from Lemma~\ref{lem:difference_mem_range_boundary} applied to the pair $(r, v)$.
\end{proof}

\begin{lemma}[Chain Decomposition]
\label{lem:chain_decomposition}
\lean{GaugingLDPC.chain_decomposition}
\leanok

Any 0-chain $c \in C_0(G, A)$ can be written as:
\[
c = \sum_{v \in V} c(v) \cdot (\delta_v - \delta_r) + \epsilon(c) \cdot \delta_r
\]
for any choice of root vertex $r \in V$.
\end{lemma}

\begin{proof}
\leanok

We first establish that $\sum_{v \in V} c(v) \cdot \delta_v = c$. By extensionality, it suffices to show equality for an arbitrary vertex $w$. Using the definition of finitely supported functions and the indicator property of $\delta_v$, we have:
\[
\left(\sum_{v \in V} c(v) \cdot \delta_v\right)(w) = c(w) \cdot 1 = c(w),
\]
where the sum reduces to the single term with $v = w$ (all other terms vanish).

Next, by distributivity of scalar multiplication over subtraction:
\[
\sum_{v \in V} c(v) \cdot (\delta_v - \delta_r) = \sum_{v \in V} c(v) \cdot \delta_v - \left(\sum_{v \in V} c(v)\right) \cdot \delta_r = c - \epsilon(c) \cdot \delta_r.
\]

Substituting this into the right-hand side of the claimed identity:
\[
\sum_{v \in V} c(v) \cdot (\delta_v - \delta_r) + \epsilon(c) \cdot \delta_r = c - \epsilon(c) \cdot \delta_r + \epsilon(c) \cdot \delta_r = c.
\]
This holds by cancellation.
\end{proof}

\begin{lemma}[Charge-Neutral Decomposition]
\label{lem:charge_neutral_decomposition}
\lean{GaugingLDPC.charge_neutral_decomposition}
\leanok
\uses{def:is_charge_neutral, lem:chain_decomposition}

If $c$ is charge-neutral (i.e., $\epsilon(c) = 0$), then:
\[
c = \sum_{v \in V} c(v) \cdot (\delta_v - \delta_r)
\]
for any root vertex $r \in V$.
\end{lemma}

\begin{proof}
\leanok
\uses{def:is_charge_neutral, lem:chain_decomposition}

By Lemma~\ref{lem:chain_decomposition}, we have $c = \sum_{v \in V} c(v) \cdot (\delta_v - \delta_r) + \epsilon(c) \cdot \delta_r$. Since $c$ is charge-neutral, we have $\epsilon(c) = 0$, so the second term vanishes: $0 \cdot \delta_r = 0$. Adding zero gives the result.
\end{proof}

\begin{lemma}[Sum in Range]
\label{lem:sum_mem_range}
\lean{GaugingLDPC.sum_mem_range}
\leanok

Let $s$ be a finite set and $f : s \to C_0(G, A)$ be a function such that $f(i) \in \operatorname{im}(\partial_1)$ for all $i \in s$. Then:
\[
\sum_{i \in s} f(i) \in \operatorname{im}(\partial_1).
\]
\end{lemma}

\begin{proof}
\leanok

The range of a linear map is a submodule, and submodules are closed under finite sums. We apply the submodule sum membership property to each element $f(i)$, which by assumption lies in the range.
\end{proof}

\begin{lemma}[Scalar Multiple in Range]
\label{lem:smul_mem_range}
\lean{GaugingLDPC.smul_mem_range}
\leanok

If $c \in \operatorname{im}(\partial_1)$, then $a \cdot c \in \operatorname{im}(\partial_1)$ for any scalar $a \in A$.
\end{lemma}

\begin{proof}
\leanok

By the membership characterization of range, from $c \in \operatorname{im}(\partial_1)$ we obtain a 1-chain $\gamma$ with $\partial_1(\gamma) = c$. We use $a \cdot \gamma$ as a witness. By linearity of the boundary map: $\partial_1(a \cdot \gamma) = a \cdot \partial_1(\gamma) = a \cdot c$.
\end{proof}

\begin{lemma}[Charge-Neutral in Range of Boundary]
\label{lem:charge_neutral_mem_range}
\lean{GaugingLDPC.charge_neutral_mem_range}
\leanok
\uses{def:is_connected, def:is_charge_neutral, lem:charge_neutral_decomposition, lem:sum_mem_range, lem:smul_mem_range, lem:vertex_minus_root_mem_range}

In a connected graph $G$, every charge-neutral 0-chain is in the range of the boundary map.
\end{lemma}

\begin{proof}
\leanok
\uses{def:is_connected, lem:charge_neutral_decomposition, lem:sum_mem_range, lem:smul_mem_range, lem:vertex_minus_root_mem_range}

Let $c$ be a charge-neutral 0-chain in a connected graph $G$. Since $G$ is connected, the vertex set is nonempty, so we may choose a root vertex $r$.

By Lemma~\ref{lem:charge_neutral_decomposition}, we have:
\[
c = \sum_{v \in V} c(v) \cdot (\delta_v - \delta_r).
\]

We apply Lemma~\ref{lem:sum_mem_range} to show this sum is in $\operatorname{im}(\partial_1)$. For each $v \in V$, we need to show $c(v) \cdot (\delta_v - \delta_r) \in \operatorname{im}(\partial_1)$.

By Lemma~\ref{lem:vertex_minus_root_mem_range}, we have $\delta_v - \delta_r \in \operatorname{im}(\partial_1)$. Then by Lemma~\ref{lem:smul_mem_range}, the scalar multiple $c(v) \cdot (\delta_v - \delta_r) \in \operatorname{im}(\partial_1)$.
\end{proof}

\begin{lemma}[Kernel of Augmentation in Range of Boundary]
\label{lem:ker_augmentation_le_range_boundary}
\lean{GaugingLDPC.ker_augmentation_le_range_boundary}
\leanok
\uses{def:is_connected, lem:charge_neutral_mem_range}

For a connected graph $G$:
\[
\ker(\epsilon) \subseteq \operatorname{im}(\partial_1).
\]
\end{lemma}

\begin{proof}
\leanok
\uses{lem:charge_neutral_mem_range}

Let $c \in \ker(\epsilon)$. By the kernel membership characterization, $\epsilon(c) = 0$, so $c$ is charge-neutral. By Lemma~\ref{lem:charge_neutral_mem_range}, $c \in \operatorname{im}(\partial_1)$.
\end{proof}

\begin{theorem}[Vanishing of Reduced Zeroth Homology for Connected Graphs]
\label{thm:vanishing_of__reduced__zeroth__homology_for__connected__graphs}
\lean{GaugingLDPC.reducedH0_vanishes}
\leanok
\uses{def:is_connected, thm:im_boundary_le_ker_augmentation, lem:ker_augmentation_le_range_boundary}

Let $G$ be a connected graph and let $A$ be a field. Consider the augmented chain complex:
\[
C_1(G, A) \xrightarrow{\partial_1} C_0(G, A) \xrightarrow{\epsilon} A \to 0
\]
where $\partial_1$ is the boundary map and $\epsilon$ is the augmentation map (sum of coefficients). Then the reduced zeroth homology vanishes:
\[
\tilde{H}_0(G, A) := \frac{\ker(\epsilon)}{\operatorname{im}(\partial_1)} = 0.
\]
Equivalently: $\ker(\epsilon) = \operatorname{im}(\partial_1)$.

\textbf{Physical interpretation}: This states that charge neutrality (total charge zero, i.e., $\chi \in \ker(\epsilon)$) implies the charge distribution is exact (can be written as the boundary of a 1-chain).
\end{theorem}

\begin{proof}
\leanok
\uses{thm:im_boundary_le_ker_augmentation, lem:ker_augmentation_le_range_boundary}

We prove equality of the two submodules by showing inclusion in both directions.

For $\ker(\epsilon) \subseteq \operatorname{im}(\partial_1)$: This follows from Lemma~\ref{lem:ker_augmentation_le_range_boundary}.

For $\operatorname{im}(\partial_1) \subseteq \ker(\epsilon)$: This follows from Theorem~\ref{thm:im_boundary_le_ker_augmentation}.

By antisymmetry of the subset relation on submodules, we conclude $\ker(\epsilon) = \operatorname{im}(\partial_1)$.
\end{proof}

\begin{corollary}[Kernel Equals Range for Connected Graphs]
\label{cor:ker_augmentation_eq_range_boundary}
\lean{GaugingLDPC.ker_augmentation_eq_range_boundary}
\leanok
\uses{thm:vanishing_of__reduced__zeroth__homology_for__connected__graphs}

For a connected graph $G$:
\[
\ker(\epsilon) = \operatorname{im}(\partial_1).
\]
\end{corollary}

\begin{proof}
\leanok
\uses{thm:vanishing_of__reduced__zeroth__homology_for__connected__graphs}

This is an immediate restatement of Theorem~\ref{thm:vanishing_of__reduced__zeroth__homology_for__connected__graphs}.
\end{proof}

\begin{corollary}[Charge-Neutral Iff in Range of Boundary]
\label{cor:charge_neutral_iff_mem_range}
\lean{GaugingLDPC.chargeNeutral_iff_mem_range}
\leanok
\uses{def:is_connected, def:is_charge_neutral, lem:is_charge_neutral_iff_mem_ker, thm:vanishing_of__reduced__zeroth__homology_for__connected__graphs}

For a connected graph $G$ and a 0-chain $c$:
\[
c \text{ is charge-neutral} \iff c \in \operatorname{im}(\partial_1).
\]
\end{corollary}

\begin{proof}
\leanok
\uses{lem:is_charge_neutral_iff_mem_ker, thm:vanishing_of__reduced__zeroth__homology_for__connected__graphs}

By Lemma~\ref{lem:is_charge_neutral_iff_mem_ker}, $c$ is charge-neutral if and only if $c \in \ker(\epsilon)$. By Theorem~\ref{thm:vanishing_of__reduced__zeroth__homology_for__connected__graphs}, $\ker(\epsilon) = \operatorname{im}(\partial_1)$, giving the result.
\end{proof}

\begin{lemma}[Augmentation of Boundary is Zero]
\label{lem:augmentation_map_of_boundary}
\lean{GaugingLDPC.augmentationMap_of_boundary}
\leanok

For any 1-chain $c \in C_1(G, A)$:
\[
\epsilon(\partial_1(c)) = 0.
\]
\end{lemma}

\begin{proof}
\leanok

This follows from the chain complex property $\epsilon \circ \partial_1 = 0$ established in the chain complex notation.
\end{proof}

\begin{corollary}[Quotient is Trivial]
\label{cor:quotient_trivial}
\lean{GaugingLDPC.quotient_trivial}
\leanok
\uses{def:is_connected, thm:vanishing_of__reduced__zeroth__homology_for__connected__graphs}

For a connected graph $G$, the quotient $\ker(\epsilon)/\operatorname{im}(\partial_1)$ is trivial. Formally, the comap of $\operatorname{im}(\partial_1)$ along the inclusion of $\ker(\epsilon)$ equals the entire kernel:
\[
(\operatorname{im}(\partial_1)) \cap \ker(\epsilon) = \ker(\epsilon).
\]
\end{corollary}

\begin{proof}
\leanok
\uses{thm:vanishing_of__reduced__zeroth__homology_for__connected__graphs}

By Theorem~\ref{thm:vanishing_of__reduced__zeroth__homology_for__connected__graphs}, $\ker(\epsilon) = \operatorname{im}(\partial_1)$. The comap of a submodule along the inclusion of itself is the entire submodule, which equals the top element.
\end{proof}

\begin{theorem}[Single Vertex Case]
\label{thm:single_vertex_case}
\lean{GaugingLDPC.single_vertex_case}
\leanok

For a single vertex graph with no edges:
\[
\ker(\epsilon) = \operatorname{im}(\partial_1) = \{0\}.
\]
\end{theorem}

\begin{proof}
\leanok

With no edges, any finitely supported function $g : E \to A$ must be zero (since $E$ is empty). For any $g : E \to_0 A$, by extensionality, $g = 0$ because for any $e \in E$, the empty type has no elements.

Therefore the boundary map sends everything to zero: for any $g$, we have $\partial_1(g) = 0$ by the definition of the boundary map applied to the zero function.

Thus $\operatorname{im}(\partial_1) = \{0\}$.

For the kernel: on a single-vertex graph, the augmentation map is injective. If $\epsilon(c_1) = \epsilon(c_2)$, then by the sum formula and the uniqueness of the single vertex, $c_1 = c_2$. By extensionality at the unique vertex, $c_1 = c_2$.

Thus $\ker(\epsilon) = \{0\}$.

Both equal $\{0\}$, establishing the equality.
\end{proof}

\begin{lemma}[Membership in Kernel of Augmentation]
\label{lem:mem_ker_augmentation_iff}
\lean{GaugingLDPC.mem_ker_augmentation_iff}
\leanok

A 0-chain $c$ is in the kernel of the augmentation map if and only if the sum of its coefficients is zero:
\[
c \in \ker(\epsilon) \iff \sum_{v \in V} c(v) = 0.
\]
\end{lemma}

\begin{proof}
\leanok

By simplification using the kernel membership definition and the formula $\epsilon(c) = \sum_{v \in V} c(v)$, these conditions are definitionally equal.
\end{proof}

\begin{lemma}[Membership in Range of Boundary]
\label{lem:mem_range_boundary_iff}
\lean{GaugingLDPC.mem_range_boundary_iff}
\leanok

A 0-chain $c$ is in the range of the boundary map if and only if there exists a 1-chain $\gamma$ mapping to it:
\[
c \in \operatorname{im}(\partial_1) \iff \exists \gamma \in C_1(G, A), \; \partial_1(\gamma) = c.
\]
\end{lemma}

\begin{proof}
\leanok

By simplification using the range membership definition, these conditions are definitionally equal.
\end{proof}

\begin{corollary}[Sum Zero Iff Exists Preimage]
\label{cor:sum_zero_iff_exists_preimage}
\lean{GaugingLDPC.sum_zero_iff_exists_preimage}
\leanok
\uses{def:is_connected, lem:mem_ker_augmentation_iff, lem:mem_range_boundary_iff, thm:vanishing_of__reduced__zeroth__homology_for__connected__graphs}

For a connected graph $G$ and a 0-chain $c$:
\[
\sum_{v \in V} c(v) = 0 \iff \exists \gamma \in C_1(G, A), \; \partial_1(\gamma) = c.
\]
\end{corollary}

\begin{proof}
\leanok
\uses{lem:mem_ker_augmentation_iff, lem:mem_range_boundary_iff, thm:vanishing_of__reduced__zeroth__homology_for__connected__graphs}

By Lemma~\ref{lem:mem_ker_augmentation_iff}, the sum condition is equivalent to $c \in \ker(\epsilon)$. By Lemma~\ref{lem:mem_range_boundary_iff}, the existence condition is equivalent to $c \in \operatorname{im}(\partial_1)$. By Theorem~\ref{thm:vanishing_of__reduced__zeroth__homology_for__connected__graphs}, these submodules are equal, completing the proof.
\end{proof}

%--- Lem_3: Charge Neutrality of Symmetrized Operators ---
\begin{definition}[Uniform Group Tuple]
\label{def:uniform_group_tuple}
\lean{GaugingLDPC.uniformGroupTuple}
\leanok

The \emph{uniform group tuple} assigns the same group element $h \in \mathbb{Z}_p$ to every vertex. Given $h \in \mathbb{Z}_p$, define:
\[
\mathbf{h} : C_0 \to \mathbb{Z}_p, \quad \mathbf{h}(v) = h \text{ for all } v \in C_0.
\]
This represents the global symmetry action $T(h)$ acting uniformly on all sites.
\end{definition}

\begin{proof}
\leanok

This is a definition, so no proof is needed.
\end{proof}

\begin{definition}[Total Character Value]
\label{def:total_character_value}
\lean{GaugingLDPC.totalCharacterValue}
\leanok
\uses{def:uniform_group_tuple}

The \emph{total character value} for a charge distribution $\boldsymbol{\chi}$ at a uniform tuple $\mathbf{h} = (h, h, \ldots, h)$ is:
\[
\chi_{\mathrm{tot}}(h) := \prod_{v \in C_0} \chi_v(h).
\]
For $p$-th roots of unity, when $\chi_v = \chi_{k_v}$, this equals $\exp\bigl(2\pi i \cdot h \cdot (\sum_v k_v) / p\bigr)$.
\end{definition}

\begin{proof}
\leanok

This is a definition, so no proof is needed.
\end{proof}

\begin{lemma}[Total Character Value at Zero]
\label{lem:total_character_value_at_zero}
\lean{GaugingLDPC.totalCharacterValue.at_zero}
\leanok
\uses{def:total_character_value}

For any charge distribution $\boldsymbol{\chi}$, we have $\chi_{\mathrm{tot}}(0) = 1$.
\end{lemma}

\begin{proof}
\leanok
\uses{def:total_character_value, def:uniform_group_tuple}
By simplification, the uniform tuple at zero equals the zero group tuple, and the multi-site character value at zero equals $1$.
\end{proof}

\begin{lemma}[Total Character Value Multiplicativity]
\label{lem:total_character_value_mul}
\lean{GaugingLDPC.totalCharacterValue.mul_property}
\leanok
\uses{def:total_character_value}

The total character value is multiplicative in $h$:
\[
\chi_{\mathrm{tot}}(h_1 + h_2) = \chi_{\mathrm{tot}}(h_1) \cdot \chi_{\mathrm{tot}}(h_2).
\]
\end{lemma}

\begin{proof}
\leanok
\uses{def:total_character_value}
This follows directly from the multiplicativity property of the multi-site character value.
\end{proof}

\begin{lemma}[Total Character Value is Root of Unity]
\label{lem:total_character_value_pow}
\lean{GaugingLDPC.totalCharacterValue.pow_eq_one}
\leanok
\uses{def:total_character_value}

The total character value is a $p$-th root of unity:
\[
\chi_{\mathrm{tot}}(h)^p = 1.
\]
\end{lemma}

\begin{proof}
\leanok
\uses{def:total_character_value}
Rewriting using the product formula $\chi_{\mathrm{tot}}(h) = \prod_v \chi_v(h)$, we have $\chi_{\mathrm{tot}}(h)^p = \prod_v \chi_v(h)^p$. By character properties, each $\chi_v(h)^p = 1$, so the product equals $1$.
\end{proof}

\begin{definition}[Charge Neutral Distribution]
\label{def:is_charge_neutral_dist}
\lean{GaugingLDPC.isChargeNeutralDist}
\leanok
\uses{def:total_character_value}

A charge distribution $\boldsymbol{\chi}$ has \emph{total charge zero} (is charge-neutral) if the total character value equals $1$ for all $h$:
\[
\chi_{\mathrm{tot}}(h) = 1 \quad \text{for all } h \in \mathbb{Z}_p.
\]
This means $\chi_{\mathrm{tot}} = 0$, i.e., $\sum_{v \in C_0} k_v \equiv 0 \pmod{p}$ in the index representation.
\end{definition}

\begin{proof}
\leanok

This is a definition, so no proof is needed.
\end{proof}

\begin{definition}[Global Symmetry Action]
\label{def:global_symmetry_action}
\lean{GaugingLDPC.globalSymmetryAction}
\leanok
\uses{def:uniform_group_tuple}

The \emph{global symmetry action} applies the same automorphism at every vertex:
\[
T(h) := \prod_{v \in C_0} \varphi_h^{(v)} = \varphi_{(h, h, \ldots, h)}.
\]
Given a multi-site symmetry action $\sigma$ and $h \in \mathbb{Z}_p$, define $T(h)(O) := \sigma.\mathrm{productAction}(\mathbf{h}, O)$ where $\mathbf{h}$ is the uniform group tuple.
\end{definition}

\begin{proof}
\leanok

This is a definition, so no proof is needed.
\end{proof}

\begin{lemma}[Global Invariance of Symmetrized Operator]
\label{lem:symmetrized_globally_invariant}
\lean{GaugingLDPC.symmetrizedOperatorMultiSite_globallyInvariant}
\leanok
\uses{def:symmetrized__operator_(_orbit__average), def:global_symmetry_action}

The multi-site symmetrized operator is invariant under the global symmetry action:
\[
\mathrm{Ad}_{T(h)}(\overline{S}) = \overline{S}.
\]
\end{lemma}

\begin{proof}
\leanok
\uses{def:symmetrized__operator_(_orbit__average), def:global_symmetry_action, def:uniform_group_tuple}
Since the symmetry group is Abelian, applying $T(h)$ to $\overline{S} = \frac{1}{|A|^n} \sum_g \varphi_g(S)$ just shifts the sum by $h$ in each component.

Unfolding the definitions of $\overline{S}$ and the global action, we apply the automorphism $\varphi_{(h,\ldots,h)}$ to the scalar-multiplied sum. By the hypothesis that scalar multiplication is fixed, $\varphi_{(h,\ldots,h)}$ preserves the normalization factor. Distributing over the sum and using the group property $\varphi_{(h,\ldots,h)} \circ \varphi_g = \varphi_{(h,\ldots,h)+g}$, we obtain a sum over shifted tuples.

Define the shift bijection $g \mapsto h + g$ (component-wise). This reindexes the sum without changing its value, proving the invariance.
\end{proof}

\begin{lemma}[Charge Projection of Symmetrized Operator Vanishes for Non-Neutral Charges]
\label{lem:charge__neutrality_of__symmetrized__operators}
\lean{GaugingLDPC.chargeProjection_of_symmetrized_eq_zero}
\leanok
\uses{def:symmetrized__operator_(_orbit__average), lem:completeness_of__charge__expansion, lem:covariance__property_of__charge__components}

For a symmetrized operator $\overline{S}$ and a charge distribution $\boldsymbol{\chi}$ with non-zero total charge, the charge-$\boldsymbol{\chi}$ component vanishes:
\[
[\![\overline{S}]\!]_{\boldsymbol{\chi}} = 0 \quad \text{when } \boldsymbol{\chi} \text{ is not charge-neutral}.
\]
\end{lemma}

\begin{proof}
\leanok
\uses{def:symmetrized__operator_(_orbit__average), lem:covariance__property_of__charge__components, def:is_charge_neutral_dist}

Since $\boldsymbol{\chi}$ is not charge-neutral, there exists $h \in \mathbb{Z}_p$ with $\chi_{\mathrm{tot}}(h) \neq 1$. Let $P = [\![\overline{S}]\!]_{\boldsymbol{\chi}}$ denote the charge projection.

Expanding the definition:
\[
P = [\![\overline{S}]\!]_{\boldsymbol{\chi}} = \frac{1}{|A|^n} \sum_g \overline{\chi(g)} \cdot \varphi_g(\overline{S}).
\]

Substituting $\overline{S} = \frac{1}{|A|^n} \sum_{g'} \varphi_{g'}(S)$:
\[
P = \frac{1}{|A|^{2n}} \sum_g \sum_{g'} \overline{\chi(g)} \cdot \varphi_g(\varphi_{g'}(S)).
\]

Using the group property $\varphi_g \circ \varphi_{g'} = \varphi_{g+g'}$:
\[
P = \frac{1}{|A|^{2n}} \sum_g \sum_{g'} \overline{\chi(g)} \cdot \varphi_{g+g'}(S).
\]

For each $g$, we reindex by $k = g + g'$, so $g'$ ranges over all tuples as $k$ does:
\[
P = \frac{1}{|A|^{2n}} \sum_k \left(\sum_g \overline{\chi(g)}\right) \cdot \varphi_k(S).
\]

The inner sum is the character orthogonality sum:
\[
\sum_g \overline{\chi(g)} = \sum_g \prod_v \overline{\chi_v(g_v)} = \prod_v \left(\sum_{g_v} \overline{\chi_v(g_v)}\right).
\]

By character orthogonality, $\sum_{g_v} \overline{\chi_v(g_v)} = |A| \cdot \delta_{\chi_v, 1}$. Therefore:
\[
\sum_g \overline{\chi(g)} = |A|^n \cdot \mathbf{1}_{\boldsymbol{\chi} = \text{trivial}}.
\]

Since $\boldsymbol{\chi} \neq \text{trivial}$ (because non-neutral distributions have at least one non-trivial local charge), the sum equals $0$. Hence $P = 0$.
\end{proof}

\begin{theorem}[Charge Neutrality of Symmetrized Operators]
\label{thm:charge_neutrality_symmetrized}
\lean{GaugingLDPC.chargeNeutrality_symmetrized}
\leanok
\uses{def:symmetrized__operator_(_orbit__average), def:is_charge_neutral_dist, lem:charge__neutrality_of__symmetrized__operators}

The symmetrized operator $\overline{S}$ has a charge expansion containing only charge-neutral components:
\[
[\![\overline{S}]\!]_{\boldsymbol{\chi}} = 0 \quad \text{unless } \boldsymbol{\chi} \text{ is charge-neutral.}
\]
Equivalently, for symmetrized operators, only the trivial charge sector survives.
\end{theorem}

\begin{proof}
\leanok
\uses{lem:charge__neutrality_of__symmetrized__operators}
This follows directly from Lemma~\ref{lem:charge__neutrality_of__symmetrized__operators}: for any charge distribution $\boldsymbol{\chi}$ that is not charge-neutral, the charge projection $[\![\overline{S}]\!]_{\boldsymbol{\chi}} = 0$.
\end{proof}

\begin{lemma}[Only Trivial Component Survives]
\label{lem:charge_projection_trivial_only}
\lean{GaugingLDPC.chargeProjection_of_symmetrized_trivial_only}
\leanok
\uses{def:symmetrized__operator_(_orbit__average)}

The charge projection of the symmetrized operator vanishes for any non-trivial charge distribution, regardless of charge neutrality:
\[
[\![\overline{S}]\!]_{\boldsymbol{\chi}} = 0 \quad \text{for all } \boldsymbol{\chi} \neq \mathbf{1}.
\]
\end{lemma}

\begin{proof}
\leanok
\uses{def:symmetrized__operator_(_orbit__average)}
The proof follows the same approach as Lemma~\ref{lem:charge__neutrality_of__symmetrized__operators}. Unfolding the definitions and using the composition property $\varphi_g \circ \varphi_{g'} = \varphi_{g+g'}$, we rearrange and reindex the sums.

The key step is the dual orthogonality relation: for the product of character conjugate values,
\[
\sum_{g \in A^{C_0}} \overline{\chi(g)} = \begin{cases} |A|^n & \text{if } \boldsymbol{\chi} = \mathbf{1} \\ 0 & \text{otherwise.} \end{cases}
\]

This follows from the product structure $\sum_g \prod_v \overline{\chi_v(g_v)} = \prod_v \sum_{g_v} \overline{\chi_v(g_v)}$, where each local sum equals $|A| \cdot \delta_{\chi_v, 1}$ by character orthogonality.

Since $\boldsymbol{\chi} \neq \mathbf{1}$ means some $\chi_v \neq 1$, the product contains a zero factor, so $[\![\overline{S}]\!]_{\boldsymbol{\chi}} = 0$.
\end{proof}

\begin{theorem}[Symmetrized Operator Equals Trivial Charge Projection]
\label{thm:symmetrized_eq_trivial_projection}
\lean{GaugingLDPC.symmetrizedOperator_eq_trivialChargeProjection}
\leanok
\uses{def:symmetrized__operator_(_orbit__average), lem:completeness_of__charge__expansion, lem:charge_projection_trivial_only}

The symmetrized operator equals its trivial charge component:
\[
\overline{S} = [\![\overline{S}]\!]_{\mathbf{1}}.
\]
\end{theorem}

\begin{proof}
\leanok
\uses{lem:completeness_of__charge__expansion, lem:charge_projection_trivial_only}
By completeness (Lemma~\ref{lem:completeness_of__charge__expansion}), $\overline{S} = \sum_{\boldsymbol{\chi}} [\![\overline{S}]\!]_{\boldsymbol{\chi}}$.

Split the sum into the trivial part and non-trivial parts:
\[
\sum_{\boldsymbol{\chi}} [\![\overline{S}]\!]_{\boldsymbol{\chi}} = [\![\overline{S}]\!]_{\mathbf{1}} + \sum_{\boldsymbol{\chi} \neq \mathbf{1}} [\![\overline{S}]\!]_{\boldsymbol{\chi}}.
\]

By Lemma~\ref{lem:charge_projection_trivial_only}, each term in the second sum is zero. Therefore $\overline{S} = [\![\overline{S}]\!]_{\mathbf{1}}$.
\end{proof}

\begin{corollary}[Symmetrized Operator Charge Expansion]
\label{cor:symmetrized_charge_expansion}
\lean{GaugingLDPC.symmetrizedOperator_chargeExpansion}
\leanok
\uses{def:symmetrized__operator_(_orbit__average), lem:completeness_of__charge__expansion, thm:symmetrized_eq_trivial_projection}

For symmetrized operators, the charge expansion is trivial:
\[
\sum_{\boldsymbol{\chi}} [\![\overline{S}]\!]_{\boldsymbol{\chi}} = [\![\overline{S}]\!]_{\mathbf{1}}.
\]
\end{corollary}

\begin{proof}
\leanok
\uses{lem:completeness_of__charge__expansion, thm:symmetrized_eq_trivial_projection}
By completeness, the left side equals $\overline{S}$. By Theorem~\ref{thm:symmetrized_eq_trivial_projection}, $\overline{S} = [\![\overline{S}]\!]_{\mathbf{1}}$.
\end{proof}

\begin{theorem}[Double Symmetrization is Idempotent]
\label{thm:symmetrized_idempotent}
\lean{GaugingLDPC.symmetrizedOperator_idempotent_via_charge}
\leanok
\uses{def:symmetrized__operator_(_orbit__average)}

Double symmetrization is idempotent:
\[
\overline{\overline{S}} = \overline{S}.
\]
\end{theorem}

\begin{proof}
\leanok
\uses{def:symmetrized__operator_(_orbit__average)}
Unfolding the definition of $\overline{S}$, we have:
\[
\overline{\overline{S}} = \frac{1}{|A|^n} \sum_g \varphi_g\left(\frac{1}{|A|^n} \sum_{g'} \varphi_{g'}(S)\right).
\]

Distributing the automorphism (which fixes scalars) and the sum:
\[
= \frac{1}{|A|^{2n}} \sum_g \sum_{g'} \varphi_g(\varphi_{g'}(S)) = \frac{1}{|A|^{2n}} \sum_g \sum_{g'} \varphi_{g+g'}(S).
\]

For each $g'$, define the shift bijection $g \mapsto g + g'$. As $g$ ranges over all tuples, so does $g + g'$:
\[
= \frac{1}{|A|^{2n}} \sum_{g'} \sum_k \varphi_k(S) = \frac{1}{|A|^{2n}} \cdot |A|^n \cdot \sum_k \varphi_k(S).
\]

Simplifying:
\[
= \frac{1}{|A|^n} \sum_k \varphi_k(S) = \overline{S}.
\]
\end{proof}

%--- Def_4: Gauging (Decoration Map) ---
\begin{definition}[Boundary Map over $\mathbb{Z}_p$]
\label{def:boundary_map_z_mod}
\lean{GaugingLDPC.boundaryMapZMod}
\leanok
\uses{rem:chain__complex__notation}

Let $G = (V, E)$ be an oriented graph with vertices $V$ (sites) and edges $E$ (gauge qudits). The \textbf{boundary map} $\partial_1: C_1 \to C_0$ over $\mathbb{Z}_p$ is the linear map
\[
\partial_1 : (E \to_0 \mathbb{Z}_p) \to_{\mathbb{Z}_p\text{-lin}} (V \to_0 \mathbb{Z}_p)
\]
defined by sending each edge $e$ to $\operatorname{target}(e) - \operatorname{source}(e)$. Formally, for a 1-chain $\alpha = \sum_e \alpha_e \cdot e$:
\[
\partial_1(\alpha) = \sum_e \alpha_e \cdot (\delta_{\operatorname{target}(e)} - \delta_{\operatorname{source}(e)})
\]
where $\delta_v$ denotes the indicator function at vertex $v$.
\end{definition}

\begin{definition}[Exact Charge Submodule]
\label{def:exact_charge_submodule}
\lean{GaugingLDPC.ExactChargeSubmodule}
\leanok
\uses{def:boundary_map_z_mod}

The \textbf{exact charge submodule} is defined as the image of the boundary map:
\[
\partial C_1 := \operatorname{im}(\partial_1) \subseteq C_0
\]
Elements $\chi \in \partial C_1$ are called \textbf{exact charge distributions} and satisfy $\chi = \partial_1(\alpha)$ for some 1-chain $\alpha \in C_1$. These are precisely the charges that can be ``gauged away'' by decoration.
\end{definition}

\begin{definition}[Exact Charge]
\label{def:is_exact_charge}
\lean{GaugingLDPC.IsExactCharge}
\leanok
\uses{def:exact_charge_submodule}

A charge distribution $\chi : V \to_0 \mathbb{Z}_p$ is \textbf{exact} if $\chi \in \partial C_1 = \operatorname{im}(\partial_1)$.
\end{definition}

\begin{theorem}[Characterization of Exact Charges]
\label{thm:is_exact_charge_iff}
\lean{GaugingLDPC.isExactCharge_iff}
\leanok
\uses{def:is_exact_charge, def:boundary_map_z_mod}

A charge distribution $\chi$ is exact if and only if there exists a 1-chain $\alpha : E \to_0 \mathbb{Z}_p$ such that $\partial_1(\alpha) = \chi$.
\end{theorem}

\begin{proof}
\leanok

This follows directly from the definition of the image of a linear map (LinearMap.mem\_range).
\end{proof}

\begin{definition}[Spanning Basis]
\label{def:spanning_basis}
\lean{GaugingLDPC.SpanningBasis}
\leanok
\uses{def:exact_charge_submodule, def:boundary_map_z_mod}

A \textbf{spanning basis} for the gauging construction is a structure consisting of:
\begin{itemize}
\item A submodule $T_1 \subseteq C_1$ (typically arising from a spanning tree of the graph)
\item A restricted boundary map $\partial_1|_{T_1} : T_1 \to \partial C_1$
\item The property that the restriction equals the original boundary on $T_1$: for all $\alpha \in T_1$, $\partial_1|_{T_1}(\alpha) = \partial_1(\alpha)$
\item Surjectivity: $\partial_1|_{T_1}$ is surjective ($T_1$ generates all exact charges)
\item Injectivity: $\partial_1|_{T_1}$ is injective (unique preimages)
\end{itemize}

The surjectivity and injectivity together ensure that $\partial_1|_{T_1} : T_1 \to \partial C_1$ is bijective, providing unique lifting of exact charges.
\end{definition}

\begin{theorem}[Bijectivity of Restricted Boundary]
\label{thm:spanning_basis_bijective}
\lean{GaugingLDPC.SpanningBasis.bijective}
\leanok
\uses{def:spanning_basis}

For a spanning basis $B$, the restricted boundary map $\partial_1|_{T_1}$ is bijective.
\end{theorem}

\begin{proof}
\leanok
\uses{def:spanning_basis}

This follows directly from the injectivity and surjectivity conditions in the definition of a spanning basis.
\end{proof}

\begin{definition}[Alpha of Chi]
\label{def:alpha_of_chi}
\lean{GaugingLDPC.SpanningBasis.alphaOfChi}
\leanok
\uses{def:spanning_basis, def:exact_charge_submodule}

Given a spanning basis $B$ and an exact charge $\chi \in \partial C_1$, define $\alpha(\chi) \in C_1$ as the unique element of $T_1$ satisfying $\partial_1(\alpha) = \chi$. Formally:
\[
\alpha(\chi) := (\partial_1|_{T_1})^{-1}(\chi)
\]
This is the key map for the gauging construction, extracting the unique 1-chain in $T_1$ that produces a given exact charge under the boundary map.
\end{definition}

\begin{lemma}[Alpha of Chi Membership]
\label{lem:alpha_of_chi_mem}
\lean{GaugingLDPC.SpanningBasis.alphaOfChi_mem}
\leanok
\uses{def:alpha_of_chi, def:spanning_basis}

For any exact charge $\chi \in \partial C_1$, the element $\alpha(\chi)$ lies in $T_1$.
\end{lemma}

\begin{proof}
\leanok
\uses{def:alpha_of_chi}

By definition, $\alpha(\chi)$ is constructed as the value of the inverse function of the restricted boundary map applied to $\chi$, which by construction returns an element of $T_1$.
\end{proof}

\begin{lemma}[Alpha of Chi Specification]
\label{lem:alpha_of_chi_spec}
\lean{GaugingLDPC.SpanningBasis.alphaOfChi_spec}
\leanok
\uses{def:alpha_of_chi, def:boundary_map_z_mod}

For any exact charge $\chi \in \partial C_1$, we have $\partial_1(\alpha(\chi)) = \chi$.
\end{lemma}

\begin{proof}
\leanok
\uses{def:alpha_of_chi, def:spanning_basis}

We unfold the definition of $\alpha(\chi)$. Since the restricted boundary map is surjective, the inverse function is a right inverse, meaning $\partial_1|_{T_1}((\partial_1|_{T_1})^{-1}(\chi)) = \chi$. The restriction property then gives $\partial_1(\alpha(\chi)) = \chi$.
\end{proof}

\begin{lemma}[Uniqueness of Alpha]
\label{lem:alpha_of_chi_unique}
\lean{GaugingLDPC.SpanningBasis.alphaOfChi_unique}
\leanok
\uses{def:alpha_of_chi, def:boundary_map_z_mod, def:spanning_basis}

If $\alpha' \in T_1$ satisfies $\partial_1(\alpha') = \chi$ for an exact charge $\chi$, then $\alpha' = \alpha(\chi)$.
\end{lemma}

\begin{proof}
\leanok
\uses{def:alpha_of_chi, def:spanning_basis}

Suppose $\alpha' \in T_1$ with $\partial_1(\alpha') = \chi$. By the restriction property, $\partial_1|_{T_1}(\alpha') = \chi$. Since the restricted boundary is injective, the inverse function is a left inverse. Therefore $(\partial_1|_{T_1})^{-1}(\partial_1|_{T_1}(\alpha')) = \alpha'$. Rewriting using $\partial_1|_{T_1}(\alpha') = \chi$ gives $\alpha(\chi) = \alpha'$.
\end{proof}

\begin{lemma}[Alpha of Zero]
\label{lem:alpha_of_chi_zero}
\lean{GaugingLDPC.SpanningBasis.alphaOfChi_zero}
\leanok
\uses{def:alpha_of_chi, def:boundary_map_z_mod}

For the zero exact charge, $\alpha(0) = 0$.
\end{lemma}

\begin{proof}
\leanok
\uses{def:alpha_of_chi, lem:alpha_of_chi_unique}

Since $0 \in T_1$ (as $T_1$ is a submodule) and $\partial_1(0) = 0$ (as $\partial_1$ is a linear map), the uniqueness result implies $\alpha(0) = 0$.
\end{proof}

\begin{definition}[Gauge Z-Basis]
\label{def:gauge_z_basis}
\lean{GaugingLDPC.GaugeZBasis}
\leanok

A \textbf{gauge Z-basis} for a prime $p$ and edge set $E$ consists of:
\begin{itemize}
\item A function $Z : E \to \mathcal{O}_{\text{gauge}}$ assigning to each edge the generalized Pauli-$Z$ operator on the gauge qudit at that edge
\item The periodicity condition: $Z_e^p = 1$ for all edges $e$
\end{itemize}
\end{definition}

\begin{definition}[Z Power]
\label{def:z_pow}
\lean{GaugingLDPC.GaugeZBasis.ZPow}
\leanok
\uses{def:gauge_z_basis}

For a gauge Z-basis $\mathcal{Z}$, an edge $e$, and an exponent $k \in \mathbb{Z}_p$, define:
\[
\mathcal{Z}_e^k := (\mathcal{Z}(e))^{\bar{k}}
\]
where $\bar{k}$ denotes the natural number representative of $k$ in $\{0, 1, \ldots, p-1\}$.
\end{definition}

\begin{lemma}[Z Power Zero]
\label{lem:z_pow_zero}
\lean{GaugingLDPC.GaugeZBasis.ZPow_zero}
\leanok
\uses{def:z_pow}

For any edge $e$, $\mathcal{Z}_e^0 = 1$.
\end{lemma}

\begin{proof}
\leanok
\uses{def:z_pow}

By simplification: $\mathcal{Z}_e^0 = (\mathcal{Z}(e))^{\bar{0}} = (\mathcal{Z}(e))^0 = 1$.
\end{proof}

\begin{lemma}[Z Power Periodic]
\label{lem:z_pow_periodic}
\lean{GaugingLDPC.GaugeZBasis.ZPow_periodic}
\leanok
\uses{def:gauge_z_basis}

For any edge $e$ and natural number $k$, $(\mathcal{Z}(e))^k = (\mathcal{Z}(e))^{k \bmod p}$.
\end{lemma}

\begin{proof}
\leanok
\uses{def:gauge_z_basis}

Write $k = (k \div p) \cdot p + (k \bmod p)$. Then:
\[
(\mathcal{Z}(e))^k = (\mathcal{Z}(e))^{(k \bmod p) + (k \div p) \cdot p} = (\mathcal{Z}(e))^{k \bmod p} \cdot ((\mathcal{Z}(e))^p)^{k \div p} = (\mathcal{Z}(e))^{k \bmod p} \cdot 1^{k \div p} = (\mathcal{Z}(e))^{k \bmod p}
\]
using the periodicity condition $Z_e^p = 1$.
\end{proof}

\begin{lemma}[Z Power Additive]
\label{lem:z_pow_add}
\lean{GaugingLDPC.GaugeZBasis.ZPow_add}
\leanok
\uses{def:z_pow, lem:z_pow_periodic}

For any edge $e$ and exponents $k_1, k_2 \in \mathbb{Z}_p$:
\[
\mathcal{Z}_e^{k_1 + k_2} = \mathcal{Z}_e^{k_1} \cdot \mathcal{Z}_e^{k_2}
\]
\end{lemma}

\begin{proof}
\leanok
\uses{def:z_pow, lem:z_pow_periodic}

Unfolding the definition, we have $\mathcal{Z}_e^{k_1 + k_2} = (\mathcal{Z}(e))^{\overline{k_1 + k_2}}$ and $\mathcal{Z}_e^{k_1} \cdot \mathcal{Z}_e^{k_2} = (\mathcal{Z}(e))^{\bar{k_1}} \cdot (\mathcal{Z}(e))^{\bar{k_2}} = (\mathcal{Z}(e))^{\bar{k_1} + \bar{k_2}}$. By periodicity, both expressions equal $(\mathcal{Z}(e))^{(\bar{k_1} + \bar{k_2}) \bmod p}$. Since $\overline{k_1 + k_2} = (\bar{k_1} + \bar{k_2}) \bmod p$ by the definition of addition in $\mathbb{Z}_p$, the result follows.
\end{proof}

\begin{definition}[Gauge Z-Operator]
\label{def:gauge_z_operator}
\lean{GaugingLDPC.gaugeZOperator}
\leanok
\uses{def:z_pow}

For a 1-chain $\alpha : E \to_0 \mathbb{Z}_p$, the \textbf{gauge Z-operator} is defined as:
\[
\mathcal{Z}(\alpha) := \prod_{e \in E} \mathcal{Z}_e^{\alpha_e}
\]
This is the product of generalized Pauli-$Z$ operators on gauge qudits with edge weights given by the coefficients of $\alpha$.
\end{definition}

\begin{lemma}[Gauge Z-Operator of Zero]
\label{lem:gauge_z_operator_zero}
\lean{GaugingLDPC.gaugeZOperator_zero}
\leanok
\uses{def:gauge_z_operator, lem:z_pow_zero}

For the zero 1-chain, $\mathcal{Z}(0) = 1$.
\end{lemma}

\begin{proof}
\leanok
\uses{def:gauge_z_operator, lem:z_pow_zero}

By simplification: $\mathcal{Z}(0) = \prod_{e \in E} \mathcal{Z}_e^0 = \prod_{e \in E} 1 = 1$.
\end{proof}

\begin{lemma}[Gauge Z-Operator Additive]
\label{lem:gauge_z_operator_add}
\lean{GaugingLDPC.gaugeZOperator_add}
\leanok
\uses{def:gauge_z_operator, lem:z_pow_add}

For 1-chains $\alpha, \beta$:
\[
\mathcal{Z}(\alpha + \beta) = \mathcal{Z}(\alpha) \cdot \mathcal{Z}(\beta)
\]
\end{lemma}

\begin{proof}
\leanok
\uses{def:gauge_z_operator, lem:z_pow_add}

We have:
\[
\mathcal{Z}(\alpha + \beta) = \prod_{e \in E} \mathcal{Z}_e^{(\alpha + \beta)_e} = \prod_{e \in E} \mathcal{Z}_e^{\alpha_e + \beta_e}
\]
By the additivity of Z-power (Lemma~\ref{lem:z_pow_add}), this equals:
\[
\prod_{e \in E} (\mathcal{Z}_e^{\alpha_e} \cdot \mathcal{Z}_e^{\beta_e}) = \left(\prod_{e \in E} \mathcal{Z}_e^{\alpha_e}\right) \cdot \left(\prod_{e \in E} \mathcal{Z}_e^{\beta_e}\right) = \mathcal{Z}(\alpha) \cdot \mathcal{Z}(\beta)
\]
where we used that the product distributes due to commutativity of the gauge algebra.
\end{proof}

\begin{definition}[Decorated Operator Algebra]
\label{def:decorated_operator_algebra}
\lean{GaugingLDPC.DecoratedOperatorAlgebra}
\leanok

The \textbf{decorated operator algebra} is the tensor product $\mathcal{O} \otimes_{\mathbb{C}} \mathcal{O}_{\text{gauge}}$, where $\mathcal{O}$ is the operator algebra on the original system and $\mathcal{O}_{\text{gauge}}$ is the operator algebra on the gauge qudits.
\end{definition}

\begin{definition}[Charge Distribution to 0-Chain]
\label{def:charge_distribution_to_0_chain}
\lean{GaugingLDPC.chargeDistributionTo0Chain}
\leanok

The conversion map from charge distributions to 0-chains:
\[
\text{chargeDistributionTo0Chain} : (V \to \mathbb{Z}_p) \to (V \to_0 \mathbb{Z}_p)
\]
interprets the charge assignment $k_v$ at each vertex as coefficients of the vertex basis, converting a function to a finitely supported function via the canonical equivalence on finite types.
\end{definition}

\begin{definition}[Alpha Map]
\label{def:alpha_map}
\lean{GaugingLDPC.alphaMap}
\leanok
\uses{def:alpha_of_chi, def:charge_distribution_to_0_chain, def:exact_charge_submodule}

Given a spanning basis $B$ and a charge distribution $\chi : V \to \mathbb{Z}_p$, the \textbf{alpha map} returns:
\[
\alpha_B(\chi) := \begin{cases}
\alpha(\chi_0) & \text{if } \chi_0 \in \partial C_1 \\
0 & \text{otherwise}
\end{cases}
\]
where $\chi_0 = \text{chargeDistributionTo0Chain}(\chi)$ is the corresponding 0-chain. For exact charge distributions, this returns the unique 1-chain in $T_1$ producing $\chi$ under $\partial_1$.
\end{definition}

\begin{definition}[Gauging Map (Decoration Map)]
\label{def:gauging_(_decoration__map)}
\lean{GaugingLDPC.gaugingMap}
\leanok
\uses{def:alpha_map, def:gauge_z_operator}

The \textbf{gauging} (or \textbf{decoration}) map $\mathfrak{D}: \mathcal{O} \to \mathcal{O} \otimes \mathcal{O}_{\text{gauge}}$ is defined by:
\[
\mathfrak{D}(O) := \sum_{\chi : V \to \mathbb{Z}_p} [\![O]\!]_{\chi} \otimes \mathcal{Z}(\alpha(\chi))
\]
where:
\begin{itemize}
\item The sum is over all charge distributions $\chi$
\item $[\![O]\!]_{\chi}$ is the charge-$\chi$ component of $O$ obtained via the multi-site charge projection
\item $\alpha(\chi)$ is the unique 1-chain in $T_1$ solving $\partial_1(\alpha) = \chi$ (when $\chi$ is exact)
\item $\mathcal{Z}(\alpha) = \prod_{e \in E} \mathcal{Z}_e^{\alpha_e}$ is the gauge Z-operator
\end{itemize}

This implements the gauging construction using the completeness of charge expansion (Lemma~\ref{lem:completeness_of_charge_expansion}): since $O = \sum_{\chi} [\![O]\!]_{\chi}$, the gauging acts on each charge component by tensoring with the appropriate gauge operator.
\end{definition}

\begin{theorem}[Gauging of Zero]
\label{thm:gauging_map_zero}
\lean{GaugingLDPC.gaugingMap_zero}
\leanok
\uses{def:gauging_(_decoration__map)}

The gauging of zero is zero: $\mathfrak{D}(0) = 0$.
\end{theorem}

\begin{proof}
\leanok
\uses{def:gauging_(_decoration__map)}

By simplification using the definitions of the gauging map and multi-site charge projection. Since the product action on the zero operator yields zero, the charge projection of zero is zero for all charge distributions. Thus each term in the sum is $0 \otimes \mathcal{Z}(\alpha(\chi)) = 0$, and the sum of zeros is zero.
\end{proof}

\begin{theorem}[Gauging is Additive]
\label{thm:gauging_map_add}
\lean{GaugingLDPC.gaugingMap_add}
\leanok
\uses{def:gauging_(_decoration__map)}

The gauging map is additive: $\mathfrak{D}(O_1 + O_2) = \mathfrak{D}(O_1) + \mathfrak{D}(O_2)$.
\end{theorem}

\begin{proof}
\leanok
\uses{def:gauging_(_decoration__map)}

We compute:
\begin{align*}
\mathfrak{D}(O_1 + O_2) &= \sum_{\chi} [\![O_1 + O_2]\!]_{\chi} \otimes \mathcal{Z}(\alpha(\chi))
\end{align*}

We claim that the charge projection is additive: $[\![O_1 + O_2]\!]_{\chi} = [\![O_1]\!]_{\chi} + [\![O_2]\!]_{\chi}$. This follows because the product action distributes over addition (since it is defined via ring automorphisms which preserve addition), and scaling distributes over addition.

Using additivity of the tensor product in the first factor:
\begin{align*}
\mathfrak{D}(O_1 + O_2) &= \sum_{\chi} ([\![O_1]\!]_{\chi} + [\![O_2]\!]_{\chi}) \otimes \mathcal{Z}(\alpha(\chi)) \\
&= \sum_{\chi} ([\![O_1]\!]_{\chi} \otimes \mathcal{Z}(\alpha(\chi)) + [\![O_2]\!]_{\chi} \otimes \mathcal{Z}(\alpha(\chi))) \\
&= \sum_{\chi} [\![O_1]\!]_{\chi} \otimes \mathcal{Z}(\alpha(\chi)) + \sum_{\chi} [\![O_2]\!]_{\chi} \otimes \mathcal{Z}(\alpha(\chi)) \\
&= \mathfrak{D}(O_1) + \mathfrak{D}(O_2)
\end{align*}
\end{proof}

\begin{theorem}[Gauging Uses Completeness]
\label{thm:gauging_map_uses_completeness}
\lean{GaugingLDPC.gaugingMap_uses_completeness}
\leanok
\uses{lem:completeness_of__charge__expansion}

By the completeness of charge expansion, every operator $O$ can be written as:
\[
O = \sum_{\chi : V \to \mathbb{Z}_p} [\![O]\!]_{\chi}
\]
This is the foundational identity that justifies the definition of the gauging map.
\end{theorem}

\begin{proof}
\leanok
\uses{lem:completeness_of__charge__expansion}

This follows directly from the completeness theorem for charge projection by index (chargeProjectionByIndex\_sum\_completeness), applied with the symmetry reversed.
\end{proof}

\begin{definition}[Chain Equivalence Modulo Kernel]
\label{def:chain_equiv_mod}
\lean{GaugingLDPC.ChainEquivMod}
\leanok
\uses{def:boundary_map_z_mod}

Two 1-chains $\alpha, \alpha' \in C_1$ are \textbf{equivalent modulo $\ker(\partial_1)$}, written $\alpha \sim \alpha'$, if:
\[
\partial_1(\alpha - \alpha') = 0
\]
equivalently, $\alpha - \alpha' \in \ker(\partial_1)$.
\end{definition}

\begin{lemma}[Chain Equivalence is Reflexive]
\label{lem:chain_equiv_mod_refl}
\lean{GaugingLDPC.chainEquivMod_refl}
\leanok
\uses{def:chain_equiv_mod}

For any 1-chain $\alpha$, we have $\alpha \sim \alpha$.
\end{lemma}

\begin{proof}
\leanok
\uses{def:chain_equiv_mod}

By simplification: $\partial_1(\alpha - \alpha) = \partial_1(0) = 0$.
\end{proof}

\begin{lemma}[Chain Equivalence is Symmetric]
\label{lem:chain_equiv_mod_symm}
\lean{GaugingLDPC.chainEquivMod_symm}
\leanok
\uses{def:chain_equiv_mod}

If $\alpha \sim \alpha'$, then $\alpha' \sim \alpha$.
\end{lemma}

\begin{proof}
\leanok
\uses{def:chain_equiv_mod}

Assume $\partial_1(\alpha - \alpha') = 0$. Then:
\[
\partial_1(\alpha' - \alpha) = \partial_1(-(\alpha - \alpha')) = -\partial_1(\alpha - \alpha') = -0 = 0
\]
using linearity of the boundary map.
\end{proof}

\begin{lemma}[Chain Equivalence is Transitive]
\label{lem:chain_equiv_mod_trans}
\lean{GaugingLDPC.chainEquivMod_trans}
\leanok
\uses{def:chain_equiv_mod}

If $\alpha_1 \sim \alpha_2$ and $\alpha_2 \sim \alpha_3$, then $\alpha_1 \sim \alpha_3$.
\end{lemma}

\begin{proof}
\leanok
\uses{def:chain_equiv_mod}

Assume $\partial_1(\alpha_1 - \alpha_2) = 0$ and $\partial_1(\alpha_2 - \alpha_3) = 0$. Note that:
\[
\alpha_1 - \alpha_3 = (\alpha_1 - \alpha_2) + (\alpha_2 - \alpha_3)
\]
Therefore:
\[
\partial_1(\alpha_1 - \alpha_3) = \partial_1(\alpha_1 - \alpha_2) + \partial_1(\alpha_2 - \alpha_3) = 0 + 0 = 0
\]
\end{proof}

\begin{theorem}[Basis Independence Modulo Kernel]
\label{thm:alpha_map_basis_change}
\lean{GaugingLDPC.alphaMap_basis_change}
\leanok
\uses{def:alpha_map, def:chain_equiv_mod, def:exact_charge_submodule}

Different spanning bases yield $\alpha$ values differing by $\ker(\partial_1)$ elements. Specifically, if $B$ and $B'$ are two spanning bases and $\chi$ is an exact charge distribution (i.e., $\chi_0 \in \partial C_1$), then:
\[
\alpha_B(\chi) \sim \alpha_{B'}(\chi)
\]

\textit{Remark}: This shows that the gauging map depends on the choice of basis $T_1$, but different choices yield equivalent results in the flux-free code space (stabilized by all flux terms $\mathbb{B}_p = +1$), since $\mathcal{Z}(\alpha) \equiv \mathcal{Z}(\alpha')$ in that space when $\alpha - \alpha' \in \ker(\partial_1)$.
\end{theorem}

\begin{proof}
\leanok
\uses{def:alpha_map, def:chain_equiv_mod, lem:alpha_of_chi_spec}

Let $\chi$ be a charge distribution such that $\chi_0 := \text{chargeDistributionTo0Chain}(\chi) \in \partial C_1$. By the specification of $\alpha$, both $\alpha_B(\chi)$ and $\alpha_{B'}(\chi)$ map to the same charge $\chi_0$ under $\partial_1$:
\[
\partial_1(\alpha_B(\chi)) = \chi_0 = \partial_1(\alpha_{B'}(\chi))
\]
Therefore:
\[
\partial_1(\alpha_B(\chi) - \alpha_{B'}(\chi)) = \partial_1(\alpha_B(\chi)) - \partial_1(\alpha_{B'}(\chi)) = \chi_0 - \chi_0 = 0
\]
which shows $\alpha_B(\chi) \sim \alpha_{B'}(\chi)$.
\end{proof}

%--- Def_5: Circuit Unitaries for Gauging ---
\begin{definition}[Qudit State]
\label{def:qudit_state}
\lean{GaugingLDPC.QuditState}
\leanok

The Hilbert space of a single qudit is $\mathbb{C}^w$. We represent states as functions $\mathbb{Z}_w \to \mathbb{C}$ (the amplitudes in the computational basis).
\end{definition}

\begin{definition}[Basis State]
\label{def:basis_state}
\lean{GaugingLDPC.basisState}
\leanok
\uses{def:qudit_state}
The computational basis state $|j\rangle$ for $j \in \mathbb{Z}_w$ is defined by
\[
\operatorname{basisState}(j)(k) = \begin{cases} 1 & \text{if } k = j \\ 0 & \text{otherwise} \end{cases}
\]
\end{definition}

\begin{definition}[Plus State]
\label{def:plus_state}
\lean{GaugingLDPC.plusState}
\leanok
\uses{def:qudit_state}
The $|+\rangle$ state is the equal superposition of all computational basis states:
\[
|+\rangle = \frac{1}{\sqrt{w}} \sum_{j=0}^{w-1} |j\rangle
\]
This is the $+1$ eigenstate of the generalized Pauli $X$ operator.
\end{definition}

\begin{definition}[Primitive Root of Unity]
\label{def:primitive_root_of_unity}
\lean{GaugingLDPC.primitiveRootOfUnity}
\leanok

The primitive $w$-th root of unity is defined as $\omega = \exp(2\pi i / w)$.
\end{definition}

\begin{definition}[Pauli X Action]
\label{def:pauli_x_action}
\lean{GaugingLDPC.pauliX_action}
\leanok
\uses{def:qudit_state}
The generalized Pauli $X$ operator acts on basis states by $X|j\rangle = |j+1\rangle$. For a state $\psi$, we have $(\operatorname{pauliX\_action}(\psi))(k) = \psi(k-1)$.
\end{definition}

\begin{definition}[Pauli Z Action]
\label{def:pauli_z_action}
\lean{GaugingLDPC.pauliZ_action}
\leanok
\uses{def:qudit_state, def:primitive_root_of_unity}
The generalized Pauli $Z$ operator acts on basis states by $Z|j\rangle = \omega^j |j\rangle$. For a state $\psi$, we have $(\operatorname{pauliZ\_action}(\psi))(k) = \omega^k \cdot \psi(k)$.
\end{definition}

\begin{definition}[Pauli X Power Action]
\label{def:pauli_x_pow_action}
\lean{GaugingLDPC.pauliX_pow_action}
\leanok
\uses{def:qudit_state}
The $k$-th power of the Pauli $X$ operator: $X^k |j\rangle = |j+k\rangle$. For a state $\psi$, we have $(\operatorname{pauliX\_pow\_action}(k)(\psi))(j) = \psi(j-k)$.
\end{definition}

\begin{definition}[Pauli Z Power Action]
\label{def:pauli_z_pow_action}
\lean{GaugingLDPC.pauliZ_pow_action}
\leanok
\uses{def:qudit_state, def:primitive_root_of_unity}
The $k$-th power of the Pauli $Z$ operator: $Z^k |j\rangle = \omega^{jk} |j\rangle$. For a state $\psi$, we have $(\operatorname{pauliZ\_pow\_action}(k)(\psi))(j) = \omega^{jk} \cdot \psi(j)$.
\end{definition}

\begin{lemma}[Pauli X on Plus State]
\label{lem:pauli_x_plus_state}
\lean{GaugingLDPC.pauliX_plusState}
\leanok
\uses{def:pauli_x_action, def:plus_state}
The $|+\rangle$ state is an eigenstate of $X$ with eigenvalue $1$: $X|+\rangle = |+\rangle$.
\end{lemma}

\begin{proof}
\leanok
\uses{def:pauli_x_action, def:plus_state}
By extensionality, it suffices to show equality for arbitrary $k$. By simplification using the definitions of pauliX\_action and plusState, both sides are equal.
\end{proof}

\begin{definition}[Two Qudit State]
\label{def:two_qudit_state}
\lean{GaugingLDPC.TwoQuditState}
\leanok

The state of a pair of qudits (control and target) is a function $\mathbb{Z}_w \to \mathbb{Z}_w \to \mathbb{C}$.
\end{definition}

\begin{definition}[Tensor State]
\label{def:tensor_state}
\lean{GaugingLDPC.tensorState}
\leanok
\uses{def:qudit_state, def:two_qudit_state}
The tensor product of two single-qudit states $\psi_1$ and $\psi_2$ is defined by
\[
(\psi_1 \otimes \psi_2)(i,j) = \psi_1(i) \cdot \psi_2(j)
\]
\end{definition}

\begin{definition}[Controlled-X Gate]
\label{def:controlled_x_gate}
\lean{GaugingLDPC.controlledXGate}
\leanok
\uses{def:two_qudit_state}
The controlled-$X$ gate with power $k$ acts as
\[
CX^k |i\rangle_c |j\rangle_t = |i\rangle_c |j + i \cdot k\rangle_t
\]
For an input state $\Psi(i,j)$, the output is $\Psi(i, j - i \cdot k)$.
\end{definition}

\begin{lemma}[Controlled-X Gate on Basis States]
\label{lem:controlled_x_gate_basis}
\lean{GaugingLDPC.controlledXGate_basis}
\leanok
\uses{def:controlled_x_gate, def:tensor_state, def:basis_state}
For basis states, $CX^k (|i_0\rangle \otimes |j_0\rangle) = |i_0\rangle \otimes |j_0 + i_0 \cdot k\rangle$.
\end{lemma}

\begin{proof}
\leanok
\uses{def:controlled_x_gate, def:tensor_state, def:basis_state}
By extensionality over $i$ and $j$. We simplify using the definitions of controlledXGate, tensorState, and basisState. We consider cases on whether $i = i_0$ and whether $j = j_0 + i_0 \cdot k$. In each case, we verify the equality by direct computation, using the fact that $j - i \cdot k = j_0$ if and only if $j = j_0 + i \cdot k$ when $i = i_0$.
\end{proof}

\begin{lemma}[Controlled-X Gate Inverse]
\label{lem:controlled_x_gate_inv}
\lean{GaugingLDPC.controlledXGate_inv}
\leanok
\uses{def:controlled_x_gate}
$CX^k$ is invertible with inverse $CX^{-k}$: $CX^{-k} \circ CX^k = \mathrm{id}$.
\end{lemma}

\begin{proof}
\leanok
\uses{def:controlled_x_gate}
By extensionality over $\Psi$, $i$, and $j$. By simplification using the definition of function composition and controlledXGate, we get the identity by ring arithmetic: $(j - i \cdot k) - i \cdot (-k) = j$.
\end{proof}

\begin{definition}[Boundary Matrix Entry]
\label{def:boundary_matrix_entry}
\lean{GaugingLDPC.boundaryMatrixEntry}
\leanok
\uses{def:circuit__unitaries_for__gauging}
The $(v,e)$-entry of the boundary matrix $\partial_1^{\mathcal{G}}$ is defined by
\[
(\partial_1)_{v,e} = \begin{cases} 
1 & \text{if } v = \operatorname{target}(e) \\
-1 & \text{if } v = \operatorname{source}(e) \\
0 & \text{otherwise}
\end{cases}
\]
where source and target come from the oriented graph structure.
\end{definition}

\begin{definition}[Matter Assignment]
\label{def:matter_assignment}
\lean{GaugingLDPC.MatterAssignment}
\leanok

A matter assignment associates matter qudits to each vertex. For each vertex $v$, $\Sigma(v)$ is the set of matter qudits on which the symmetry acts when controlled by $v$.
\end{definition}

\begin{definition}[Full Gauging System State]
\label{def:full_gauging_system_state}
\lean{GaugingLDPC.FullGaugingSystemState}
\leanok

The state of the full gauging system including vertices, edges, and matter qudits. A state assigns complex amplitudes to configurations $(f_V : V \to \mathbb{Z}_w, f_E : E \to \mathbb{Z}_w, f_M : M \to \mathbb{Z}_w)$.
\end{definition}

\begin{definition}[Circuit Unitaries for Gauging]
\label{def:circuit__unitaries_for__gauging}
\lean{GaugingLDPC.edgeVertexEntanglingUnitary}
\leanok
\uses{def:circuit__unitaries_for__gauging, def:full_gauging_system_state, def:boundary_matrix_entry}
The gauging procedure is implemented by the following circuit unitaries:

\textbf{1. Edge-vertex entangling unitary} $U_{C\mathcal{X}}$:
\[
U_{C\mathcal{X}} := \prod_{v \in \mathcal{G}_0} \prod_{e \in \mathcal{G}_1} (C\mathcal{X}_{v \to e})^{(\partial_1^{\mathcal{G}})_{v,e}}
\]
where $(C_c\mathcal{X}_t)^k |i\rangle_c |j\rangle_t = |i\rangle_c |j + i \cdot k\rangle_t$ is the controlled-$\mathcal{X}$ gate and $(\partial_1^{\mathcal{G}})_{v,e} \in \mathbb{F}_w$ is the $(v,e)$-entry of the boundary matrix.

The action on the full state space is:
\[
U_{C\mathcal{X}} |f_V\rangle|f_E\rangle|f_M\rangle = |f_V\rangle|f_E + \partial_1^T f_V\rangle|f_M\rangle
\]
The matter qudits are unchanged.
\end{definition}

\begin{definition}[Matter-Symmetry Coupling Unitary]
\label{def:matter_symmetry_coupling_unitary}
\lean{GaugingLDPC.matterSymmetryCouplingUnitary}
\leanok
\uses{def:full_gauging_system_state, def:matter_assignment}
The matter-symmetry coupling unitary is defined as
\[
U_{C\mathsf{T}} := \prod_{v \in \mathcal{G}_0} C_v \mathsf{T}_{\Sigma(v)}
\]
where $C_v \mathsf{T}_{\Sigma(v)}$ is the controlled symmetry operator on matter qudits.

The action on the full state space is:
\[
U_{C\mathsf{T}} |f_V\rangle|f_E\rangle|f_M\rangle = |f_V\rangle|f_E\rangle\left|f_M + \sum_v f_V(v) \cdot \mathbf{1}_{\Sigma(v)}\right\rangle
\]
The edge qudits are unchanged.
\end{definition}

\begin{definition}[Plus Projection]
\label{def:plus_projection}
\lean{GaugingLDPC.plusProjection}
\leanok
\uses{def:qudit_state}
The projection onto $|+\rangle$ for a single qudit is
\[
\langle +|\psi\rangle = \frac{1}{\sqrt{w}} \sum_{j=0}^{w-1} \psi(j)
\]
\end{definition}

\begin{lemma}[Plus Projection on Plus State]
\label{lem:plus_projection_plus_state}
\lean{GaugingLDPC.plusProjection_plusState}
\leanok
\uses{def:plus_projection, def:plus_state}
$\langle +|+\rangle = 1$ (normalization).
\end{lemma}

\begin{proof}
\leanok
\uses{def:plus_projection, def:plus_state}
By simplification using the definitions of plusProjection and plusState, the sum becomes a constant. Rewriting using the fact that the sum of a constant over $\mathbb{Z}_w$ equals $w$ times the constant, and using that $|\mathbb{Z}_w| = w$, we get $\frac{1}{\sqrt{w}} \cdot w \cdot \frac{1}{\sqrt{w}}$. Since $(w : \mathbb{R}) > 0$ (because $w$ is prime), we have $\sqrt{w} \neq 0$. By field simplification and using that $(\sqrt{w})^2 = w$, we obtain $1$.
\end{proof}

\begin{definition}[Measurement Projection]
\label{def:measurement_projection}
\lean{GaugingLDPC.measurementProjection}
\leanok
\uses{def:full_gauging_system_state}
The measurement projection $\langle +|_{\mathcal{G}_0}$ projects all vertex ancillas onto the $|+\rangle$ state:
\[
\langle +|_{\mathcal{G}_0} := \prod_{v \in \mathcal{G}_0} \langle +|_v
\]
The action on a state $\Psi$ is
\[
\langle +|_{\mathcal{G}_0} |\Psi\rangle(f_E, f_M) = \left(\frac{1}{\sqrt{w}}\right)^{|V|} \sum_{f_V : V \to \mathbb{Z}_w} \Psi(f_V, f_E, f_M)
\]
\end{definition}

\begin{theorem}[Unitaries Commute]
\label{thm:unitaries_commute}
\lean{GaugingLDPC.unitaries_commute}
\leanok
\uses{def:circuit__unitaries_for__gauging, def:matter_symmetry_coupling_unitary}
The order of $U_{C\mathcal{X}}$ and $U_{C\mathsf{T}}$ does not matter:
\[
U_{C\mathcal{X}} \circ U_{C\mathsf{T}} = U_{C\mathsf{T}} \circ U_{C\mathcal{X}}
\]
This is because their only common support is on gauge qudits (vertex ancillas), which serve as controls in both cases. Specifically:
\begin{itemize}
\item $U_{C\mathcal{X}}$ transforms edges: $f_E \mapsto f_E + \partial_1^T f_V$ (matter unchanged)
\item $U_{C\mathsf{T}}$ transforms matter: $f_M \mapsto f_M + \sum_v f_V(v) \cdot \mathbf{1}_{\Sigma(v)}$ (edges unchanged)
\item Both use $f_V$ as control, which remains unchanged by both
\end{itemize}
\end{theorem}

\begin{proof}
\leanok
\uses{def:circuit__unitaries_for__gauging, def:matter_symmetry_coupling_unitary}
By extensionality over $\Psi$, $f_V$, $f_E$, and $f_M$. Both sides evaluate to $\Psi$ applied to the same transformed configuration. On the left-hand side, first $U_{C\mathsf{T}}$ transforms $f_M$, then $U_{C\mathcal{X}}$ transforms $f_E$. On the right-hand side, first $U_{C\mathcal{X}}$ transforms $f_E$, then $U_{C\mathsf{T}}$ transforms $f_M$. Both give $\Psi(f_V, f_E - \sum_v f_V(v) \cdot (\partial_1)_{v,e}, f_M - \sum_v (\text{if } m \in \Sigma(v) \text{ then } f_V(v) \text{ else } 0))$. By simplification using the definitions of function composition, edgeVertexEntanglingUnitary, and matterSymmetryCouplingUnitary, both sides are equal.
\end{proof}

\begin{definition}[Edge-Vertex Entangling Unitary Inverse]
\label{def:edge_vertex_entangling_unitary_inv}
\lean{GaugingLDPC.edgeVertexEntanglingUnitary_inv}
\leanok
\uses{def:circuit__unitaries_for__gauging, def:boundary_matrix_entry, def:full_gauging_system_state}
The inverse of the edge-vertex entangling unitary $(U_{C\mathcal{X}})^{-1}$ applies $CX$ with negated boundary matrix entries:
\[
(U_{C\mathcal{X}})^{-1} |f_V\rangle|f_E\rangle|f_M\rangle = |f_V\rangle|f_E - \partial_1^T f_V\rangle|f_M\rangle
\]
\end{definition}

\begin{lemma}[Edge-Vertex Entangling Unitary Right Inverse]
\label{lem:edge_vertex_entangling_unitary_right_inv}
\lean{GaugingLDPC.edgeVertexEntanglingUnitary_right_inv}
\leanok
\uses{def:circuit__unitaries_for__gauging, def:edge_vertex_entangling_unitary_inv}
$U_{C\mathcal{X}} \circ (U_{C\mathcal{X}})^{-1} = \mathrm{id}$.
\end{lemma}

\begin{proof}
\leanok
\uses{def:circuit__unitaries_for__gauging, def:edge_vertex_entangling_unitary_inv}
By extensionality over $\Psi$, $f_V$, $f_E$, and $f_M$. By simplification using the definitions of function composition, edgeVertexEntanglingUnitary, and edgeVertexEntanglingUnitary\_inv, and the identity function, we obtain the result. The key step uses extensionality over $e$ and ring arithmetic to show that $(f_E(e) + \sum_v f_V(v) \cdot (\partial_1)_{v,e}) - \sum_v f_V(v) \cdot (\partial_1)_{v,e} = f_E(e)$.
\end{proof}

\begin{lemma}[Edge-Vertex Entangling Unitary Left Inverse]
\label{lem:edge_vertex_entangling_unitary_left_inv}
\lean{GaugingLDPC.edgeVertexEntanglingUnitary_left_inv}
\leanok
\uses{def:circuit__unitaries_for__gauging, def:edge_vertex_entangling_unitary_inv}
$(U_{C\mathcal{X}})^{-1} \circ U_{C\mathcal{X}} = \mathrm{id}$.
\end{lemma}

\begin{proof}
\leanok
\uses{def:circuit__unitaries_for__gauging, def:edge_vertex_entangling_unitary_inv}
By extensionality over $\Psi$, $f_V$, $f_E$, and $f_M$. By simplification using the definitions of function composition, edgeVertexEntanglingUnitary, and edgeVertexEntanglingUnitary\_inv, and the identity function, we obtain the result. The key step uses extensionality over $e$ and ring arithmetic.
\end{proof}

\begin{theorem}[Edge-Vertex Entangling Unitary is Bijective]
\label{thm:edge_vertex_entangling_unitary_bijective}
\lean{GaugingLDPC.edgeVertexEntanglingUnitary_bijective}
\leanok
\uses{def:circuit__unitaries_for__gauging, def:edge_vertex_entangling_unitary_inv, lem:edge_vertex_entangling_unitary_left_inv, lem:edge_vertex_entangling_unitary_right_inv}
$U_{C\mathcal{X}}$ is a bijection (hence unitary as an operator).
\end{theorem}

\begin{proof}
\leanok
\uses{lem:edge_vertex_entangling_unitary_left_inv, lem:edge_vertex_entangling_unitary_right_inv, def:edge_vertex_entangling_unitary_inv}
We prove each direction separately.

\textbf{Injective:} Let $\Psi_1, \Psi_2$ be given with $U_{C\mathcal{X}}(\Psi_1) = U_{C\mathcal{X}}(\Psi_2)$. We first establish that $(U_{C\mathcal{X}})^{-1}(U_{C\mathcal{X}}(\Psi_1)) = (U_{C\mathcal{X}})^{-1}(U_{C\mathcal{X}}(\Psi_2))$ by rewriting with the hypothesis. Using the left inverse property, this reduces to $\Psi_1 = \Psi_2$.

\textbf{Surjective:} Let $\Psi$ be arbitrary. We exhibit $(U_{C\mathcal{X}})^{-1}(\Psi)$ as a preimage. Using the right inverse property, $U_{C\mathcal{X}}((U_{C\mathcal{X}})^{-1}(\Psi)) = \mathrm{id}(\Psi) = \Psi$.
\end{proof}

\begin{definition}[Matter-Symmetry Coupling Unitary Inverse]
\label{def:matter_symmetry_coupling_unitary_inv}
\lean{GaugingLDPC.matterSymmetryCouplingUnitary_inv}
\leanok
\uses{def:matter_symmetry_coupling_unitary, def:full_gauging_system_state, def:matter_assignment}
The inverse of the matter-symmetry coupling unitary $(U_{C\mathsf{T}})^{-1}$ is defined by
\[
(U_{C\mathsf{T}})^{-1} |f_V\rangle|f_E\rangle|f_M\rangle = |f_V\rangle|f_E\rangle\left|f_M - \sum_v f_V(v) \cdot \mathbf{1}_{\Sigma(v)}\right\rangle
\]
\end{definition}

\begin{lemma}[Matter-Symmetry Coupling Unitary Right Inverse]
\label{lem:matter_symmetry_coupling_unitary_right_inv}
\lean{GaugingLDPC.matterSymmetryCouplingUnitary_right_inv}
\leanok
\uses{def:matter_symmetry_coupling_unitary, def:matter_symmetry_coupling_unitary_inv}
$U_{C\mathsf{T}} \circ (U_{C\mathsf{T}})^{-1} = \mathrm{id}$.
\end{lemma}

\begin{proof}
\leanok
\uses{def:matter_symmetry_coupling_unitary, def:matter_symmetry_coupling_unitary_inv}
By extensionality over $\Psi$, $f_V$, $f_E$, and $f_M$. By simplification using the definitions of function composition, matterSymmetryCouplingUnitary, matterSymmetryCouplingUnitary\_inv, and the identity function, we obtain the result. The key step uses extensionality over $m$ and ring arithmetic.
\end{proof}

\begin{lemma}[Matter-Symmetry Coupling Unitary Left Inverse]
\label{lem:matter_symmetry_coupling_unitary_left_inv}
\lean{GaugingLDPC.matterSymmetryCouplingUnitary_left_inv}
\leanok
\uses{def:matter_symmetry_coupling_unitary, def:matter_symmetry_coupling_unitary_inv}
$(U_{C\mathsf{T}})^{-1} \circ U_{C\mathsf{T}} = \mathrm{id}$.
\end{lemma}

\begin{proof}
\leanok
\uses{def:matter_symmetry_coupling_unitary, def:matter_symmetry_coupling_unitary_inv}
By extensionality over $\Psi$, $f_V$, $f_E$, and $f_M$. By simplification using the definitions of function composition, matterSymmetryCouplingUnitary, matterSymmetryCouplingUnitary\_inv, and the identity function, we obtain the result. The key step uses extensionality over $m$ and ring arithmetic.
\end{proof}

\begin{theorem}[Matter-Symmetry Coupling Unitary is Bijective]
\label{thm:matter_symmetry_coupling_unitary_bijective}
\lean{GaugingLDPC.matterSymmetryCouplingUnitary_bijective}
\leanok
\uses{def:matter_symmetry_coupling_unitary, def:matter_symmetry_coupling_unitary_inv, lem:matter_symmetry_coupling_unitary_left_inv, lem:matter_symmetry_coupling_unitary_right_inv}
$U_{C\mathsf{T}}$ is a bijection (hence unitary as an operator).
\end{theorem}

\begin{proof}
\leanok
\uses{lem:matter_symmetry_coupling_unitary_left_inv, lem:matter_symmetry_coupling_unitary_right_inv, def:matter_symmetry_coupling_unitary_inv}
We prove each direction separately.

\textbf{Injective:} Let $\Psi_1, \Psi_2$ be given with $U_{C\mathsf{T}}(\Psi_1) = U_{C\mathsf{T}}(\Psi_2)$. We first establish that $(U_{C\mathsf{T}})^{-1}(U_{C\mathsf{T}}(\Psi_1)) = (U_{C\mathsf{T}})^{-1}(U_{C\mathsf{T}}(\Psi_2))$ by rewriting with the hypothesis. Let $h_2$ denote the left inverse property. By calculation:
\[
\Psi_1 = ((U_{C\mathsf{T}})^{-1} \circ U_{C\mathsf{T}})(\Psi_1) = ((U_{C\mathsf{T}})^{-1} \circ U_{C\mathsf{T}})(\Psi_2) = \Psi_2
\]
where the first and last equalities use $h_2$, and the middle equality uses the established fact.

\textbf{Surjective:} Let $\Psi$ be arbitrary. We exhibit $(U_{C\mathsf{T}})^{-1}(\Psi)$ as a preimage. Let $h$ denote the right inverse property. By calculation:
\[
U_{C\mathsf{T}}((U_{C\mathsf{T}})^{-1}(\Psi)) = (U_{C\mathsf{T}} \circ (U_{C\mathsf{T}})^{-1})(\Psi) = \mathrm{id}(\Psi) = \Psi
\]
where the second equality uses $h$.
\end{proof}

%--- Def_6: Gauged Stabilizers (Vertex and Plaquette Terms) ---
\begin{definition}[Gauged Cell Complex]
\label{def:gauged_cell_complex}
\lean{GaugingLDPC.GaugedCellComplex}
\leanok
\uses{def:circuit__unitaries_for__gauging}

A \emph{gauged cell complex} $\mathcal{G} = (\mathcal{G}_0, \mathcal{G}_1, \mathcal{G}_2)$ extends an oriented graph with 2-cells (plaquettes). It consists of:
\begin{itemize}
    \item $\mathcal{G}_0$: a finite set of vertices (0-cells),
    \item $\mathcal{G}_1$: a finite set of edges (1-cells),
    \item $\mathcal{G}_2$: a finite set of plaquettes (2-cells).
\end{itemize}

The structure includes:
\begin{itemize}
    \item A \emph{plaquette boundary function} $\partial_2 : P \times E \to \mathbb{Z}_w$ that assigns to each plaquette $p$ and edge $e$ the coefficient of $e$ in the boundary of $p$ (typically $0$, $1$, or $-1$ modulo $w$).
    \item A \emph{boundary cycle condition}: for every plaquette $p \in P$ and every vertex $v \in V$,
    \[
    \sum_{e \in E} \partial_2(p, e) \cdot \left( \begin{cases} 1 & \text{if } v = \mathrm{target}(e) \\ -1 & \text{if } v = \mathrm{source}(e) \\ 0 & \text{otherwise} \end{cases} \right) = 0.
    \]
\end{itemize}
This condition ensures that plaquette boundaries are actual cycles.
\end{definition}

\begin{definition}[1-Boundary Matrix Entry]
\label{def:boundary1_matrix_entry}
\lean{GaugingLDPC.boundary1MatrixEntry}
\leanok
\uses{def:gauged_cell_complex}

The $(v,e)$-entry of the 1-boundary matrix $\partial_1^{\mathcal{G}}$ is defined as:
\[
(\partial_1)_{v,e} := \begin{cases} 1 & \text{if } v = \mathrm{target}(e) \\ -1 & \text{if } v = \mathrm{source}(e) \\ 0 & \text{otherwise} \end{cases}
\]
\end{definition}

\begin{definition}[2-Boundary Matrix Entry]
\label{def:boundary2_matrix_entry}
\lean{GaugingLDPC.boundary2MatrixEntry}
\leanok
\uses{def:gauged_cell_complex}

The $(p,e)$-entry of the 2-boundary matrix $\partial_2^{\mathcal{G}}$ is defined as:
\[
(\partial_2)_{p,e} := \text{plaquetteBoundary}(p, e),
\]
which gives the coefficient of edge $e$ in the boundary of plaquette $p$.
\end{definition}

\begin{definition}[Gauged System State]
\label{def:gauged_system_state}
\lean{GaugingLDPC.GaugedSystemState}
\leanok
\uses{def:gauged_cell_complex}

The state of the full gauged system is a function
\[
\Psi : (V \to \mathbb{Z}_w) \times (E \to \mathbb{Z}_w) \times (M \to \mathbb{Z}_w) \to \mathbb{C}
\]
that assigns complex amplitudes to configurations $(f_V, f_E, f_M)$ of the vertex, edge, and matter qudits.
\end{definition}

\begin{definition}[Gauged Stabilizers (Vertex and Plaquette Terms)]
\label{def:gauged__stabilizers_(_vertex_and__plaquette__terms)}
\lean{GaugingLDPC.vertexStabilizer}
\leanok
\uses{def:circuit__unitaries_for__gauging}

The gauged code has two types of stabilizer generators:

\textbf{1. Vertex stabilizer (Gauss law generator)} $\mathbb{A}_v$ for each $v \in \mathcal{G}_0$:
\[
\mathbb{A}_v := \mathsf{T}_{\Sigma(v)} \prod_{e \in \mathcal{G}_1} (\mathcal{X}_e)^{(\partial_1^{\mathcal{G}})_{v,e}}
\]
where:
\begin{itemize}
    \item $\mathsf{T}_{\Sigma(v)}$ is the on-site symmetry restricted to the vertex set $\Sigma(v)$,
    \item $\mathcal{X}_e$ is the generalized Pauli-$X$ on edge qudit $e$,
    \item The product runs over all edges incident to $v$ (by the boundary matrix).
\end{itemize}

The action on a state $\Psi$ is:
\[
(\mathbb{A}_v \cdot \Psi)(f_V, f_E, f_M) = \Psi(f_V, f_E', f_M')
\]
where $f_E'(e) = f_E(e) - (\partial_1)_{v,e}$ and $f_M'(m) = f_M(m) - 1$ if $m \in \Sigma(v)$, else $f_M'(m) = f_M(m)$.
\end{definition}

\begin{definition}[Plaquette Z-Phase]
\label{def:plaquette_z_phase}
\lean{GaugingLDPC.plaquetteZPhase}
\leanok
\uses{def:boundary2_matrix_entry, def:gauged_cell_complex}

The total $Z$-phase from plaquette $p$ given edge configuration $f_E$ is:
\[
\omega^{\sum_{e \in E} (\partial_2)_{p,e} \cdot f_E(e) \mod w}
\]
where $\omega = \exp(2\pi i / w)$ is the primitive $w$-th root of unity.
\end{definition}

\begin{definition}[Plaquette Stabilizer]
\label{def:plaquette_stabilizer}
\lean{GaugingLDPC.plaquetteStabilizer}
\leanok
\uses{def:plaquette_z_phase, def:gauged_cell_complex}

\textbf{2. Plaquette stabilizer (flux term)} $\mathbb{B}_p$ for each $p \in \mathcal{G}_2$:
\[
\mathbb{B}_p := \prod_{e \in p} \mathcal{Z}_e^{(\partial_2^{\mathcal{G}})_{p,e}}
\]
where the product runs over all edges in the boundary of plaquette $p$, with exponents given by the 2-boundary matrix.

The action on a state $\Psi$ is:
\[
(\mathbb{B}_p \cdot \Psi)(f_V, f_E, f_M) = \omega^{\sum_e (\partial_2)_{p,e} \cdot f_E(e)} \cdot \Psi(f_V, f_E, f_M)
\]
\end{definition}

\begin{definition}[Plaquette Boundary Chain]
\label{def:plaquette_boundary_chain}
\lean{GaugingLDPC.plaquetteBoundaryChain}
\leanok
\uses{def:boundary2_matrix_entry}

The boundary of plaquette $p$ as a 1-chain is the element $\partial_2(p) \in E \to_0 \mathbb{Z}_w$ defined by:
\[
(\partial_2(p))(e) := (\partial_2)_{p,e}
\]
for each edge $e \in E$.
\end{definition}

\begin{theorem}[Plaquette Boundary is a Cycle]
\label{thm:plaquette_boundary_is_cycle}
\lean{GaugingLDPC.plaquette_boundary_is_cycle}
\leanok
\uses{def:plaquette_boundary_chain, def:boundary1_matrix_entry}

For every plaquette $p$ and every vertex $v$:
\[
\sum_{e \in E} (\partial_2(p))(e) \cdot (\partial_1)_{v,e} = 0.
\]
This is the chain complex property $\partial_1 \circ \partial_2 = 0$.
\end{theorem}

\begin{proof}
\leanok
\uses{def:plaquette_boundary_chain, def:boundary1_matrix_entry, def:gauged_cell_complex}

Let $v$ be an arbitrary vertex. By the definition of the plaquette boundary chain and the boundary matrix entries, we have:
\[
\sum_{e \in E} (\partial_2(p))(e) \cdot (\partial_1)_{v,e} = \sum_{e \in E} \text{plaquetteBoundary}(p, e) \cdot \left( \begin{cases} 1 & \text{if } v = \mathrm{target}(e) \\ -1 & \text{if } v = \mathrm{source}(e) \\ 0 & \text{otherwise} \end{cases} \right).
\]
This equals zero by the boundary cycle axiom of the gauged cell complex structure.
\end{proof}

\begin{theorem}[Plaquette Corresponds to Cycle]
\label{thm:plaquette_corresponds_to_cycle}
\lean{GaugingLDPC.plaquette_corresponds_to_cycle}
\leanok
\uses{def:plaquette_boundary_chain, def:circuit__unitaries_for__gauging}

The plaquette boundary lies in the kernel of $\partial_1$ (the 1-cycle space $Z_1$):
\[
\partial_1(\partial_2(p)) = 0.
\]
This is the key property: $\mathbb{B}_p$ operators correspond to cycles in $Z_1(\mathcal{G}, \mathbb{F}_w)$.
\end{theorem}

\begin{proof}
\leanok
\uses{thm:plaquette_boundary_is_cycle, def:plaquette_boundary_chain}

By extensionality, it suffices to show equality at each vertex $v$. We apply the boundary map definition and use the finitely supported function representation. For each edge $e$, we establish that:
\[
(\delta_{\mathrm{target}(e)} - \delta_{\mathrm{source}(e)})(v) = \begin{cases} 1 & \text{if } v = \mathrm{target}(e) \\ -1 & \text{if } v = \mathrm{source}(e) \\ 0 & \text{otherwise} \end{cases}
\]
by case analysis on whether $v = \mathrm{target}(e)$ or $v = \mathrm{source}(e)$, using the fact that source and target are distinct. The sum over the support can be extended to a sum over all edges (since terms outside the support contribute zero), and the result then follows from the boundary cycle condition of the gauged cell complex.
\end{proof}

\begin{definition}[1-Cycle Space]
\label{def:cycle_space_1}
\lean{GaugingLDPC.cycleSpace1}
\leanok
\uses{def:circuit__unitaries_for__gauging}

The 1-cycle space is the kernel of the boundary map:
\[
Z_1 := \ker(\partial_1) = \{ c \in C_1 : \partial_1(c) = 0 \}.
\]
\end{definition}

\begin{definition}[1-Boundary Space]
\label{def:boundary_space_1}
\lean{GaugingLDPC.boundarySpace1}
\leanok
\uses{def:plaquette_boundary_chain}

The 1-boundary space is the image of the 2-boundary map:
\[
B_1 := \mathrm{im}(\partial_2) = \mathrm{span}\{ \partial_2(p) : p \in \mathcal{G}_2 \}.
\]
This is spanned by the plaquette boundaries.
\end{definition}

\begin{theorem}[Boundary Space is Contained in Cycle Space]
\label{thm:boundary_space_le_cycle_space}
\lean{GaugingLDPC.boundarySpace_le_cycleSpace}
\leanok
\uses{def:boundary_space_1, def:cycle_space_1}

All boundaries are cycles: $B_1 \subseteq Z_1$.

This follows from the chain complex property $\partial_1 \circ \partial_2 = 0$.
\end{theorem}

\begin{proof}
\leanok
\uses{thm:plaquette_corresponds_to_cycle, def:boundary_space_1, def:cycle_space_1}

We show that the generating set of $B_1$ is contained in $Z_1$. The boundary space $B_1$ is the span of the set $\{\partial_2(p) : p \in P\}$. Let $c$ be in this generating set. Then $c = \partial_2(p)$ for some plaquette $p$. We need to show $c \in Z_1$, i.e., $c \in \ker(\partial_1)$. This follows directly from the theorem that plaquette boundaries correspond to cycles: $\partial_1(\partial_2(p)) = 0$.
\end{proof}

\begin{definition}[First Cohomology Vanishes]
\label{def:first_cohomology_vanishes}
\lean{GaugingLDPC.firstCohomologyVanishes}
\leanok
\uses{def:cycle_space_1, def:boundary_space_1}

The first cohomology vanishes, $H^1 = 0$, if and only if:
\[
Z_1 = B_1.
\]
When this holds, all cycles are generated by boundaries of plaquettes.
\end{definition}

\begin{theorem}[Cycles Generated by Plaquettes]
\label{thm:cycles_generated_by_plaquettes}
\lean{GaugingLDPC.cycles_generated_by_plaquettes}
\leanok
\uses{def:first_cohomology_vanishes, def:cycle_space_1, def:boundary_space_1}

When $H^1 = 0$, every cycle is a boundary of some 2-chain:
\[
Z_1 \subseteq B_1.
\]
This means all flux configurations can be generated by plaquette stabilizers.
\end{theorem}

\begin{proof}
\leanok
\uses{def:first_cohomology_vanishes}

Assume $H^1 = 0$, i.e., $Z_1 = B_1$. Then $Z_1 \subseteq B_1$ follows immediately by rewriting with this equality.
\end{proof}

\begin{definition}[Vertex Stabilizers Collection]
\label{def:vertex_stabilizers}
\lean{GaugingLDPC.vertexStabilizers}
\leanok
\uses{def:gauged__stabilizers_(_vertex_and__plaquette__terms)}

The set of all vertex stabilizers $\{\mathbb{A}_v\}_{v \in \mathcal{G}_0}$ is the collection indexed by vertices $v \in V$ of the vertex stabilizer operators.
\end{definition}

\begin{definition}[Plaquette Stabilizers Collection]
\label{def:plaquette_stabilizers}
\lean{GaugingLDPC.plaquetteStabilizers}
\leanok
\uses{def:plaquette_stabilizer}

The set of all plaquette stabilizers $\{\mathbb{B}_p\}_{p \in \mathcal{G}_2}$ is the collection indexed by plaquettes $p \in P$ of the plaquette stabilizer operators.
\end{definition}

%--- Def_7: Decorated Stabilizer (Gauged Stabilizer of Original Code) ---
\begin{definition}[Symmetrized Stabilizer]
\label{def:symmetrized_stabilizer}
\lean{GaugingLDPC.SymmetrizedStabilizer}
\leanok

A \textbf{symmetrized stabilizer} $\overline{S}$ of the original code is a structure that bundles together:
\begin{enumerate}
    \item An operator $\overline{S}$ acting on gauged system states (the symmetrized/orbit-averaged operator)
    \item The support $\mathrm{Supp}(\overline{S})$: the set of matter qudits on which $\overline{S}$ acts non-trivially
    \item A Boolean flag indicating whether the original stabilizer $S$ was Hermitian
\end{enumerate}

The structure satisfies several key properties:
\begin{itemize}
    \item \textbf{Hermiticity preservation}: When the original stabilizer is Hermitian, so is $\overline{S}$. In amplitude representation: $\overline{S}\Psi(f) = \overline{\overline{S}\bar{\Psi}(f)}$ where $\bar{\Psi} = \overline{\Psi}$.
    \item \textbf{Linearity}: $\overline{S}(c \cdot \Psi) = c \cdot \overline{S}\Psi$ for constant scalars $c \in \mathbb{C}$.
    \item \textbf{Edge independence}: $\overline{S}$ acts only on matter, so edge-dependent phases factor out: $\overline{S}(\phi(f_E) \cdot \Psi) = \phi(f_E) \cdot \overline{S}\Psi$.
    \item \textbf{Edge shift commutativity}: $\overline{S}$ commutes with edge shifts since it acts only on matter.
    \item \textbf{Symmetry}: $\overline{S}$ is invariant under matter shifts (by construction as orbit average): for any vertex $v$ and shift $\sigma$, shifting matter qudits in $\Sigma(v)$ commutes with $\overline{S}$.
\end{itemize}
\end{definition}

\begin{definition}[Overlap Vertices]
\label{def:overlap_vertices}
\lean{GaugingLDPC.OverlapVertices}
\leanok
\uses{def:symmetrized_stabilizer}

The \textbf{overlap set} $\Omega(\overline{S})$ of a symmetrized stabilizer $\overline{S}$ is the set of vertices whose vertex sets intersect the support of $\overline{S}$:
\[
\Omega(\overline{S}) := \{v \in \mathcal{G}_0 : \Sigma(v) \cap \mathrm{Supp}(\overline{S}) \neq \emptyset\}
\]

Equivalently, $v \in \Omega(\overline{S})$ if and only if there exists a matter qudit $m \in \Sigma(v)$ such that $m \in \mathrm{Supp}(\overline{S})$.
\end{definition}

\begin{lemma}[Membership in Overlap Vertices]
\label{lem:mem_overlap_vertices}
\lean{GaugingLDPC.mem_overlapVertices}
\leanok
\uses{def:overlap_vertices}

A vertex $v$ belongs to the overlap set $\Omega(\overline{S})$ if and only if there exists $m \in M$ such that $m \in \Sigma(v)$ and $m \in \mathrm{Supp}(\overline{S})$.
\end{lemma}

\begin{proof}
\leanok
\uses{def:overlap_vertices}
By simplification using the definition of $\mathsf{OverlapVertices}$, which filters the universal set of vertices by the existence condition.
\end{proof}

\begin{definition}[Product Basis Projector]
\label{def:product_basis_projector}
\lean{GaugingLDPC.productBasisProjector}
\leanok

The \textbf{product basis projector} $\bigotimes_{v \in \Omega} |b_v\rangle\langle b_v|$ for a finite set $\Omega$ of vertices and an assignment $b : V \to \mathbb{F}_w$ is defined as:
\[
\left(\bigotimes_{v \in \Omega} |b_v\rangle\langle b_v|\right)\Psi(f_V, f_E, f_M) = 
\begin{cases}
\Psi(f_V, f_E, f_M) & \text{if } \forall v \in \Omega,\, f_V(v) = b(v) \\
0 & \text{otherwise}
\end{cases}
\]

This projects onto states where the vertex field $f_V$ agrees with $b$ on all vertices in $\Omega$.
\end{definition}

\begin{definition}[Symmetry Transformation $\mathsf{T}^b$]
\label{def:symmetry_transform_t}
\lean{GaugingLDPC.symmetryTransformT}
\leanok

The \textbf{symmetry transformation} $\mathsf{T}^b := \prod_{v \in \Omega} [\mathsf{T}|_{\Sigma(v)}]^{b_v}$ shifts matter qudits in $\Sigma(v)$ by $b(v)$ for each vertex $v$ in $\Omega$:
\[
(\mathsf{T}^b \Psi)(f_V, f_E, f_M) = \Psi\left(f_V, f_E, f_M'\right)
\]
where $f_M'(m) = f_M(m) - \sum_{v \in \Omega} [m \in \Sigma(v)] \cdot b(v)$, using Iverson bracket notation.
\end{definition}

\begin{definition}[Adjoint Symmetry Transformation $(\mathsf{T}^b)^\dagger$]
\label{def:symmetry_transform_t_adj}
\lean{GaugingLDPC.symmetryTransformTAdj}
\leanok
\uses{def:symmetry_transform_t}

The \textbf{adjoint (inverse) transformation} $(\mathsf{T}^b)^\dagger = \mathsf{T}^{-b}$ is defined as:
\[
((\mathsf{T}^b)^\dagger \Psi)(f_V, f_E, f_M) = \Psi\left(f_V, f_E, f_M'\right)
\]
where $f_M'(m) = f_M(m) + \sum_{v \in \Omega} [m \in \Sigma(v)] \cdot b(v)$.
\end{definition}

\begin{definition}[Conjugation by $\mathsf{T}^b$]
\label{def:conjugate_by_t}
\lean{GaugingLDPC.conjugateByT}
\leanok
\uses{def:symmetry_transform_t, def:symmetry_transform_t_adj}

The \textbf{conjugation} of an operator $O$ by $\mathsf{T}^b$ is:
\[
\mathsf{T}^b \cdot O \cdot (\mathsf{T}^b)^\dagger = \mathsf{T}^b \circ O \circ (\mathsf{T}^b)^\dagger
\]
\end{definition}

\begin{definition}[Decorated Stabilizer (Gauged Stabilizer of Original Code)]
\label{def:decorated__stabilizer_(_gauged__stabilizer_of__original__code)}
\lean{GaugingLDPC.decoratedStabilizer}
\leanok

Let $\overline{S}$ be a symmetrized stabilizer of the original code. The \textbf{decorated (gauged) stabilizer} is:
\[
\mathbb{S} := \mathfrak{D}(\overline{S}) = \sum_{\vec{b} \in \mathbb{F}_w^{|\Omega(\overline{S})|}} |\vec{b}\rangle\langle\vec{b}|_{\Omega(\overline{S})} \otimes \mathsf{T}^{\vec{b}} \overline{S} (\mathsf{T}^{\vec{b}})^\dagger
\]

where:
\begin{itemize}
    \item $\Omega(\overline{S}) := \{v \in \mathcal{G}_0 : \Sigma(v) \cap \mathrm{Supp}(\overline{S}) \neq \emptyset\}$ is the overlap set
    \item $\mathsf{T}^{\vec{b}} := \prod_{v_i \in \Omega(\overline{S})} [\mathsf{T}|_{\Sigma(v_i)}]^{b_i}$
    \item The sum is taken pointwise at each configuration $(f_V, f_E, f_M)$
\end{itemize}

Explicitly, for a state $\Psi$:
\[
(\mathbb{S}\Psi)(f_V, f_E, f_M) = \sum_{b : V \to \mathbb{F}_w} \left(\bigotimes_{v \in \Omega} |b_v\rangle\langle b_v|\right) \left(\mathsf{T}^b \overline{S} (\mathsf{T}^b)^\dagger \Psi\right)(f_V, f_E, f_M)
\]
\end{definition}

\begin{definition}[Hermitian Operator]
\label{def:is_hermitian_op}
\lean{GaugingLDPC.IsHermitianOp}
\leanok

An operator $O$ on the gauged system is \textbf{Hermitian} (self-adjoint), written $O^\dagger = O$, if for all states $\Psi$ and configurations $(f_V, f_E, f_M)$:
\[
(O\Psi)(f_V, f_E, f_M) = \overline{(O\bar{\Psi})(f_V, f_E, f_M)}
\]
where $\bar{\Psi}(f_V', f_E', f_M') = \overline{\Psi(f_V', f_E', f_M')}$ denotes pointwise complex conjugation.
\end{definition}

\begin{theorem}[Decorated Stabilizer is Hermitian]
\label{thm:decorated_stabilizer_hermitian}
\lean{GaugingLDPC.decoratedStabilizer_hermitian}
\leanok
\uses{def:decorated__stabilizer_(_gauged__stabilizer_of__original__code), def:is_hermitian_op, def:symmetrized_stabilizer}

If the original stabilizer $S$ is Hermitian (i.e., $\overline{S}.\mathsf{isHermitian} = \mathsf{true}$), then the decorated stabilizer $\mathbb{S} = \mathfrak{D}(\overline{S})$ is also Hermitian.
\end{theorem}

\begin{proof}
\leanok
\uses{def:decorated__stabilizer_(_gauged__stabilizer_of__original__code), def:is_hermitian_op}

We first establish that $\overline{S}.\mathsf{op}$ is Hermitian using the structure field $\mathsf{op\_hermitian}$. Let $\Psi$ be any state and $(f_V, f_E, f_M)$ any configuration.

By the definition of the decorated stabilizer, we have a sum over $b : V \to \mathbb{F}_w$. Complex conjugation distributes over finite sums, so we apply $\overline{\sum_b (\cdot)} = \sum_b \overline{(\cdot)}$.

For each term $b$, we consider the product basis projector. We split into cases:

\textbf{Case 1:} When the projector condition holds (i.e., $\forall v \in \Omega,\, f_V(v) = b(v)$):
We unfold the definitions of conjugation by $\mathsf{T}^b$, the symmetry transforms, and the adjoint. We apply the Hermitian property of $\overline{S}.\mathsf{op}$. The conjugation of the result follows because $\mathsf{T}^b$ commutes with conjugation since it only shifts the matter field $f_M$.

\textbf{Case 2:} When the projector condition fails:
Both sides equal $0$, and $\bar{0} = 0$.

Therefore $\mathbb{S}$ is Hermitian.
\end{proof}

\begin{definition}[Measurable Operator]
\label{def:is_measurable_op}
\lean{GaugingLDPC.IsMeasurableOp}
\leanok
\uses{def:product_basis_projector}

An operator $O$ is \textbf{measurable} if it can be written in the form:
\[
O = \sum_{b : V \to \mathbb{F}_w} P_b \cdot O_b
\]
where $P_b = \bigotimes_{v \in \Omega} |b_v\rangle\langle b_v|$ are orthogonal projectors for some finite set $\Omega$ of vertices, and $O_b$ are operators depending on $b$.
\end{definition}

\begin{theorem}[Decorated Stabilizer is Measurable]
\label{thm:decorated_stabilizer_measurable}
\lean{GaugingLDPC.decoratedStabilizer_measurable}
\leanok
\uses{def:decorated__stabilizer_(_gauged__stabilizer_of__original__code), def:is_measurable_op}

The decorated stabilizer $\mathbb{S} = \mathfrak{D}(\overline{S})$ is a measurable operator.
\end{theorem}

\begin{proof}
\leanok
\uses{def:decorated__stabilizer_(_gauged__stabilizer_of__original__code), def:is_measurable_op}

We take $\Omega = \Omega(\overline{S})$ (the overlap vertices) and $O_b = \mathsf{T}^b \overline{S} (\mathsf{T}^b)^\dagger$ (the conjugation of $\overline{S}$ by $\mathsf{T}^b$). By definition, the decorated stabilizer has exactly this form, so the result follows by reflexivity.
\end{proof}

\begin{theorem}[Decorated Stabilizer Commutes with Plaquette Stabilizers]
\label{thm:decorated_stabilizer_commutes_plaquette}
\lean{GaugingLDPC.decoratedStabilizer_commutes_plaquette}
\leanok
\uses{def:decorated__stabilizer_(_gauged__stabilizer_of__original__code), def:gauged__stabilizers_(_vertex_and__plaquette__terms)}

The decorated stabilizer $\mathbb{S}$ commutes with all plaquette stabilizers $\mathbb{B}_p$:
\[
\mathbb{S} \circ \mathbb{B}_p = \mathbb{B}_p \circ \mathbb{S}
\]
for all plaquettes $p$.
\end{theorem}

\begin{proof}
\leanok
\uses{def:decorated__stabilizer_(_gauged__stabilizer_of__original__code), def:gauged__stabilizers_(_vertex_and__plaquette__terms)}

By extensionality, it suffices to show equality for arbitrary $\Psi$, $f_V$, $f_E$, $f_M$.

Unfolding definitions, we have:
\begin{align*}
(\mathbb{S}(\mathbb{B}_p \Psi))(f_V, f_E, f_M) &= \sum_b \left(\bigotimes_{v \in \Omega} |b_v\rangle\langle b_v|\right) \left(\mathsf{T}^b \overline{S} (\mathsf{T}^b)^\dagger (\mathbb{B}_p \Psi)\right)(f_V, f_E, f_M)
\end{align*}

Since $\mathbb{B}_p$ multiplies by a phase $\phi_p(f_E)$ that depends only on the edge configuration, we use the fact that multiplication distributes over sums: $\phi_p \cdot \sum_b (\cdot) = \sum_b \phi_p \cdot (\cdot)$.

For each term $b$, we split on whether the projector condition holds:

\textbf{Case 1:} When $\forall v \in \Omega,\, f_V(v) = b(v)$:
We unfold the definitions of $\mathsf{T}^b$, $(\mathsf{T}^b)^\dagger$, and the plaquette stabilizer. The key observation is that $(\mathsf{T}^b)^\dagger$ shifts only $f_M$, not $f_E$, so when we apply $\mathbb{B}_p$ first, we get:
\[
((\mathsf{T}^b)^\dagger (\mathbb{B}_p \Psi))(f_V', f_E', f_M') = \phi_p(f_E') \cdot ((\mathsf{T}^b)^\dagger \Psi)(f_V', f_E', f_M')
\]

We then apply the property $\mathsf{op\_edge\_phase}$ of the symmetrized stabilizer, which states that edge-dependent phases factor out. Taking $\phi = \phi_p$ (the plaquette $\mathcal{Z}$-phase), we obtain:
\[
\overline{S}(\phi_p(f_E') \cdot \Phi) = \phi_p(f_E) \cdot \overline{S}(\Phi)
\]

This shows that the plaquette phase factors through, yielding equality with the RHS.

\textbf{Case 2:} When the projector condition fails:
Both sides equal $0$, and $\phi_p \cdot 0 = 0$.

Therefore $\mathbb{S} \circ \mathbb{B}_p = \mathbb{B}_p \circ \mathbb{S}$.
\end{proof}

\begin{theorem}[Decorated Stabilizer Commutes with Vertex Stabilizers]
\label{thm:decorated_stabilizer_commutes_vertex}
\lean{GaugingLDPC.decoratedStabilizer_commutes_vertex}
\leanok
\uses{def:decorated__stabilizer_(_gauged__stabilizer_of__original__code), def:gauged__stabilizers_(_vertex_and__plaquette__terms)}

The decorated stabilizer $\mathbb{S}$ commutes with all vertex stabilizers $\mathbb{A}_v$:
\[
\mathbb{S} \circ \mathbb{A}_{v_0} = \mathbb{A}_{v_0} \circ \mathbb{S}
\]
for all vertices $v_0$.
\end{theorem}

\begin{proof}
\leanok
\uses{def:decorated__stabilizer_(_gauged__stabilizer_of__original__code), def:gauged__stabilizers_(_vertex_and__plaquette__terms), def:symmetrized_stabilizer}

By extensionality, it suffices to show equality for arbitrary $\Psi$, $f_V$, $f_E$, $f_M$.

Unfolding definitions, the LHS is $(\mathbb{S}(\mathbb{A}_{v_0}\Psi))(f_V, f_E, f_M)$ and the RHS is $(\mathbb{A}_{v_0}(\mathbb{S}\Psi))(f_V, f_E, f_M)$.

The vertex stabilizer $\mathbb{A}_{v_0}$ shifts:
\begin{itemize}
    \item $f_E \mapsto f_E - \partial_1(v_0, \cdot)$ (edge shift by boundary)
    \item $f_M|_{\Sigma(v_0)} \mapsto f_M|_{\Sigma(v_0)} - 1$ (matter shift on $\Sigma(v_0)$)
\end{itemize}

The projector condition $|b\rangle\langle b|$ depends only on $f_V$, which is unchanged by $\mathbb{A}_{v_0}$.

We apply $\mathsf{sum\_congr}$ to reduce to showing term-by-term equality for each $b$.

Unfolding the definitions of the projector, conjugation by $\mathsf{T}^b$, and the symmetry transforms:

\textbf{Case 1:} When the projector condition holds ($\forall v \in \Omega,\, f_V(v) = b(v)$):

Let $\delta(e) := \partial_1(v_0, e)$ be the edge shift.

\textbf{Step 1:} We expand the LHS. The composition $(\mathsf{T}^b)^\dagger \circ \mathbb{A}_{v_0}$ at $(f_V', f_E', f_M')$ evaluates to $\Psi$ at $(f_V', f_E' - \delta, f_M'')$ where:
\[
f_M''(m) = \begin{cases}
f_M'(m) + \sum_{v \in \Omega} [m \in \Sigma(v)] b(v) - 1 & \text{if } m \in \Sigma(v_0) \\
f_M'(m) + \sum_{v \in \Omega} [m \in \Sigma(v)] b(v) & \text{otherwise}
\end{cases}
\]

\textbf{Step 2:} We apply the property $\mathsf{op\_edge\_shift}$ of the symmetrized stabilizer. This allows us to move the edge shift $-\delta$ from inside the operator to the output evaluation point. Specifically:
\[
\overline{S}(\Psi(\cdot, f_E' - \delta, \cdot))(f_V, f_E, f_M - \mathsf{T}^b) = \overline{S}(\Psi)(f_V, f_E - \delta, f_M - \mathsf{T}^b)
\]

\textbf{Step 3:} We apply the property $\mathsf{symmetric}$ of the symmetrized stabilizer with vertex $v_0$ and shift $-1$. Since $\overline{S}$ is symmetric (invariant under matter shifts by construction as orbit average), shifting matter by $-1$ on $\Sigma(v_0)$ inside the operator is equivalent to shifting in the output:
\[
\overline{S}(\Psi(\cdot, \cdot, f_M' - 1 \text{ on } \Sigma(v_0)))(f_V, f_E - \delta, f_M - \mathsf{T}^b)
\]
\[
= \overline{S}(\Psi)(f_V, f_E - \delta, (f_M - \mathsf{T}^b) - 1 \text{ on } \Sigma(v_0))
\]

Converting between these forms, we verify that the matter field arguments match by case analysis on whether $m \in \Sigma(v_0)$:
\begin{itemize}
    \item If $m \in \Sigma(v_0)$: both sides have $f_M(m) - \sum_v [m \in \Sigma(v)] b(v) - 1$
    \item If $m \notin \Sigma(v_0)$: both sides have $f_M(m) - \sum_v [m \in \Sigma(v)] b(v)$
\end{itemize}

This follows by ring arithmetic in $\mathbb{F}_w$.

\textbf{Case 2:} When the projector condition fails:
Both sides are $0$ by reflexivity.

Therefore $\mathbb{S} \circ \mathbb{A}_{v_0} = \mathbb{A}_{v_0} \circ \mathbb{S}$.
\end{proof}

%--- Thm_2: Equivalence of Algebraic and Circuit Gauging ---
\begin{definition}[Path System]
\label{def:path_system}
\lean{GaugingLDPC.PathSystem}
\leanok

A \emph{path system} from a root vertex $r$ in an oriented graph $G = (V, E)$ over $\mathbb{Z}_p$ consists of:
\begin{itemize}
  \item A root vertex $r \in V$
  \item For each vertex $v \in V$, a $1$-chain $\gamma(v \to r) \in \mathbb{Z}_p^E$ (the path-chain from $v$ to $r$)
\end{itemize}
satisfying:
\begin{enumerate}
  \item \textbf{Boundary condition:} For all $v \in V$,
    \[
      \partial_1(\gamma(v \to r)) = \delta_r - \delta_v
    \]
    where $\delta_w$ denotes the Dirac delta $0$-chain at vertex $w$.
  \item \textbf{Triviality at root:} $\gamma(r \to r) = 0$.
\end{enumerate}
This structure encodes a spanning tree of the graph, where $\gamma(v \to r)$ represents the unique path from $v$ to the root $r$ in the tree.
\end{definition}

\begin{proof}
\leanok
No proof needed for definitions.
\end{proof}

\begin{lemma}[Path Chain Root Boundary]
\label{lem:path_chain_root_boundary}
\lean{GaugingLDPC.PathSystem.pathChain_root_boundary}
\leanok
\uses{def:path_system}

For a path system with root $r$, the boundary of the path-chain from $r$ to itself is zero:
\[
  \partial_1(\gamma(r \to r)) = 0
\]
\end{lemma}

\begin{proof}
\leanok
\uses{def:path_system}
By the triviality at root condition, $\gamma(r \to r) = 0$. Applying the boundary map to zero gives zero by linearity.
\end{proof}

\begin{definition}[Total Charge Function]
\label{def:total_charge_fun}
\lean{GaugingLDPC.totalChargeFun}
\leanok

For a function-based charge distribution $\chi : V \to \mathbb{Z}_p$, the \emph{total charge} is defined as:
\[
  \chi_{\mathrm{tot}} := \sum_{v \in V} \chi(v)
\]
\end{definition}

\begin{proof}
\leanok
No proof needed for definitions.
\end{proof}

\begin{definition}[Charge Neutrality for Functions]
\label{def:is_charge_neutral_fun}
\lean{GaugingLDPC.IsChargeNeutralFun}
\leanok
\uses{def:total_charge_fun}

A function-based charge distribution $\chi : V \to \mathbb{Z}_p$ is \emph{charge-neutral} if its total charge is zero:
\[
  \chi_{\mathrm{tot}} = \sum_{v \in V} \chi(v) = 0
\]
\end{definition}

\begin{proof}
\leanok
No proof needed for definitions.
\end{proof}

\begin{lemma}[Total Charge of Zero Distribution]
\label{lem:total_charge_fun_zero}
\lean{GaugingLDPC.totalChargeFun_zero}
\leanok
\uses{def:total_charge_fun}

The total charge of the zero distribution is zero:
\[
  \sum_{v \in V} 0 = 0
\]
\end{lemma}

\begin{proof}
\leanok
\uses{def:total_charge_fun}
This follows by simplification: the sum of constantly zero terms over any finite set is zero.
\end{proof}

\begin{lemma}[Zero Distribution is Charge-Neutral]
\label{lem:is_charge_neutral_fun_zero}
\lean{GaugingLDPC.isChargeNeutralFun_zero}
\leanok
\uses{def:is_charge_neutral_fun, lem:total_charge_fun_zero}

The zero distribution $\chi \equiv 0$ is charge-neutral.
\end{lemma}

\begin{proof}
\leanok
\uses{lem:total_charge_fun_zero}
By the definition of charge neutrality and the fact that the total charge of the zero distribution is zero.
\end{proof}

\begin{definition}[Alpha from Path System]
\label{def:alpha_from_path_system}
\lean{GaugingLDPC.alphaFromPathSystem}
\leanok
\uses{def:path_system}

Given an oriented graph $G$, a path system $\gamma$, and a charge distribution $\chi : V \to \mathbb{Z}_p$, the \emph{$1$-chain $\alpha(\chi)$} is defined as:
\[
  \alpha(\chi) := \sum_{v \in V} (-\chi(v)) \cdot \gamma(v \to r)
\]
This is the gauge field configuration produced by the circuit construction.
\end{definition}

\begin{proof}
\leanok
No proof needed for definitions.
\end{proof}

\begin{lemma}[Alpha of Zero is Zero]
\label{lem:alpha_from_path_system_zero}
\lean{GaugingLDPC.alphaFromPathSystem_zero}
\leanok
\uses{def:alpha_from_path_system}

For any path system $\gamma$:
\[
  \alpha(0) = 0
\]
\end{lemma}

\begin{proof}
\leanok
\uses{def:alpha_from_path_system}
By definition, $\alpha(0) = \sum_{v \in V} (-0) \cdot \gamma(v \to r) = \sum_{v \in V} 0 \cdot \gamma(v \to r) = 0$.
\end{proof}

\begin{lemma}[Boundary of Alpha for Charge-Neutral Distributions]
\label{lem:alpha_from_path_system_boundary_neutral}
\lean{GaugingLDPC.alphaFromPathSystem_boundary_neutral}
\leanok
\uses{def:alpha_from_path_system, def:is_charge_neutral_fun, def:path_system}

For a path system $\gamma$ and a charge-neutral distribution $\chi$ (i.e., $\chi_{\mathrm{tot}} = 0$):
\[
  \partial_1(\alpha(\chi)) = \chi
\]
where we identify $\chi$ with its corresponding $0$-chain.
\end{lemma}

\begin{proof}
\leanok
\uses{def:alpha_from_path_system, def:is_charge_neutral_fun, def:path_system}
We compute the boundary of $\alpha(\chi)$:
\begin{align*}
  \partial_1(\alpha(\chi)) &= \partial_1\left(\sum_{v \in V} (-\chi(v)) \cdot \gamma(v \to r)\right) \\
  &= \sum_{v \in V} (-\chi(v)) \cdot \partial_1(\gamma(v \to r)) \\
  &= \sum_{v \in V} (-\chi(v)) \cdot (\delta_r - \delta_v)
\end{align*}
by linearity of the boundary map and the path boundary property.

Distributing the scalar multiplication:
\[
  = \sum_{v \in V} (-\chi(v)) \cdot \delta_r - \sum_{v \in V} (-\chi(v)) \cdot \delta_v
\]

For the root sum:
\[
  \sum_{v \in V} (-\chi(v)) \cdot \delta_r = \left(-\sum_{v \in V} \chi(v)\right) \cdot \delta_r = (-\chi_{\mathrm{tot}}) \cdot \delta_r
\]

Since $\chi$ is charge-neutral, $\chi_{\mathrm{tot}} = 0$, so this term vanishes. We are left with:
\[
  0 - \sum_{v \in V} (-\chi(v)) \cdot \delta_v = \sum_{v \in V} \chi(v) \cdot \delta_v = \chi
\]
where the last equality identifies the function $\chi$ with its corresponding $0$-chain.
\end{proof}

\begin{definition}[Circuit Gauging Map]
\label{def:circuit_gauging_map}
\lean{GaugingLDPC.circuitGaugingMap}
\leanok
\uses{def:is_charge_neutral_fun, def:alpha_from_path_system, def:path_system, def:charge__projection_(_multi__site__distribution)}

The \emph{circuit-based gauging map} is defined as follows. For an operator $O$ with charge decomposition $O = \sum_\chi \llbracket O \rrbracket_\chi$ (by the completeness of charge expansion), the circuit produces:
\[
  \mathfrak{D}_{\mathrm{circ}}(O) := \sum_{\substack{\chi : V \to \mathbb{Z}_p \\ \chi_{\mathrm{tot}} = 0}} \llbracket O \rrbracket_\chi \otimes Z(\alpha(\chi))
\]
where $\alpha(\chi)$ is determined by the path system.

The circuit projects onto charge-neutral configurations because the measurement $\langle +| Z^{\chi_{\mathrm{tot}}} |+\rangle = \delta_{\chi_{\mathrm{tot}}, 0}$.
\end{definition}

\begin{proof}
\leanok
No proof needed for definitions.
\end{proof}

\begin{lemma}[CX Commutes with Matter Operators]
\label{lem:u_cx_commutes_with_matter}
\lean{GaugingLDPC.U_CX_commutes_with_matter}
\leanok
\uses{def:circuit__unitaries_for__gauging}

The unitary $U_{\mathrm{CX}}$ acts only on the gauge system (vertex and edge ancillas) and commutes with operators $O$ acting on the matter system:
\[
  U_{\mathrm{CX}} \, O \, U_{\mathrm{CX}}^\dagger = O
\]
This follows from the definition: the edge-vertex entangling unitary only modifies edge configurations $f_E$, leaving matter configurations $f_M$ unchanged.
\end{lemma}

\begin{proof}
\leanok
\uses{def:circuit__unitaries_for__gauging}
By definition of the edge-vertex entangling unitary, it transforms edge configurations via addition based on vertex configurations. The matter part of the state remains unchanged. By simplification using the definition, the edge transformation is the identity on the matter component, and the equality holds by showing the overall transformation preserves the state value through ring arithmetic.
\end{proof}

\begin{lemma}[CT Conjugates Charge Components]
\label{lem:u_ct_conjugates_charge_component}
\lean{GaugingLDPC.U_CT_conjugates_charge_component}
\leanok
\uses{lem:covariance__property_of__charge__components, def:charge__projection_(_multi__site__distribution)}

Using the covariance property: $\varphi_g(\llbracket O \rrbracket_\chi) = \chi(g) \cdot \llbracket O \rrbracket_\chi$.

The controlled-$T$ applies symmetry conditionally on vertex ancilla state:
\[
  U_{\mathrm{CT}} (|g\rangle \otimes \llbracket O \rrbracket_\chi) U_{\mathrm{CT}}^\dagger = |g\rangle \otimes (\chi(g) \cdot \llbracket O \rrbracket_\chi)
\]
\end{lemma}

\begin{proof}
\leanok
\uses{lem:covariance__property_of__charge__components}
This follows directly from the multi-site charge projection covariance lemma, which establishes that the product action $\sigma_g$ on the charge component $\llbracket O \rrbracket_\chi$ equals the character value $\chi(g)$ times the charge component.
\end{proof}

\begin{lemma}[Measurement Projects Charge Neutral]
\label{lem:measurement_projects_charge_neutral}
\lean{GaugingLDPC.measurement_projects_charge_neutral}
\leanok

The measurement $\langle +|_r$ on the root vertex ancilla implements charge neutrality projection:
\[
  \langle +| Z_r^{\chi_{\mathrm{tot}}} |+\rangle = \delta_{\chi_{\mathrm{tot}}, 0}
\]
This is because $|+\rangle = \frac{1}{\sqrt{p}} \sum_j |j\rangle$ and $Z|j\rangle = \omega^j |j\rangle$ where $\omega = e^{2\pi i/p}$:
\[
  \langle +|Z^k|+\rangle = \frac{1}{p} \sum_j \omega^{jk} = \delta_{k,0}
\]
by character orthogonality.
\end{lemma}

\begin{proof}
\leanok

We consider two cases.

\textbf{Case 1:} $\chi_{\mathrm{tot}} = 0$. Then all terms in the sum are $\omega^0 = 1$, so the sum equals $p$, and $\frac{1}{p} \cdot p = 1$.

\textbf{Case 2:} $\chi_{\mathrm{tot}} \neq 0$. We use character orthogonality via the geometric series formula.

First, we establish that $\omega = e^{2\pi i/p}$ is a primitive $p$-th root of unity, so $\omega^p = 1$. For $0 < k < p$ (where $k = \chi_{\mathrm{tot}}.\mathrm{val}$), we have $\omega^k \neq 1$. This is shown by contradiction: if $\omega^k = 1$, then $\exp(k \cdot 2\pi i/p) = 1$, which by the characterization of when $\exp(z) = 1$ implies $k/p$ is an integer. But $0 < k < p$ implies $0 < k/p < 1$, a contradiction.

Let $r = \omega^k$. Since $r \neq 1$ and $r^p = \omega^{kp} = (\omega^p)^k = 1^k = 1$, we apply the geometric series formula:
\[
  \sum_{j=0}^{p-1} r^j = \frac{r^p - 1}{r - 1} = \frac{1 - 1}{r - 1} = 0
\]
Therefore $\frac{1}{p} \cdot 0 = 0$.
\end{proof}

\begin{theorem}[Equivalence of Algebraic and Circuit Gauging]
\label{thm:equivalence_of__algebraic_and__circuit__gauging}
\lean{GaugingLDPC.algebraic_eq_circuit_gauging}
\leanok
\uses{def:circuit__unitaries_for__gauging}

Let $\mathfrak{D}(O)$ be the algebraic gauging map (Definition 4) and $\mathfrak{D}_{\mathrm{circ}}(O)$ be the circuit gauging map. When the spanning basis $T_1$ corresponds to the path system $\gamma$:
\[
  \mathfrak{D}(O) = \mathfrak{D}_{\mathrm{circ}}(O)
\]

Both constructions:
\begin{enumerate}
  \item Decompose $O = \sum_\chi \llbracket O \rrbracket_\chi$ by completeness of charge expansion
  \item For each $\chi$, attach gauge field operator $Z(\alpha(\chi))$
  \item Only charge-neutral $\chi$ contribute (circuit: measurement projection; algebraic: combined with charge neutrality for symmetrized operators)
  \item The $\alpha(\chi)$ constructions coincide when $T_1 \leftrightarrow$ path system $\gamma$
\end{enumerate}

The key insight is that both constructions solve the boundary equation $\partial_1(\alpha) = \pm\chi$ using the same spanning tree structure.
\end{theorem}

\begin{proof}
\leanok
\uses{def:circuit__unitaries_for__gauging, def:circuit_gauging_map, lem:charge__neutrality_of__symmetrized__operators}
We show that the algebraic and circuit gauging maps produce the same result by comparing their definitions term by term.

Both maps are sums over charge distributions $\chi : V \to \mathbb{Z}_p$. By applying the sum congruence principle, it suffices to show that each term agrees.

For each $\chi$, we consider two cases:

\textbf{Case 1: Charge-neutral} ($\chi_{\mathrm{tot}} = 0$). In this case, we need to show the tensor products agree. Since the first components (the charge projections $\llbracket O \rrbracket_\chi$) are identical, it suffices to show the gauge $Z$-operators agree. By the correspondence hypothesis between the spanning basis and path system, the algebraic $\alpha$-map and the path system $\alpha$-map produce the same gauge $Z$-operator. The charge-neutral condition implies exactness (by the neutral-iff-exact hypothesis, which follows from vanishing of reduced zeroth homology for connected graphs), so the correspondence hypothesis applies.

\textbf{Case 2: Not charge-neutral} ($\chi_{\mathrm{tot}} \neq 0$). The circuit map gives $0$ by the conditional. For the algebraic map, by the hypothesis that non-neutral projections vanish (which follows from charge neutrality of symmetrized operators), we have $\llbracket O \rrbracket_\chi = 0$. Thus $0 \otimes Z(\alpha) = 0$ by the property that tensoring zero with anything yields zero.
\end{proof}

\begin{lemma}[Circuit Gauging Map of Zero]
\label{lem:circuit_gauging_map_zero}
\lean{GaugingLDPC.circuitGaugingMap_zero}
\leanok
\uses{def:circuit_gauging_map}

The circuit gauging map of the zero operator is zero:
\[
  \mathfrak{D}_{\mathrm{circ}}(0) = 0
\]
\end{lemma}

\begin{proof}
\leanok
\uses{def:circuit_gauging_map}
We show that each term in the sum defining $\mathfrak{D}_{\mathrm{circ}}(0)$ is zero.

For each charge distribution $\chi$, if $\chi$ is charge-neutral, then the charge projection of zero is zero (since the symmetry action fixes zero), so $\llbracket 0 \rrbracket_\chi = 0$. Thus the tensor product $0 \otimes Z(\alpha(\chi)) = 0$.

If $\chi$ is not charge-neutral, the term is $0$ by definition.

Since every term is zero, the sum is zero.
\end{proof}

\begin{lemma}[Circuit Gauging Map is Additive]
\label{lem:circuit_gauging_map_add}
\lean{GaugingLDPC.circuitGaugingMap_add}
\leanok
\uses{def:circuit_gauging_map}

The circuit gauging map is additive:
\[
  \mathfrak{D}_{\mathrm{circ}}(O_1 + O_2) = \mathfrak{D}_{\mathrm{circ}}(O_1) + \mathfrak{D}_{\mathrm{circ}}(O_2)
\]
\end{lemma}

\begin{proof}
\leanok
\uses{def:circuit_gauging_map}
By definition of the circuit gauging map, we have sums over charge distributions. Using the sum addition distribution property, we can combine the sums.

For each charge distribution $\chi$, we consider two cases:

\textbf{Charge-neutral case:} The charge projection is additive, i.e., $\llbracket O_1 + O_2 \rrbracket_\chi = \llbracket O_1 \rrbracket_\chi + \llbracket O_2 \rrbracket_\chi$. This holds because the symmetry product action distributes over addition (since it is an automorphism), and scalar multiplication distributes over addition. By the tensor product addition property:
\[
  (\llbracket O_1 \rrbracket_\chi + \llbracket O_2 \rrbracket_\chi) \otimes Z(\alpha(\chi)) = \llbracket O_1 \rrbracket_\chi \otimes Z(\alpha(\chi)) + \llbracket O_2 \rrbracket_\chi \otimes Z(\alpha(\chi))
\]

\textbf{Non-neutral case:} Both terms are $0$, and $0 + 0 = 0$.
\end{proof}

\begin{lemma}[Circuit Order Independence]
\label{lem:circuit_order_independent}
\lean{GaugingLDPC.circuit_order_independent}
\leanok
\uses{def:circuit__unitaries_for__gauging}

The circuit construction is independent of the ordering of $U_{\mathrm{CX}}$ and $U_{\mathrm{CT}}$:
\[
  U_{\mathrm{CX}} \circ U_{\mathrm{CT}} = U_{\mathrm{CT}} \circ U_{\mathrm{CX}}
\]
This follows from the commutativity theorem for the circuit unitaries.
\end{lemma}

\begin{proof}
\leanok
\uses{def:circuit__unitaries_for__gauging}
This follows directly from the unitaries commute theorem established in the circuit unitaries for gauging definition.
\end{proof}

%--- Def_8: Cheeger Constant (Isoperimetric Constant) ---
\begin{definition}[Edge Boundary]
\label{def:edge_boundary}
\lean{SimpleGraph.edgeBoundary}
\leanok

Let $G = (V, E)$ be a simple graph and let $U \subseteq V$ be a set of vertices. The \textbf{edge boundary} of $U$, denoted $\partial U$, is the set of edges with exactly one endpoint in $U$:
\[
\partial U := \{e \in E : e = \{v, w\} \text{ where } (v \in U \land w \notin U) \lor (v \notin U \land w \in U)\}.
\]
\end{definition}

\begin{lemma}[Membership in Edge Boundary]
\label{lem:mem_edge_boundary_iff}
\lean{SimpleGraph.mem_edgeBoundary_iff}
\leanok
\uses{def:edge_boundary}

An edge $e$ belongs to the edge boundary $\partial U$ if and only if $e \in E$ and there exist vertices $v, w$ such that $e = \{v, w\}$ and exactly one of $v, w$ belongs to $U$.
\end{lemma}

\begin{proof}
\leanok

This follows directly from the definition of set membership in a separated set, i.e., by \texttt{Set.mem\_sep\_iff}.
\end{proof}

\begin{lemma}[Edge Boundary of Empty Set]
\label{lem:edge_boundary_empty}
\lean{SimpleGraph.edgeBoundary_empty}
\leanok
\uses{def:edge_boundary}

For any graph $G$, the edge boundary of the empty set is empty: $\partial \emptyset = \emptyset$.
\end{lemma}

\begin{proof}
\leanok
\uses{def:edge_boundary}
By extensionality, it suffices to show that no edge $e$ belongs to $\partial \emptyset$. We simplify using the definition of edge boundary. Suppose for contradiction that $e \in \partial \emptyset$. Then there exist $v, w$ such that $e = \{v, w\}$ and either $(v \in \emptyset \land w \notin \emptyset)$ or $(v \notin \emptyset \land w \in \emptyset)$. In the first case, $v \in \emptyset$ is a contradiction. In the second case, $w \in \emptyset$ is a contradiction. Thus $\partial \emptyset = \emptyset$.
\end{proof}

\begin{lemma}[Edge Boundary of Full Vertex Set]
\label{lem:edge_boundary_univ}
\lean{SimpleGraph.edgeBoundary_univ}
\leanok
\uses{def:edge_boundary}

For any graph $G$ with vertex set $V$, the edge boundary of the entire vertex set is empty: $\partial V = \emptyset$.
\end{lemma}

\begin{proof}
\leanok
\uses{def:edge_boundary}
By extensionality, it suffices to show that no edge $e$ belongs to $\partial V$. We simplify using the definition. For any edge $e = \{v, w\}$, both $v \in V$ and $w \in V$ (since $V$ is the universe), so neither condition $(v \in V \land w \notin V)$ nor $(v \notin V \land w \in V)$ can hold. The result follows by contradiction.
\end{proof}

\begin{lemma}[Edge Boundary Subset of Edge Set]
\label{lem:edge_boundary_subset_edge_set}
\lean{SimpleGraph.edgeBoundary_subset_edgeSet}
\leanok
\uses{def:edge_boundary}

For any graph $G$ and vertex set $U$, the edge boundary is a subset of the edge set: $\partial U \subseteq E$.
\end{lemma}

\begin{proof}
\leanok
\uses{def:edge_boundary}
Let $e \in \partial U$. By definition of edge boundary, $e$ is in the separated set $\{e \in E : \ldots\}$, so $e \in E$.
\end{proof}

\begin{lemma}[Edge Boundary of Complement]
\label{lem:edge_boundary_compl}
\lean{SimpleGraph.edgeBoundary_compl}
\leanok
\uses{def:edge_boundary}

The edge boundary is symmetric with respect to complementation: $\partial U^c = \partial U$.
\end{lemma}

\begin{proof}
\leanok
\uses{def:edge_boundary}
By extensionality, we prove both inclusions. For the forward direction, suppose $e \in \partial U^c$. Then $e \in E$ and there exist $v, w$ with $e = \{v, w\}$ such that either $(v \notin U \land w \in U)$ or $(v \in U \land w \notin U)$ (since membership in $U^c$ is equivalent to non-membership in $U$). Using double negation elimination, we can rewrite these conditions as $(w \in U \land v \notin U)$ or $(v \in U \land w \notin U)$, which shows $e \in \partial U$.

For the reverse direction, suppose $e \in \partial U$. Then $e \in E$ and there exist $v, w$ with $e = \{v, w\}$ such that either $(v \in U \land w \notin U)$ or $(v \notin U \land w \in U)$. Using double negation introduction, these become conditions on membership in $U^c$, showing $e \in \partial U^c$.
\end{proof}

\begin{definition}[Edge Crosses Set]
\label{def:edge_crosses_set}
\lean{SimpleGraph.edgeCrossesSet}
\leanok

A helper function to check if an edge with endpoints $v$ and $w$ crosses a vertex set $U$, i.e., has exactly one endpoint in $U$:
\[
\texttt{edgeCrossesSet}(U, v, w) := (v \in U \land w \notin U) \lor (v \notin U \land w \in U).
\]
\end{definition}

\begin{lemma}[Edge Crosses Set is Symmetric]
\label{lem:edge_crosses_set_symm}
\lean{SimpleGraph.edgeCrossesSet_symm}
\leanok
\uses{def:edge_crosses_set}

The predicate for crossing a set is symmetric in the endpoints: $\texttt{edgeCrossesSet}(U, v, w) = \texttt{edgeCrossesSet}(U, w, v)$.
\end{lemma}

\begin{proof}
\leanok
\uses{def:edge_crosses_set}
This follows by commutativity of disjunction and conjunction.
\end{proof}

\begin{definition}[Edge Boundary Finset]
\label{def:edge_boundary_finset}
\lean{SimpleGraph.edgeBoundaryFinset}
\leanok
\uses{def:edge_crosses_set}

For a finite graph $G$ with decidable adjacency and a finite vertex set $U$, the \textbf{edge boundary finset} is the finite set of boundary edges:
\[
\texttt{edgeBoundaryFinset}(G, U) := \{e \in E : \texttt{edgeCrossesSet}(U, v, w) \text{ where } e = \{v, w\}\}.
\]
\end{definition}

\begin{lemma}[Membership in Edge Boundary Finset]
\label{lem:mem_edge_boundary_finset_iff}
\lean{SimpleGraph.mem_edgeBoundaryFinset_iff}
\leanok
\uses{def:edge_boundary_finset, def:edge_crosses_set}

An edge $e$ is in $\texttt{edgeBoundaryFinset}(G, U)$ if and only if $e \in \texttt{edgeFinset}(G)$ and $e$ crosses $U$.
\end{lemma}

\begin{proof}
\leanok
\uses{def:edge_boundary_finset}
This follows directly from the definition of filter membership.
\end{proof}

\begin{lemma}[Edge Boundary Finset of Empty Set]
\label{lem:edge_boundary_finset_empty}
\lean{SimpleGraph.edgeBoundaryFinset_empty}
\leanok
\uses{def:edge_boundary_finset, def:edge_crosses_set}

For any finite graph $G$, $\texttt{edgeBoundaryFinset}(G, \emptyset) = \emptyset$.
\end{lemma}

\begin{proof}
\leanok
\uses{def:edge_boundary_finset, def:edge_crosses_set}
By extensionality, we show both inclusions. For the forward direction, suppose $e \in \texttt{edgeBoundaryFinset}(G, \emptyset)$. By case analysis on $e = \{v, w\}$, we simplify the crossing condition: since no vertex is in $\emptyset$, the condition $(v \in \emptyset \land w \notin \emptyset) \lor (v \notin \emptyset \land w \in \emptyset)$ reduces to $\texttt{false} \lor \texttt{false} = \texttt{false}$, a contradiction.

For the reverse direction, if $e \in \emptyset$ then we have a contradiction by the definition of the empty set.
\end{proof}

\begin{lemma}[Edge Boundary Finset of Full Set]
\label{lem:edge_boundary_finset_univ}
\lean{SimpleGraph.edgeBoundaryFinset_univ}
\leanok
\uses{def:edge_boundary_finset, def:edge_crosses_set}

For any finite graph $G$ with vertex type $V$, $\texttt{edgeBoundaryFinset}(G, \texttt{Finset.univ}) = \emptyset$.
\end{lemma}

\begin{proof}
\leanok
\uses{def:edge_boundary_finset, def:edge_crosses_set}
By extensionality. For the forward direction, suppose $e \in \texttt{edgeBoundaryFinset}(G, \texttt{univ})$. By case analysis on $e = \{v, w\}$, we simplify: since every vertex is in $\texttt{univ}$, the crossing condition becomes $\texttt{false}$, a contradiction.

For the reverse direction, membership in $\emptyset$ is a contradiction.
\end{proof}

\begin{lemma}[Edge Boundary Finset Cardinality Non-negative]
\label{lem:edge_boundary_finset_card_nonneg}
\lean{SimpleGraph.edgeBoundaryFinset_card_nonneg}
\leanok
\uses{def:edge_boundary_finset}

For any finite graph $G$ and vertex set $U$, $0 \leq |\texttt{edgeBoundaryFinset}(G, U)|$.
\end{lemma}

\begin{proof}
\leanok

The cardinality of any finset is a natural number, hence non-negative.
\end{proof}

\begin{definition}[Small Subset]
\label{def:is_small_subset}
\lean{SimpleGraph.IsSmallSubset}
\leanok

A subset $U$ of vertices is called \textbf{small} if it is non-empty and contains at most half the total number of vertices:
\[
\texttt{IsSmallSubset}(U) \iff U \neq \emptyset \land 2|U| \leq |V|.
\]
\end{definition}

\begin{definition}[Small Subsets]
\label{def:small_subsets}
\lean{SimpleGraph.smallSubsets}
\leanok
\uses{def:is_small_subset}

The set of all small subsets of the vertex set:
\[
\texttt{smallSubsets} := \{U : U \text{ is a small subset}\}.
\]
\end{definition}

\begin{lemma}[Small Subset Characterization]
\label{lem:is_small_subset_iff}
\lean{SimpleGraph.isSmallSubset_iff}
\leanok
\uses{def:is_small_subset}

A finset $U$ is a small subset if and only if $U$ is nonempty and $2|U| \leq |V|$.
\end{lemma}

\begin{proof}
\leanok
\uses{def:is_small_subset}
This holds by reflexivity of the definition.
\end{proof}

\begin{definition}[Expansion Ratio]
\label{def:expansion_ratio}
\lean{SimpleGraph.expansionRatio}
\leanok
\uses{def:edge_boundary_finset}

The \textbf{expansion ratio} of a vertex subset $U$ is the ratio of the number of boundary edges to the number of vertices in $U$:
\[
\texttt{expansionRatio}(G, U) := \frac{|\partial U|}{|U|}.
\]
\end{definition}

\begin{lemma}[Expansion Ratio Non-negative]
\label{lem:expansion_ratio_nonneg}
\lean{SimpleGraph.expansionRatio_nonneg}
\leanok
\uses{def:expansion_ratio}

For any graph $G$ and vertex set $U$, $\texttt{expansionRatio}(G, U) \geq 0$.
\end{lemma}

\begin{proof}
\leanok
\uses{def:expansion_ratio, def:edge_boundary_finset}
By definition, the expansion ratio is a quotient of two natural numbers cast to reals. We apply the fact that division of non-negative numbers is non-negative. Both $|\partial U|$ and $|U|$ are natural numbers, hence their casts to $\mathbb{R}$ are non-negative.
\end{proof}

\begin{definition}[Expansion Ratios]
\label{def:expansion_ratios}
\lean{SimpleGraph.expansionRatios}
\leanok
\uses{def:is_small_subset, def:expansion_ratio}

The set of all expansion ratios over small subsets:
\[
\texttt{expansionRatios}(G) := \{r \in \mathbb{R} : \exists U, \texttt{IsSmallSubset}(U) \land r = \texttt{expansionRatio}(G, U)\}.
\]
\end{definition}

\begin{definition}[Cheeger Constant (Isoperimetric Constant)]
\label{def:cheeger__constant_(_isoperimetric__constant)}
\lean{SimpleGraph.cheegerConstant}
\leanok
\uses{def:expansion_ratios}

The \textbf{Cheeger constant} (also called the \textbf{isoperimetric constant} or \textbf{edge expansion}) of a finite graph $G = (V, E)$ is defined as:
\[
h(G) := \inf_{U \subseteq V,\, 0 < |U| \leq |V|/2} \frac{|\partial U|}{|U|}
\]
where the infimum is taken over the set of expansion ratios of all small subsets. If no small subsets exist, the Cheeger constant is defined as $\inf \emptyset = 0$.

\textbf{Interpretation}: The Cheeger constant measures how well-connected the graph is. It quantifies the minimum ratio of boundary edges to subset size among all small subsets, providing a lower bound on how ``expansive'' the graph is.
\end{definition}

\begin{definition}[Expander Graph]
\label{def:is_expander_graph}
\lean{SimpleGraph.IsExpanderGraph}
\leanok
\uses{def:cheeger__constant_(_isoperimetric__constant)}

A graph $G$ is an \textbf{expander graph} if its Cheeger constant isat least 1:
\[
\texttt{IsExpanderGraph}(G) \iff h(G) \geq 1.
\]
This means that any small subset of vertices has a boundary at least as large as itself.
\end{definition}

\begin{theorem}[Cheeger Constant Non-negative]
\label{thm:cheeger_constant_nonneg}
\lean{SimpleGraph.cheegerConstant_nonneg}
\leanok
\uses{def:cheeger__constant_(_isoperimetric__constant), def:expansion_ratios, lem:expansion_ratio_nonneg}

If there exists at least one small subset (i.e., $\texttt{expansionRatios}(G) \neq \emptyset$), then the Cheeger constant is non-negative: $h(G) \geq 0$.
\end{theorem}

\begin{proof}
\leanok
\uses{def:cheeger__constant_(_isoperimetric__constant), def:expansion_ratios, lem:expansion_ratio_nonneg}
By definition, the Cheeger constant is the infimum of the set of expansion ratios. We apply the fact that the infimum of a set of non-negative reals is non-negative (\texttt{Real.sInf\_nonneg}). Let $r$ be an arbitrary element of $\texttt{expansionRatios}(G)$. Then there exists a small subset $U$ such that $r = \texttt{expansionRatio}(G, U)$. By the lemma on expansion ratio non-negativity, $r \geq 0$. Hence all elements of the set are non-negative, and so is their infimum.
\end{proof}

\begin{theorem}[Cheeger Constant Bounds Expansion Ratio]
\label{thm:cheeger_constant_le_expansion_ratio}
\lean{SimpleGraph.cheegerConstant_le_expansionRatio}
\leanok
\uses{def:cheeger__constant_(_isoperimetric__constant), def:expansion_ratio, def:is_small_subset, lem:expansion_ratio_nonneg}

For any small subset $U$, the Cheeger constant is at most the expansion ratio of $U$:
\[
h(G) \leq \texttt{expansionRatio}(G, U).
\]
\end{theorem}

\begin{proof}
\leanok
\uses{def:cheeger__constant_(_isoperimetric__constant), def:expansion_ratios, lem:expansion_ratio_nonneg}
By definition, the Cheeger constant is $\inf(\texttt{expansionRatios}(G))$. We apply \texttt{csInf\_le}, which requires showing:
\begin{enumerate}
    \item The set is bounded below: We claim $0$ is a lower bound. For any $r \in \texttt{expansionRatios}(G)$, there exists a small subset $W$ with $r = \texttt{expansionRatio}(G, W) \geq 0$ by the expansion ratio non-negativity lemma.
    \item The expansion ratio of $U$ is in the set: Since $U$ is a small subset, we have $\texttt{expansionRatio}(G, U) \in \texttt{expansionRatios}(G)$ by definition.
\end{enumerate}
Therefore $\inf(\texttt{expansionRatios}(G)) \leq \texttt{expansionRatio}(G, U)$.
\end{proof}

\begin{theorem}[Expander Graphs Have Large Expansion]
\label{thm:expander_expansion_ge_one}
\lean{SimpleGraph.expander_expansion_ge_one}
\leanok
\uses{def:is_expander_graph, def:expansion_ratio, def:is_small_subset, thm:cheeger_constant_le_expansion_ratio}

For an expander graph $G$, every small subset $U$ has expansion ratio at least 1:
\[
\texttt{IsExpanderGraph}(G) \Rightarrow \forall U,\, \texttt{IsSmallSubset}(U) \Rightarrow \texttt{expansionRatio}(G, U) \geq 1.
\]
\end{theorem}

\begin{proof}
\leanok
\uses{def:is_expander_graph, thm:cheeger_constant_le_expansion_ratio}
Let $G$ be an expander graph, so $h(G) \geq 1$ by definition. Let $U$ be a small subset. By the theorem that the Cheeger constant bounds expansion ratios, we have $h(G) \leq \texttt{expansionRatio}(G, U)$. By transitivity of $\leq$, we conclude $1 \leq h(G) \leq \texttt{expansionRatio}(G, U)$.
\end{proof}

\begin{theorem}[Expander Graphs Have Large Boundaries]
\label{thm:expander_edge_boundary_card_ge}
\lean{SimpleGraph.expander_edgeBoundary_card_ge}
\leanok
\uses{def:is_expander_graph, def:edge_boundary_finset, def:is_small_subset, thm:expander_expansion_ge_one}

For an expander graph $G$, every small subset $U$ satisfies $|U| \leq |\partial U|$:
\[
\texttt{IsExpanderGraph}(G) \Rightarrow \forall U,\, \texttt{IsSmallSubset}(U) \Rightarrow |U| \leq |\partial U|.
\]
\end{theorem}

\begin{proof}
\leanok
\uses{thm:expander_expansion_ge_one, def:expansion_ratio, def:is_small_subset}
Let $G$ be an expander and $U$ a small subset. By the previous theorem, $\texttt{expansionRatio}(G, U) \geq 1$. By definition of expansion ratio, this means $\frac{|\partial U|}{|U|} \geq 1$. Since $U$ is nonempty (as a small subset), we have $|U| > 0$, so $|U| > 0$ as a real number. Multiplying both sides of $1 \leq \frac{|\partial U|}{|U|}$ by $|U|$ (which preserves the inequality since $|U| > 0$), we get $|U| \leq |\partial U|$. Converting back from real to natural number inequality completes the proof.
\end{proof}

%--- Def_9: Gauging Graph Criteria ---
\section{Gauging Graph Criteria}

A \textbf{valid gauging graph} $\mathcal{G}$ for the gauging procedure must satisfy the following four criteria:

\begin{enumerate}
    \item \textbf{Bounded Degree}: The degree of the gauging graph $\mathcal{G}$ is bounded by a constant: $\max_{v \in \mathcal{G}_0} \deg(v) = O(1)$. This ensures the weight of $\mathbb{A}_v$ terms is bounded.
    
    \item \textbf{Sparse Cycles}: There exists a generating basis for cycles in $C_2(\mathcal{G})$ such that each basis cycle has constant weight $O(1)$. This ensures $|\text{Supp}(\mathbb{B}_p)| = O(1)$ for each $p \in \mathcal{G}_2$.
    
    \item \textbf{Constant Path for Charge Neutralization}: Define the set of paths for each stabilizer $S$:
    \[
    \Gamma(S) := \{\alpha \mid \partial_1 \alpha = \chi, \forall \chi \in C_0(S)\}
    \]
    where $C_0(S) := \{\chi : [[S]]_\chi \neq 0\}$ is the set of charge configurations in the support of $S$. We require $\min_{\alpha \in \Gamma(S)} \text{Wt}(\alpha) = O(1)$ for all stabilizer generators $S$.
    
    \item \textbf{Expansion}: The graph has Cheeger constant $h(\mathcal{G}) \geq 1$. This is required for distance preservation.
\end{enumerate}

\begin{definition}[Gauged Cell Complex to Simple Graph]
\label{def:gauged_cell_complex_to_simple_graph}
\lean{GaugingLDPC.GaugedCellComplex.toSimpleGraph}
\leanok
\uses{def:gauging_(_decoration__map)}

Given a gauged cell complex $G$ over a vertex set $V$, edge set $E$, and plaquette set $P$, we define the associated simple graph by forgetting orientation. Two vertices $v_1, v_2 \in V$ are adjacent if $v_1 \neq v_2$ and there exists an edge $e \in E$ such that either:
\begin{itemize}
    \item $\text{source}(e) = v_1$ and $\text{target}(e) = v_2$, or
    \item $\text{source}(e) = v_2$ and $\text{target}(e) = v_1$.
\end{itemize}
\end{definition}

\begin{proof}
\leanok

We verify the axioms of a simple graph. For symmetry: given $v_1 \neq v_2$ with a witnessing edge $e$, the same edge witnesses adjacency from $v_2$ to $v_1$ by considering the symmetric case. For irreflexivity: if $v$ were adjacent to itself, we would have $v \neq v$, which is a contradiction.
\end{proof}

\begin{definition}[Maximum Degree]
\label{def:max_degree}
\lean{GaugingLDPC.maxDegree}
\leanok

For a finite graph $G$ on a nonempty vertex set $V$, the \textbf{maximum degree} is defined as:
\[
\text{maxDegree}(G) := \sup_{v \in V} \deg_G(v)
\]
\end{definition}

\begin{definition}[Bounded Degree (Criterion 1)]
\label{def:bounded_degree}
\lean{GaugingLDPC.BoundedDegree}
\leanok
\uses{def:max_degree}

A graph $G$ has \textbf{bounded degree} with bound $d \in \mathbb{N}$ if its maximum degree satisfies:
\[
\text{maxDegree}(G) \leq d
\]
\end{definition}

\begin{theorem}[Degree Bounded by Maximum Degree]
\label{thm:degree_le_max_degree}
\lean{GaugingLDPC.degree_le_maxDegree}
\leanok
\uses{def:max_degree}

For any vertex $v$ in a finite nonempty graph $G$:
\[
\deg_G(v) \leq \text{maxDegree}(G)
\]
\end{theorem}

\begin{proof}
\leanok
\uses{def:max_degree}
By unfolding the definition of maximum degree, we have $\text{maxDegree}(G) = \sup_{u \in V} \deg_G(u)$. Since $v \in V$, the degree $\deg_G(v)$ is bounded above by this supremum.
\end{proof}

\begin{theorem}[Bounded Degree Implies Bounded Degree at Each Vertex]
\label{thm:bounded_degree_at_vertex}
\lean{GaugingLDPC.BoundedDegree.degree_at_vertex}
\leanok
\uses{def:bounded_degree, thm:degree_le_max_degree}

If $G$ has bounded degree with bound $d$, then for every vertex $v$:
\[
\deg_G(v) \leq d
\]
\end{theorem}

\begin{proof}
\leanok
\uses{thm:degree_le_max_degree, def:bounded_degree}
By transitivity: $\deg_G(v) \leq \text{maxDegree}(G) \leq d$, using Theorem~\ref{thm:degree_le_max_degree} and the bounded degree assumption.
\end{proof}

\begin{definition}[Incident Edges]
\label{def:incident_edges}
\lean{GaugingLDPC.incidentEdges}
\leanok
\uses{def:gauging_(_decoration__map)}

For a gauged cell complex $G$ and a vertex $v$, the set of \textbf{incident edges} is:
\[
\text{incidentEdges}(G, v) := \{e \in E \mid \text{source}(e) = v \lor \text{target}(e) = v\}
\]
\end{definition}

\begin{definition}[Vertex Stabilizer Support Bound]
\label{def:vertex_stabilizer_support_bound}
\lean{GaugingLDPC.vertexStabilizerSupportBound}
\leanok
\uses{def:incident_edges, def:gauging_(_decoration__map)}

For a gauged cell complex $G$, matter assignment $\sigma$, and vertex $v$, the \textbf{vertex stabilizer support bound} is:
\[
\text{vertexStabilizerSupportBound}(G, \sigma, v) := |\sigma(v)| + |\text{incidentEdges}(G, v)|
\]
This bounds the support weight of the vertex stabilizer $\mathbb{A}_v$.
\end{definition}

\begin{definition}[Plaquette Boundary Weight]
\label{def:plaquette_boundary_weight}
\lean{GaugingLDPC.plaquetteBoundaryWeight}
\leanok
\uses{def:gauging_(_decoration__map)}

The \textbf{weight of a plaquette boundary} for plaquette $p$ in a gauged cell complex $G$ is the number of edges with non-zero coefficient:
\[
\text{plaquetteBoundaryWeight}(G, p) := |\{e \in E \mid \partial_2(p)(e) \neq 0\}|
\]
\end{definition}

\begin{definition}[Sparse Cycle Basis (Criterion 2)]
\label{def:sparse_cycle_basis}
\lean{GaugingLDPC.SparseCycleBasis}
\leanok
\uses{def:plaquette_boundary_weight, def:gauging_(_decoration__map)}

A gauged cell complex $G$ has a \textbf{sparse cycle basis} with bound $d \in \mathbb{N}$ if:
\begin{enumerate}
    \item Every plaquette boundary has weight at most $d$: for all $p \in P$, $\text{plaquetteBoundaryWeight}(G, p) \leq d$.
    \item The plaquette boundaries generate all cycles (i.e., the first cohomology vanishes).
\end{enumerate}
\end{definition}

\begin{definition}[Plaquette Stabilizer Support]
\label{def:plaquette_stabilizer_support}
\lean{GaugingLDPC.plaquetteStabilizerSupport}
\leanok
\uses{def:gauging_(_decoration__map)}

The \textbf{support of plaquette stabilizer} $\mathbb{B}_p$ is the set of edges in its boundary:
\[
\text{plaquetteStabilizerSupport}(G, p) := \{e \in E \mid \partial_2(p)(e) \neq 0\}
\]
\end{definition}

\begin{theorem}[Sparse Cycles Implies Bounded Plaquette Support]
\label{thm:sparse_cycles_bounded_plaquette}
\lean{GaugingLDPC.sparseCycles_implies_bounded_plaquette_term}
\leanok
\uses{def:sparse_cycle_basis, def:plaquette_stabilizer_support, def:plaquette_boundary_weight}

If $G$ has a sparse cycle basis with bound $d$, then for every plaquette $p$:
\[
|\text{plaquetteStabilizerSupport}(G, p)| \leq d
\]
\end{theorem}

\begin{proof}
\leanok
\uses{def:sparse_cycle_basis, def:plaquette_stabilizer_support, def:plaquette_boundary_weight}
By rewriting using the fact that the plaquette stabilizer support cardinality equals the plaquette boundary weight (by reflexivity), we directly apply the plaquette weight bound from the sparse cycle basis assumption.
\end{proof}

\begin{definition}[Chain Weight]
\label{def:chain_weight}
\lean{GaugingLDPC.chainWeight}
\leanok

The \textbf{weight of a 1-chain} $\alpha : E \to \mathbb{Z}/w\mathbb{Z}$ is the cardinality of its support:
\[
\text{chainWeight}(\alpha) := |\text{supp}(\alpha)|
\]
\end{definition}

\begin{definition}[Neutralizing Path]
\label{def:neutralizing_path}
\lean{GaugingLDPC.IsNeutralizingPath}
\leanok
\uses{def:chain_weight, def:gauging_(_decoration__map)}

A \textbf{neutralizing path} for charge configuration $\chi : V \to \mathbb{Z}/w\mathbb{Z}$ in an oriented graph $G$ is a 1-chain $\alpha$ such that:
\[
\partial_1 \alpha = \chi
\]
where $\partial_1$ is the boundary map from 1-chains to 0-chains.
\end{definition}

\begin{definition}[Stabilizer Generator]
\label{def:stabilizer_generator}
\lean{GaugingLDPC.StabilizerGenerator}
\leanok
\uses{def:symmetrized__operator_(_orbit__average), def:gauging_(_decoration__map)}

A \textbf{stabilizer generator} with respect to an oriented graph $G$ consists of:
\begin{itemize}
    \item A symmetrized stabilizer $\bar{S}$
    \item A finite set of charge configurations $C_0(S) := \{\chi : [[S]]_\chi \neq 0\}$, which is the set of charge configurations with non-zero charge projection
    \item A proof that all charge configurations in $C_0(S)$ are exact (lie in $\text{im}(\partial_1)$)
\end{itemize}
\end{definition}

\begin{definition}[Constant Charge Neutralization Path (Criterion 3)]
\label{def:constant_charge_neutralization_path}
\lean{GaugingLDPC.ConstantChargeNeutralizationPath}
\leanok
\uses{def:stabilizer_generator, def:neutralizing_path, def:chain_weight, def:gauging_(_decoration__map)}

A gauged cell complex $G$ with stabilizer generators $\mathcal{S}$ satisfies the \textbf{constant charge neutralization path property} with bound $d \in \mathbb{N}$ if:

For each stabilizer $S \in \mathcal{S}$ and each charge configuration $\chi \in C_0(S)$, there exists a neutralizing path $\alpha$ such that:
\[
\partial_1 \alpha = \chi \quad \text{and} \quad \text{chainWeight}(\alpha) \leq d
\]

In other words, $\min_{\alpha \in \Gamma(S)} \text{Wt}(\alpha) = O(1)$ where $\Gamma(S) := \{\alpha \mid \partial_1 \alpha = \chi, \forall \chi \in C_0(S)\}$.
\end{definition}

\begin{definition}[Expansion Property (Criterion 4)]
\label{def:expansion_property}
\lean{GaugingLDPC.ExpansionProperty}
\leanok
\uses{def:cheeger__constant_(_isoperimetric__constant)}

A graph $G$ satisfies the \textbf{expansion property} if it is an expander graph, i.e., its Cheeger constant satisfies $h(G) \geq 1$.
\end{definition}

\begin{theorem}[Expansion Implies Cheeger Constant At Least One]
\label{thm:expansion_cheeger_ge_one}
\lean{GaugingLDPC.expansion_cheeger_ge_one}
\leanok
\uses{def:expansion_property, def:cheeger__constant_(_isoperimetric__constant)}

If a graph $G$ satisfies the expansion property, then its Cheeger constant is at least 1:
\[
h(G) \geq 1
\]
\end{theorem}

\begin{proof}
\leanok
\uses{def:expansion_property}
This follows directly from the definition of the expansion property, which asserts that the graph is an expander graph with Cheeger constant at least 1.
\end{proof}

\begin{definition}[Valid Gauging Graph]
\label{def:gauging__graph__criteria}
\lean{GaugingLDPC.ValidGaugingGraph}
\leanok
\uses{def:cheeger__constant_(_isoperimetric__constant), def:decorated__stabilizer_(_gauged__stabilizer_of__original__code), def:gauged__stabilizers_(_vertex_and__plaquette__terms), def:gauging_(_decoration__map)}

A \textbf{valid gauging graph} is a gauged cell complex $G$ with matter assignment $\sigma$ and stabilizer generators $\mathcal{S}$ that satisfies all four criteria:

\begin{enumerate}
    \item \textbf{Criterion 1 (Bounded Degree)}: There exists $d_1 \in \mathbb{N}$ such that $\text{maxDegree}(G) \leq d_1$.
    
    \item \textbf{Criterion 2 (Sparse Cycles)}: There exists $d_2 \in \mathbb{N}$ such that $G$ has a sparse cycle basis with bound $d_2$.
    
    \item \textbf{Criterion 3 (Constant Path)}: There exists $d_3 \in \mathbb{N}$ such that $G$ satisfies the constant charge neutralization path property with bound $d_3$.
    
    \item \textbf{Criterion 4 (Expansion)}: The associated simple graph satisfies the expansion property, i.e., $h(G) \geq 1$.
\end{enumerate}
\end{definition}

\begin{theorem}[Plaquette Stabilizer Has Bounded Weight]
\label{thm:plaquette_stabilizer_bounded_weight}
\lean{GaugingLDPC.ValidGaugingGraph.plaquetteStabilizer_bounded_weight}
\leanok
\uses{def:gauging__graph__criteria, def:plaquette_stabilizer_support, thm:sparse_cycles_bounded_plaquette}

For a valid gauging graph with cycle weight bound $d_2$, every plaquette stabilizer $\mathbb{B}_p$ has support cardinality at most $d_2$:
\[
|\text{Supp}(\mathbb{B}_p)| \leq d_2
\]
\end{theorem}

\begin{proof}
\leanok
\uses{thm:sparse_cycles_bounded_plaquette, def:gauging__graph__criteria}
This follows directly from Theorem~\ref{thm:sparse_cycles_bounded_plaquette} applied to Criterion 2 (sparse cycles) of the valid gauging graph.
\end{proof}

\begin{theorem}[Decorated Stabilizer Has Bounded Weight]
\label{thm:decorated_stabilizer_bounded_weight}
\lean{GaugingLDPC.ValidGaugingGraph.decoratedStabilizer_bounded_weight}
\leanok
\uses{def:gauging__graph__criteria, def:constant_charge_neutralization_path, def:neutralizing_path, def:chain_weight}

For a valid gauging graph with path weight bound $d_3$, every stabilizer generator $S \in \mathcal{S}$ and every charge configuration $\chi \in C_0(S)$ admits a neutralizing path $\alpha$ with:
\[
\partial_1 \alpha = \chi \quad \text{and} \quad \text{chainWeight}(\alpha) \leq d_3
\]
\end{theorem}

\begin{proof}
\leanok
\uses{def:gauging__graph__criteria, def:constant_charge_neutralization_path}
This follows directly from Criterion 3 (constant charge neutralization path) of the valid gauging graph definition.
\end{proof}

\begin{theorem}[Valid Gauging Graph Is Expander]
\label{thm:graph_is_expander}
\lean{GaugingLDPC.ValidGaugingGraph.graph_isExpander}
\leanok
\uses{def:gauging__graph__criteria, def:expansion_property}

A valid gauging graph satisfies the expansion property.
\end{theorem}

\begin{proof}
\leanok
\uses{def:gauging__graph__criteria}
This follows directly from Criterion 4 (expansion) of the valid gauging graph definition.
\end{proof}

\begin{theorem}[Small Subsets Have Large Boundaries]
\label{thm:small_subset_large_boundary}
\lean{GaugingLDPC.ValidGaugingGraph.small_subset_has_large_boundary}
\leanok
\uses{def:gauging__graph__criteria, def:expansion_property}

For a valid gauging graph $G$ and any small subset $U \subseteq V$:
\[
|U| \leq |\partial U|
\]
where $\partial U$ denotes the edge boundary of $U$.
\end{theorem}

\begin{proof}
\leanok
\uses{def:gauging__graph__criteria, def:expansion_property}
This follows from the expander property: by Criterion 4, the Cheeger constant satisfies $h(G) \geq 1$, which implies that for small subsets, the edge boundary cardinality is at least as large as the subset cardinality.
\end{proof}

\begin{theorem}[Cheeger Constant Implies Distance Bound]
\label{thm:cheeger_distance_bound}
\lean{GaugingLDPC.cheegerConstant_implies_distance_bound}
\leanok
\uses{def:gauging__graph__criteria, def:expansion_property, def:cheeger__constant_(_isoperimetric__constant)}

For a valid gauging graph $G$ and any small subset $U \subseteq V$, the expansion ratio satisfies:
\[
\text{expansionRatio}(G, U) \geq 1
\]
This ensures distance preservation of the gauged code.
\end{theorem}

\begin{proof}
\leanok
\uses{def:gauging__graph__criteria, def:expansion_property}
By Criterion 4, the graph $G$ satisfies the expansion property with Cheeger constant at least 1. For any small subset $U$, the expander property guarantees that the expansion ratio is at least 1.
\end{proof}

%--- Lem_4: Charge Convolution for Operator Products ---
\begin{lemma}[Charge Convolution for Operator Products]
\label{lem:charge__convolution_for__operator__products}
\lean{GaugingLDPC.chargeProjection_mul_convolution}
\leanok
\uses{lem:charge_projection_of_product_of_projections}

Let $A$ and $B$ be operators invariant under the symmetry $\mathsf{T}$. The charge components of their product $AB$ are given by the convolution of their individual components:
\[
\llbracket AB \rrbracket_{\boldsymbol{\mu}} = \sum_{\boldsymbol{\chi} + \boldsymbol{\eta} = \boldsymbol{\mu}} \llbracket A \rrbracket_{\boldsymbol{\chi}} \llbracket B \rrbracket_{\boldsymbol{\eta}}
\]
where the sum runs over all pairs of charge distributions $(\boldsymbol{\chi}, \boldsymbol{\eta})$ that sum to $\boldsymbol{\mu}$.
\end{lemma}

\begin{proof}
\leanok

We proceed in five steps.

\textbf{Step 1: Expand $A$ and $B$ using completeness.}
By the completeness of charge expansion (Lemma~\ref{lem:completeness_of_charge_expansion}), we have
\[
A = \sum_{\chi} \llbracket A \rrbracket_{\chi} \quad \text{and} \quad B = \sum_{\eta} \llbracket B \rrbracket_{\eta}.
\]

\textbf{Step 2: Expand the product using the sum expansions.}
We compute:
\[
AB = \left(\sum_{\chi} \llbracket A \rrbracket_{\chi}\right) \left(\sum_{\eta} \llbracket B \rrbracket_{\eta}\right) = \sum_{\chi, \eta} \llbracket A \rrbracket_{\chi} \llbracket B \rrbracket_{\eta}.
\]

\textbf{Step 3: Apply linearity of the charge projection.}
By the linearity of the multi-site charge projection (which distributes over sums), we obtain:
\[
\llbracket AB \rrbracket_{\mu} = \sum_{\chi, \eta} \llbracket \llbracket A \rrbracket_{\chi} \llbracket B \rrbracket_{\eta} \rrbracket_{\mu}.
\]

\textbf{Step 4: Apply orthogonality.}
We use the key orthogonality relation: for any charge distributions $\chi$, $\eta$, $\mu$,
\[
\llbracket \llbracket A \rrbracket_{\chi} \llbracket B \rrbracket_{\eta} \rrbracket_{\mu} = 
\begin{cases}
\llbracket A \rrbracket_{\chi} \llbracket B \rrbracket_{\eta} & \text{if } \chi + \eta = \mu, \\
0 & \text{otherwise}.
\end{cases}
\]
This holds because $\llbracket A \rrbracket_{\chi} \llbracket B \rrbracket_{\eta}$ already lies in the $(\chi + \eta)$-eigenspace (by the covariance property, Lemma~\ref{lem:covariance_property_of_charge_components}, and the multiplicativity of character values: $(\chi + \eta)(g) = \chi(g) \cdot \eta(g)$), so projecting onto $\mu \neq \chi + \eta$ gives zero.

\textbf{Step 5: Sum collapses to the convolution.}
Substituting the orthogonality relation, the double sum telescopes:
\[
\llbracket AB \rrbracket_{\mu} = \sum_{\substack{\chi, \eta \\ \chi + \eta = \mu}} \llbracket A \rrbracket_{\chi} \llbracket B \rrbracket_{\eta}.
\]
Using the change of variables $\eta = \mu - \chi$, this becomes:
\[
\llbracket AB \rrbracket_{\mu} = \sum_{\chi} \llbracket A \rrbracket_{\chi} \llbracket B \rrbracket_{\mu - \chi},
\]
which is precisely the convolution formula.
\end{proof}

\begin{lemma}[Multiplicativity of Multi-Site Character Values]
\label{lem:multi_site_character_value_add}
\lean{GaugingLDPC.multiSiteCharacterValue_add}
\leanok
\uses{lem:charge_projection_of_product_of_projections}

The multi-site character value is multiplicative in the charge distribution: for any charge distributions $\chi$ and $\eta$, and any group tuple $g$,
\[
(\chi + \eta)(g) = \chi(g) \cdot \eta(g).
\]
\end{lemma}

\begin{proof}
\leanok

By definition of the multi-site character value as a product over sites, we have:
\[
(\chi + \eta)(g) = \prod_{v \in C_0} (\chi + \eta)_v(g_v) = \prod_{v \in C_0} \chi_v(g_v) \cdot \eta_v(g_v).
\]
By the product rule for finite products and the fact that character addition satisfies $(\chi_v + \eta_v)(g_v) = \chi_v(g_v) \cdot \eta_v(g_v)$ (the multiplicativity of additive characters), we obtain:
\[
\prod_{v \in C_0} \chi_v(g_v) \cdot \eta_v(g_v) = \left(\prod_{v \in C_0} \chi_v(g_v)\right) \cdot \left(\prod_{v \in C_0} \eta_v(g_v)\right) = \chi(g) \cdot \eta(g).
\]
\end{proof}

\begin{lemma}[Covariance of Products of Charge Components]
\label{lem:charge_projection_mul_covariance}
\lean{GaugingLDPC.chargeProjection_mul_covariance}
\leanok
\uses{lem:charge_projection_of_product_of_projections}

The product of two charge components transforms under the symmetry with the combined eigenvalue: for any charge distributions $\chi$ and $\eta$, group tuple $g$, and operators $A$ and $B$,
\[
\sigma(g)\left(\llbracket A \rrbracket_{\chi} \cdot \llbracket B \rrbracket_{\eta}\right) = (\chi + \eta)(g) \cdot \left(\llbracket A \rrbracket_{\chi} \cdot \llbracket B \rrbracket_{\eta}\right).
\]
\end{lemma}

\begin{proof}
\leanok

Since the symmetry action is multiplicative (it is a ring homomorphism), we have:
\[
\sigma(g)\left(\llbracket A \rrbracket_{\chi} \cdot \llbracket B \rrbracket_{\eta}\right) = \sigma(g)\left(\llbracket A \rrbracket_{\chi}\right) \cdot \sigma(g)\left(\llbracket B \rrbracket_{\eta}\right).
\]
By the covariance property (Lemma~\ref{lem:covariance_property_of_charge_components}), each factor transforms with its respective eigenvalue:
\[
\sigma(g)\left(\llbracket A \rrbracket_{\chi}\right) = \chi(g) \cdot \llbracket A \rrbracket_{\chi}, \quad \sigma(g)\left(\llbracket B \rrbracket_{\eta}\right) = \eta(g) \cdot \llbracket B \rrbracket_{\eta}.
\]
Substituting and using the multiplicativity of character values $(\chi + \eta)(g) = \chi(g) \cdot \eta(g)$, we obtain:
\[
\sigma(g)\left(\llbracket A \rrbracket_{\chi} \cdot \llbracket B \rrbracket_{\eta}\right) = \chi(g) \cdot \eta(g) \cdot \llbracket A \rrbracket_{\chi} \cdot \llbracket B \rrbracket_{\eta} = (\chi + \eta)(g) \cdot \left(\llbracket A \rrbracket_{\chi} \cdot \llbracket B \rrbracket_{\eta}\right).
\]
\end{proof}

\begin{lemma}[Orthogonality of Charge Projections on Products]
\label{lem:charge_projection_of_product_of_projections}
\lean{GaugingLDPC.chargeProjection_of_product_of_projections}
\leanok
\uses{lem:charge_projection_of_product_of_projections}

The charge projection of a product of charge components satisfies an orthogonality relation:
\[
\llbracket \llbracket A \rrbracket_{\chi} \llbracket B \rrbracket_{\eta} \rrbracket_{\mu} = \delta_{\chi + \eta, \mu} \cdot \llbracket A \rrbracket_{\chi} \llbracket B \rrbracket_{\eta}
\]
where $\delta_{\chi + \eta, \mu}$ is the Kronecker delta. This is because $\llbracket A \rrbracket_{\chi} \llbracket B \rrbracket_{\eta}$ already lies in the $(\chi + \eta)$-eigenspace, so projecting onto $\mu \neq \chi + \eta$ gives zero.
\end{lemma}

\begin{proof}
\leanok

Let $P = \llbracket A \rrbracket_{\chi}$ and $Q = \llbracket B \rrbracket_{\eta}$. Expanding the charge projection definition and using the covariance property, for each group element $g$:
\[
\sigma(g)(P) = \chi(g) \cdot P, \quad \sigma(g)(Q) = \eta(g) \cdot Q.
\]

The charge projection of the product is:
\[
\llbracket PQ \rrbracket_{\mu} = \frac{1}{|G|} \sum_{g \in G} \overline{\mu(g)} \cdot \sigma(g)(PQ).
\]

Using multiplicativity of the action and the covariance relations:
\[
\sigma(g)(PQ) = \sigma(g)(P) \cdot \sigma(g)(Q) = \chi(g) \cdot P \cdot \eta(g) \cdot Q = (\chi + \eta)(g) \cdot PQ.
\]

Substituting:
\[
\llbracket PQ \rrbracket_{\mu} = \frac{1}{|G|} \sum_{g \in G} \overline{\mu(g)} \cdot (\chi + \eta)(g) \cdot PQ = \left(\frac{1}{|G|} \sum_{g \in G} \overline{\mu(g)} \cdot (\chi + \eta)(g)\right) \cdot PQ.
\]

By the orthogonality of characters, the sum evaluates to:
\[
\frac{1}{|G|} \sum_{g \in G} \overline{\mu(g)} \cdot (\chi + \eta)(g) = 
\begin{cases}
1 & \text{if } \chi + \eta = \mu, \\
0 & \text{otherwise}.
\end{cases}
\]

This completes the proof: when $\chi + \eta = \mu$, the normalization factor $p^{|C_0|}$ cancels, yielding $PQ$; when $\chi + \eta \neq \mu$, the sum is zero.
\end{proof}

%--- Lem_5: Gauging is a Homomorphism (up to Flux Equivalence) ---
\begin{definition}[Flux Equivalence]
\label{def:flux_equivalent}
\lean{GaugingLDPC.FluxEquivalent}
\leanok
\uses{def:gauged__stabilizers_(_vertex_and__plaquette__terms), def:gauging_(_decoration__map)}

Two decorated operators $X$ and $Y$ are \emph{flux-equivalent}, denoted $X \sim_{\mathbb{B}} Y$, if $X = Y \cdot \prod_p \mathbb{B}_p^{c_p}$ for some coefficients $c_p$. Since $\mathbb{B}_p$ acts as $Z(\partial_2 p)$ on the gauge part, this becomes:
\[
X = Y \cdot \left(1 \otimes Z\left(\sum_p c_p \cdot \partial_2 p\right)\right)
\]
for some $\sigma : P \to_0 \mathbb{Z}/p\mathbb{Z}$.
\end{definition}

\begin{definition}[Delta Chain]
\label{def:delta_chain}
\lean{GaugingLDPC.deltaChain}
\leanok
\uses{def:gauging_(_decoration__map)}

The \emph{delta chain} is defined as $\delta = \alpha_A + \alpha_B - \alpha_{AB}$, where $\alpha$ denotes the lifting map. This is the difference between the sum of individual liftings and the joint lifting:
\[
\delta(\chi_A, \chi_B) := B.\alpha(\chi_A) + B.\alpha(\chi_B) - B.\alpha(\chi_A + \chi_B)
\]
\end{definition}

\begin{lemma}[Linearity of Alpha]
\label{lem:alpha_of_chi_add}
\lean{GaugingLDPC.alphaOfChi_add}
\leanok
\uses{def:gauging_(_decoration__map)}

The map $\alpha_\chi$ is linear (additive) on exact charges. Since the restricted boundary $\partial_1 : T_1 \to \text{ExactChargeSubmodule}$ is a linear isomorphism, its inverse $\alpha_\chi$ is also linear. Therefore:
\[
\alpha(\chi_1 + \chi_2) = \alpha(\chi_1) + \alpha(\chi_2)
\]
\end{lemma}

\begin{proof}
\leanok
\uses{def:gauging_(_decoration__map)}

The sum $\alpha(\chi_1) + \alpha(\chi_2)$ lies in $T_1$ since $T_1$ is a submodule, which we verify by applying the submodule addition closure to $\alpha(\chi_1) \in T_1$ and $\alpha(\chi_2) \in T_1$. The boundary of this sum equals $\chi_1 + \chi_2$, which follows from applying the boundary map to the sum and using the boundary specification for each term:
\[
\partial_1(\alpha(\chi_1) + \alpha(\chi_2)) = \partial_1(\alpha(\chi_1)) + \partial_1(\alpha(\chi_2)) = \chi_1 + \chi_2
\]
By uniqueness of $\alpha_\chi$, we obtain the result.
\end{proof}

\begin{lemma}[Delta Chains are Zero]
\label{lem:delta_chain_eq_zero}
\lean{GaugingLDPC.deltaChain_eq_zero}
\leanok
\uses{def:delta_chain, lem:alpha_of_chi_add}

Since $\alpha$ is linear on exact charges:
\[
\delta = \alpha(\chi_1) + \alpha(\chi_2) - \alpha(\chi_1 + \chi_2) = \alpha(\chi_1) + \alpha(\chi_2) - (\alpha(\chi_1) + \alpha(\chi_2)) = 0
\]
\end{lemma}

\begin{proof}
\leanok
\uses{lem:alpha_of_chi_add}

By simplification using the linearity of $\alpha_\chi$ (Lemma~\ref{lem:alpha_of_chi_add}), the expression $\alpha(\chi_1) + \alpha(\chi_2) - \alpha(\chi_1 + \chi_2)$ reduces to $0$ by the subtraction identity.
\end{proof}

\begin{lemma}[Delta is a Cycle]
\label{lem:delta_is_cycle}
\lean{GaugingLDPC.delta_is_cycle}
\leanok
\uses{def:delta_chain, def:gauging_(_decoration__map)}

The delta chain is a 1-cycle: $\partial_1(\delta) = 0$.
\end{lemma}

\begin{proof}
\leanok
\uses{def:delta_chain, def:gauging_(_decoration__map)}

We compute:
\[
\partial_1 \delta = \partial_1 \alpha_A + \partial_1 \alpha_B - \partial_1 \alpha_{AB} = \chi_A + \chi_B - (\chi_A + \chi_B) = 0
\]
The proof proceeds by applying the boundary map to the difference, using the fact that boundary is additive, and then applying the specification that $\partial_1(\alpha(\chi)) = \chi$ for each term. The result follows by simplification.
\end{proof}

\begin{lemma}[Delta in Cycle Space]
\label{lem:delta_in_cycle_space}
\lean{GaugingLDPC.delta_in_cycleSpace}
\leanok
\uses{def:delta_chain, lem:delta_is_cycle}

The delta chain lies in the 1-cycle space $Z_1 = \ker(\partial_1)$.
\end{lemma}

\begin{proof}
\leanok
\uses{lem:delta_is_cycle}

Rewriting the membership condition in terms of the kernel of the linear map, this follows directly from Lemma~\ref{lem:delta_is_cycle}.
\end{proof}

\begin{lemma}[Delta is Boundary when $H^1$ Vanishes]
\label{lem:delta_is_boundary_when_h1_vanishes}
\lean{GaugingLDPC.delta_is_boundary_when_H1_vanishes}
\leanok
\uses{def:delta_chain, lem:delta_in_cycle_space}

When $H^1 = 0$, every 1-cycle is a boundary. Thus $\delta \in B_1 = \text{span}\{\partial_2 p : p \in P\}$.
\end{lemma}

\begin{proof}
\leanok
\uses{lem:delta_in_cycle_space}

From Lemma~\ref{lem:delta_in_cycle_space}, we have $\delta \in Z_1$. The hypothesis that $H^1 = 0$ means $Z_1 = B_1$, so rewriting with this equality gives $\delta \in B_1$.
\end{proof}

\begin{lemma}[Boundary as Sum of Plaquettes]
\label{lem:boundary_as_sum_of_plaquettes}
\lean{GaugingLDPC.boundary_as_sum_of_plaquettes}
\leanok
\uses{def:gauged__stabilizers_(_vertex_and__plaquette__terms)}

When $\delta \in B_1$, it can be written as $\delta = \sum_p c_p \cdot \partial_2 p$. Thus $Z(\delta) = \prod_p Z(\partial_2 p)^{c_p} = \prod_p \mathbb{B}_p^{c_p}$.
\end{lemma}

\begin{proof}
\leanok
\uses{def:gauged__stabilizers_(_vertex_and__plaquette__terms)}

Since $\delta \in B_1 = \text{span}\{\partial_2 p : p \in P\}$, we apply the characterization of submodule span membership. This gives us that $\delta$ lies in the span of the range of plaquette boundary chains. Using the characterization of membership in a span over a range, we obtain a function $c : P \to \mathbb{Z}/p\mathbb{Z}$ such that $\delta = \sum_q c_q \cdot \partial_2 q$. Converting this function to a finitely-supported function completes the proof.
\end{proof}

\begin{lemma}[Gauge Z Operator Finset Sum]
\label{lem:gauge_z_operator_finset_sum}
\lean{GaugingLDPC.gaugeZOperator_finset_sum}
\leanok
\uses{def:gauging_(_decoration__map)}

For finite sums: $Z\left(\sum_i \alpha_i\right) = \prod_i Z(\alpha_i)$.
\end{lemma}

\begin{proof}
\leanok
\uses{def:gauging_(_decoration__map)}

We proceed by induction on the finite set $s$. 

\textbf{Base case} ($s = \emptyset$): By simplification, the empty sum is $0$ and the empty product is $1$, and $Z(0) = 1$ by definition.

\textbf{Inductive step}: For a set with an inserted element $a$, we rewrite the sum over the insertion as the sum of $f(a)$ plus the sum over the remaining set, and similarly for the product. Then we apply the additive property of the gauge Z operator and the induction hypothesis.
\end{proof}

\begin{lemma}[Z Power Scalar Multiplication]
\label{lem:z_pow_smul}
\lean{GaugingLDPC.ZPow_smul}
\leanok
\uses{def:gauging_(_decoration__map)}

For scalar multiplication: $Z_e^{a \cdot k} = (Z_e^k)^{a}$ where the exponent is taken modulo $p$ since $(Z_e)^p = 1$.
\end{lemma}

\begin{proof}
\leanok
\uses{def:gauging_(_decoration__map)}

By the definition of $Z^{\text{Pow}}$ and using the power multiplication law, we have $(Z_e)^{(a \cdot k)} = (Z_e)^{(k \cdot a)}$. Applying the periodicity property of $Z^{\text{Pow}}$ (that powers depend only on the exponent modulo $p$) to both sides and using the congruence $(a \cdot k) \equiv a \cdot k \pmod{p}$, the result follows by ring arithmetic.
\end{proof}

\begin{lemma}[Gauge Z Operator Scalar Multiplication]
\label{lem:gauge_z_operator_smul}
\lean{GaugingLDPC.gaugeZOperator_smul}
\leanok
\uses{def:gauging_(_decoration__map), lem:z_pow_smul}

For scalar multiplication: $Z(a \cdot \alpha) = Z(\alpha)^a$.
\end{lemma}

\begin{proof}
\leanok
\uses{lem:z_pow_smul}

By the definition of the gauge Z operator as a product, we rewrite the goal using the power of a product formula. Then for each edge $e$, the scalar multiplication on the finitely-supported function gives $(a \cdot \alpha)(e) = a \cdot \alpha(e)$, and we apply Lemma~\ref{lem:z_pow_smul} to conclude.
\end{proof}

\begin{lemma}[Gauge Z Sum Decomposition]
\label{lem:gauge_z_sum_eq_gauge_z_joint_times_delta}
\lean{GaugingLDPC.gaugeZ_sum_eq_gaugeZ_joint_times_delta}
\leanok
\uses{def:delta_chain, def:gauging_(_decoration__map)}

The gauge factor decomposition: $Z(\alpha_A + \alpha_B) = Z(\alpha_{AB}) \cdot Z(\delta)$ where $\delta$ is the delta chain.
\end{lemma}

\begin{proof}
\leanok
\uses{def:delta_chain, def:gauging_(_decoration__map)}

We rewrite using the additive property of the gauge Z operator and then verify that the chains satisfy $(\alpha_A + \alpha_B) = \alpha_{AB} + \delta$ by the definition of the delta chain, which gives the identity by Abel group arithmetic.
\end{proof}

\begin{lemma}[Gauging Map Multiplication Expansion]
\label{lem:gauging_map_mul_expansion}
\lean{GaugingLDPC.gaugingMap_mul_expansion}
\leanok
\uses{def:gauging_(_decoration__map)}

The product $\mathfrak{D}(A)\mathfrak{D}(B)$ expands as a double sum over charge pairs:
\[
\mathfrak{D}(A)\mathfrak{D}(B) = \sum_{\chi,\eta} [\![A]\!]_\chi [\![B]\!]_\eta \otimes Z(\alpha_\chi)Z(\alpha_\eta) = \sum_{\chi,\eta} [\![A]\!]_\chi [\![B]\!]_\eta \otimes Z(\alpha_\chi + \alpha_\eta)
\]
Since $Z$ operators are diagonal (products of $Z_e$'s), they commute: $Z(\alpha_A)Z(\alpha_B) = Z(\alpha_A + \alpha_B)$.
\end{lemma}

\begin{proof}
\leanok
\uses{def:gauging_(_decoration__map)}

By the definition of the gauging map as a sum, the product of two gauging maps becomes a product of sums. Using the sum-times-sum formula, this expands to a double sum. For each pair $(\chi, \eta)$, the tensor product multiplication formula gives:
\[
(A_\chi \otimes Z(\alpha_\chi)) \cdot (B_\eta \otimes Z(\alpha_\eta)) = (A_\chi \cdot B_\eta) \otimes (Z(\alpha_\chi) \cdot Z(\alpha_\eta))
\]
Applying the additive property of the gauge Z operator completes the proof.
\end{proof}

\begin{axiom}[Gauge Factor for Non-Exact Component]
\label{ax:gauge_factor_nonexact_component}
\lean{GaugingLDPC.gauge_factor_nonexact_component_ax}
\leanok

\textbf{\color{red}[UNPROVEN ASSUMPTION]}

When $\mu$ is exact but $k$ is not, the gauge factor $Z(\alpha_\mu)$ equals $1$ for the term's contribution. This holds because non-exact charge projections contribute zero in the symmetry-invariant sector.

\textit{Note: This axiom was introduced because the full proof was not completed in the formalization.}
\end{axiom}

\begin{axiom}[Gauge Factor for Exact Component in Non-Exact Total]
\label{ax:gauge_factor_exact_component_in_nonexact_total}
\lean{GaugingLDPC.gauge_factor_exact_component_in_nonexact_total_ax}
\leanok

\textbf{\color{red}[UNPROVEN ASSUMPTION]}

When $\mu$ is NOT exact but $k$ IS exact (with $\mu - k$ not exact), the gauge factor $Z(\alpha_k) = 1$. This holds because when $\mu$ is not exact, the total charge projection vanishes, so the term's contribution is zero anyway.

\textit{Note: This axiom was introduced because the full proof was not completed in the formalization.}
\end{axiom}

\begin{axiom}[Convolution Reindex]
\label{ax:convolution_reindex}
\lean{GaugingLDPC.convolution_reindex_ax}
\leanok

\textbf{\color{red}[UNPROVEN ASSUMPTION]}

Sums over ChargeDistribution equal sums over $(V \to \mathbb{Z}/p\mathbb{Z})$ via the standardByIndex bijection, preserving the convolution structure:
\[
\sum_{\chi \in \text{ChargeDistribution}} [\![A]\!]_\chi \cdot [\![B]\!]_{\mu - \chi} = \sum_{\chi : V \to \mathbb{Z}/p\mathbb{Z}} [\![A]\!]_{\text{std}(\chi)} \cdot [\![B]\!]_{\text{std}(\mu - \chi)}
\]

\textit{Note: This axiom was introduced because the full proof was not completed in the formalization.}
\end{axiom}

\begin{lemma}[Flux Equivalence is Reflexive]
\label{lem:flux_equivalent_refl}
\lean{GaugingLDPC.fluxEquivalent_refl}
\leanok
\uses{def:flux_equivalent}

Flux equivalence is reflexive: $X \sim_{\mathbb{B}} X$ for all $X$.
\end{lemma}

\begin{proof}
\leanok
\uses{def:flux_equivalent}

We take $\sigma = 0$. Then the flux term with $c = 0$ becomes:
\[
1 \otimes Z\left(\sum_q 0 \cdot \partial_2 q\right) = 1 \otimes Z(0) = 1 \otimes 1 = 1
\]
Thus $X = X \cdot 1 = X$.
\end{proof}

\begin{lemma}[Flux Equivalence is Symmetric]
\label{lem:flux_equivalent_symm}
\lean{GaugingLDPC.fluxEquivalent_symm}
\leanok
\uses{def:flux_equivalent}

Flux equivalence is symmetric: if $X \sim_{\mathbb{B}} Y$ then $Y \sim_{\mathbb{B}} X$.
\end{lemma}

\begin{proof}
\leanok
\uses{def:flux_equivalent}

From the hypothesis, we obtain $\sigma$ such that $X = Y \cdot \text{flux}(\sigma)$. We take $-\sigma$ as our witness. The goal becomes $Y = X \cdot \text{flux}(-\sigma)$. Substituting $X = Y \cdot \text{flux}(\sigma)$, we need $Y = Y \cdot \text{flux}(\sigma) \cdot \text{flux}(-\sigma)$. We show that $\text{flux}(\sigma) \cdot \text{flux}(-\sigma) = 1$ by the tensor product multiplication formula, the additive property of the gauge Z operator, and the fact that $\sum_q \sigma_q \cdot \partial_2 q + \sum_q (-\sigma_q) \cdot \partial_2 q = 0$. Thus $Y = Y \cdot 1 = Y$.
\end{proof}

\begin{lemma}[Gauging is a Homomorphism up to Flux Equivalence]
\label{lem:gauging_is_a__homomorphism_(up_to__flux__equivalence)}
\lean{GaugingLDPC.gauging_homomorphism_up_to_flux}
\leanok
\uses{def:gauged__stabilizers_(_vertex_and__plaquette__terms), def:circuit__unitaries_for__gauging, lem:charge__convolution_for__operator__products}

For symmetry-invariant operators $A$ and $B$:
\[
\mathfrak{D}(A)\mathfrak{D}(B) \sim_{\mathbb{B}} \mathfrak{D}(AB)
\]
where $\sim_{\mathbb{B}}$ denotes equivalence modulo multiplication by flux stabilizers $\mathbb{B}_p$.

This is the central result: the gauging map preserves multiplication up to equivalence modulo flux stabilizers.
\end{lemma}

\begin{proof}
\leanok
\uses{ax:gauge_factor_nonexact_component, ax:gauge_factor_exact_component_in_nonexact_total, ax:convolution_reindex, lem:delta_is_boundary_when_h1_vanishes, lem:boundary_as_sum_of_plaquettes, lem:gauge_z_sum_eq_gauge_z_joint_times_delta, lem:gauging_map_mul_expansion, lem:delta_chain_eq_zero, lem:alpha_of_chi_add}

\textbf{\color{orange}[Uses unproven axioms: ax:gauge\_factor\_nonexact\_component, ax:gauge\_factor\_exact\_component\_in\_nonexact\_total, ax:convolution\_reindex]}

\textbf{Step 1:} Every delta chain is a boundary (since $H^1 = 0$). By Lemma~\ref{lem:delta_is_boundary_when_h1_vanishes}, for all exact charges $\chi_A, \chi_B$, we have $\delta(\chi_A, \chi_B) \in B_1$.

\textbf{Step 2:} Each delta chain can be written as a sum of plaquette boundaries. By Lemma~\ref{lem:boundary_as_sum_of_plaquettes}, there exists $\sigma' : P \to_0 \mathbb{Z}/p\mathbb{Z}$ such that $\delta(\chi_A, \chi_B) = \sum_q \sigma'_q \cdot \partial_2 q$.

\textbf{Key insight:} Since $\alpha_\chi$ is linear (Lemma~\ref{lem:alpha_of_chi_add}), ALL delta chains are zero by Lemma~\ref{lem:delta_chain_eq_zero}! Therefore the flux coefficient is $0$.

We take $\sigma = 0$. The flux term with $c = 0$ is $1 \otimes Z(0) = 1$, so the goal becomes:
\[
\mathfrak{D}(A) \cdot \mathfrak{D}(B) = \mathfrak{D}(AB)
\]

We verify $\sum_{\chi} \sum_{\eta} \delta(\chi, \eta) = 0$ using Lemma~\ref{lem:delta_chain_eq_zero}.

Using Lemma~\ref{lem:gauging_map_mul_expansion} for the left-hand side expansion, we rewrite as a product sum. We apply the fiber sum bijection to regroup by total charge $\mu = \chi + \eta$.

For fixed $\mu$, we establish that for any $k : V \to \mathbb{Z}/p\mathbb{Z}$:
\[
Z(\alpha_k + \alpha_{\mu-k}) = Z(\alpha_\mu)
\]
This follows by case analysis on exactness:
\begin{itemize}
\item If $\mu$, $k$, and $\mu-k$ are all exact: by linearity of $\alpha$, we have $\alpha_k + \alpha_{\mu-k} = \alpha_\mu$.
\item If $\mu$ is exact but $k$ is not: the gauge factor equals $1$ by the axiom for non-exact components.
\item If $\mu$ is not exact: if both $k$ and $\mu-k$ were exact, then $\mu$ would be exact (contradiction). The remaining cases use the axiom for exact components in non-exact totals.
\end{itemize}

After establishing the gauge factor equality, we factor out $Z(\alpha_\mu)$ from the sum. The remaining identity:
\[
[\![AB]\!]_\mu = \sum_\chi [\![A]\!]_\chi \cdot [\![B]\!]_{\mu-\chi}
\]
follows from the convolution theorem (Lemma~\ref{lem:charge__convolution_for__operator__products}) and the reindexing axiom.
\end{proof}

\begin{theorem}[Gauging is a Strict Homomorphism on Flux-Free Subspace]
\label{thm:gauging_strict_homomorphism_on_flux_free}
\lean{GaugingLDPC.gauging_strict_homomorphism_on_flux_free}
\leanok
\uses{lem:gauging_is_a__homomorphism_(up_to__flux__equivalence)}

When restricted to the flux-free code space (kernel of all flux stabilizers), the gauging map is an exact homomorphism. There exists $c : P \to_0 \mathbb{Z}/p\mathbb{Z}$ such that:
\[
\mathfrak{D}(A)\mathfrak{D}(B) = \mathfrak{D}(AB) \cdot \left(1 \otimes Z\left(\sum_q c_q \cdot \partial_2 q\right)\right)
\]
This is because the flux stabilizers act as identity on this subspace, so the flux equivalence becomes exact equality.
\end{theorem}

\begin{proof}
\leanok
\uses{lem:gauging_is_a__homomorphism_(up_to__flux__equivalence)}

This is just unpacking the flux equivalence definition from Lemma~\ref{lem:gauging_is_a__homomorphism_(up_to__flux__equivalence)}.
\end{proof}

%--- Lem_6: Weight Non Decrease Under Stabilizer Equivalence ---
\begin{definition}[Net Support Change]
\label{def:net_support_change}
\lean{GaugingLDPC.netSupportChange}
\leanok
\uses{def:cheeger__constant_(_isoperimetric__constant)}

Let $G = (V, E)$ be a simple graph and $U \subseteq V$ a finite subset of vertices. The \textbf{net support change} when trading vertex support for edge support is defined as:
\[
\Delta(U) := |\partial U| - |U|
\]
where $\partial U$ denotes the edge boundary of $U$, i.e., the set of edges with exactly one endpoint in $U$.
\end{definition}

\begin{lemma}[Support Change Non-Negative for Expanders]
\label{lem:weight__non__decrease__under__stabilizer__equivalence}
\lean{GaugingLDPC.support_change_nonneg}
\leanok
\uses{def:cheeger__constant_(_isoperimetric__constant), def:net_support_change}

Let $G = (V, E)$ be a simple graph that is an expander graph (i.e., $h(\mathcal{G}) \geq 1$). For any non-empty small subset $U \subseteq V$, the net support change is non-negative:
\[
\Delta(U) = |\partial U| - |U| \geq 0
\]

This is the core combinatorial fact: when $h(\mathcal{G}) \geq 1$, we have $|\partial U| \geq |U|$, so the edge support gained is at least as large as the vertex support removed.
\end{lemma}

\begin{proof}
\leanok
\uses{def:cheeger__constant_(_isoperimetric__constant)}

We unfold the definition of net support change. By the expander property, for any small subset $U$ we have $|\partial U| \geq |U|$. Therefore:
\[
\Delta(U) = |\partial U| - |U| \geq 0
\]
The inequality follows directly from integer arithmetic using the Cheeger bound.
\end{proof}

\begin{theorem}[Weight Non-Decrease Under Stabilizer Equivalence]
\label{thm:weight_non_decrease_under_stabilizer_equiv}
\lean{GaugingLDPC.weight_non_decrease_under_stabilizer_equiv}
\leanok
\uses{def:cheeger__constant_(_isoperimetric__constant), def:gauged__stabilizers_(_vertex_and__plaquette__terms)}

Let $O = c_U \mathsf{T}_U + O^\perp$ be an operator where $U \subseteq \mathcal{G}_0$ is the vertex support of the symmetry component, with $\mathsf{T}_U := \prod_{v \in U} \mathsf{T}_{\Sigma(v)}$.

Let $G$ be an expander graph (with $h(\mathcal{G}) \geq 1$) and let $U$ be a small subset. Given:
\begin{itemize}
\item Original vertex support containing $U$
\item Original edge support disjoint from the edge boundary $\partial U$
\end{itemize}

Then the replacement $O \mapsto c_U \prod_{e \in \partial U} \mathcal{X}_e + O^\perp$ (obtained by multiplying by $\prod_{v \in U} \mathbb{A}_v$) is \textbf{weight non-decreasing}:
\[
|\mathrm{Supp}(O')| \geq |\mathrm{Supp}(O)|
\]

More precisely, if the new vertex support is the original minus $U$, and the new edge support is the original plus $\partial U$, then:
\[
|\text{newVertexSupport}| + |\text{newEdgeSupport}| \geq |\text{originalVertexSupport}| + |\text{originalEdgeSupport}|
\]
\end{theorem}

\begin{proof}
\leanok
\uses{def:cheeger__constant_(_isoperimetric__constant)}

Let the new vertex support be $\text{originalVertexSupport} \setminus U$ and the new edge support be $\text{originalEdgeSupport} \cup \partial U$.

\textbf{Step 1 (Vertex support decrease):} Since $U \subseteq \text{originalVertexSupport}$, we have:
\[
|\text{originalVertexSupport}| = |\text{newVertexSupport}| + |U|
\]
This follows from the cardinality of set difference: $|A| = |A \setminus B| + |B|$ when $B \subseteq A$.

\textbf{Step 2 (Edge support increase):} Since the original edge support is disjoint from $\partial U$, we have:
\[
|\text{newEdgeSupport}| = |\text{originalEdgeSupport}| + |\partial U|
\]
This follows from the cardinality of disjoint union.

\textbf{Step 3 (Apply Cheeger bound):} By the expander property with $h(\mathcal{G}) \geq 1$, for any small subset $U$:
\[
|\partial U| \geq |U|
\]

\textbf{Step 4 (Combine):} The total support change is:
\begin{align*}
&|\text{newVertexSupport}| + |\text{newEdgeSupport}| \\
&= (|\text{originalVertexSupport}| - |U|) + (|\text{originalEdgeSupport}| + |\partial U|) \\
&= |\text{originalVertexSupport}| + |\text{originalEdgeSupport}| + (|\partial U| - |U|) \\
&\geq |\text{originalVertexSupport}| + |\text{originalEdgeSupport}|
\end{align*}
where the final inequality follows from $|\partial U| - |U| \geq 0$ by the Cheeger bound. The result follows by integer arithmetic.
\end{proof}

\begin{corollary}[Boundary Size Lower Bound for Expanders]
\label{cor:boundary_ge_size_for_expander}
\lean{GaugingLDPC.boundary_ge_size_for_expander}
\leanok
\uses{def:cheeger__constant_(_isoperimetric__constant)}

Let $G$ be an expander graph with $h(\mathcal{G}) \geq 1$. For any small subset $U \subseteq V$:
\[
|\partial U| \geq |U|
\]
\end{corollary}

\begin{proof}
\leanok
\uses{def:cheeger__constant_(_isoperimetric__constant)}

This follows directly from the expander property: by definition of an expander graph with Cheeger constant at least 1, the edge boundary of any small subset is at least as large as the subset itself.
\end{proof}

\begin{corollary}[Support Change Lower Bound]
\label{cor:support_change_lower_bound}
\lean{GaugingLDPC.support_change_lower_bound}
\leanok
\uses{def:cheeger__constant_(_isoperimetric__constant), def:net_support_change}

Let $G$ be a simple graph and $U \subseteq V$ a small subset. The net support change is bounded below by:
\[
\Delta(U) \geq (h(\mathcal{G}) - 1) \cdot |U|
\]
where $h(\mathcal{G})$ is the Cheeger constant of $G$. When $h(\mathcal{G}) \geq 1$, this gives a non-negative bound.
\end{corollary}

\begin{proof}
\leanok
\uses{def:cheeger__constant_(_isoperimetric__constant)}

We unfold the definition of net support change. Since $U$ is a small non-empty subset, we have $|U| > 0$.

By definition of the Cheeger constant, for any small subset $U$ the expansion ratio satisfies:
\[
h(\mathcal{G}) \leq \frac{|\partial U|}{|U|}
\]

Multiplying both sides by $|U| > 0$:
\[
h(\mathcal{G}) \cdot |U| \leq |\partial U|
\]

Subtracting $|U|$ from both sides:
\[
(h(\mathcal{G}) - 1) \cdot |U| \leq |\partial U| - |U| = \Delta(U)
\]

Converting the integer subtraction to real numbers and applying linear arithmetic completes the proof.
\end{proof}

\begin{corollary}[Expansion Ratio Lower Bound]
\label{cor:expansion_ratio_ge_cheeger}
\lean{GaugingLDPC.expansion_ratio_ge_cheeger}
\leanok
\uses{def:cheeger__constant_(_isoperimetric__constant)}

Let $G$ be a simple graph and $U \subseteq V$ a small subset. The expansion ratio of $U$ is at least the Cheeger constant:
\[
\frac{|\partial U|}{|U|} \geq h(\mathcal{G})
\]
\end{corollary}

\begin{proof}
\leanok
\uses{def:cheeger__constant_(_isoperimetric__constant)}

This follows directly from the definition of the Cheeger constant as the infimum of expansion ratios over all small subsets.
\end{proof}

%--- Lem_7: Gauged Code is Sparse and Distance Preserving ---
\begin{definition}[LDPC Code]
\label{def:is_ldpc_code}
\lean{GaugingLDPC.IsLDPCCode}
\leanok
\uses{def:decorated__stabilizer_(_gauged__stabilizer_of__original__code)}

An \emph{LDPC code} is a code with bounded stabilizer weight. Formally, given a matter assignment $\sigma$ mapping vertices $v$ to matter qudit sets $\Sigma(v)$, and bounds $\mathrm{matterWeightBound}$ and $\mathrm{stabilizerSupportBound}$, the code is LDPC if:
\begin{enumerate}
    \item (Bounded vertex sets) For all vertices $v \in V$, $|\Sigma(v)| \leq \mathrm{matterWeightBound}$.
    \item (Sparse stabilizers) $\mathrm{stabilizerSupportBound} \leq \mathrm{matterWeightBound}$.
\end{enumerate}

This captures the property that each vertex set $\Sigma(v)$ has size $O(1)$ since the original code is LDPC.
\end{definition}

\begin{definition}[Vertex Stabilizer Weight]
\label{def:vertex_stabilizer_weight}
\lean{GaugingLDPC.vertexStabilizerWeight}
\leanok
\uses{def:gauged__stabilizers_(_vertex_and__plaquette__terms)}

The \emph{total support weight of the vertex stabilizer} $\mathfrak{A}_v$ is defined as:
\[
    \mathrm{vertexStabilizerWeight}(G, \sigma, v) = |\Sigma(v)| + |\text{incident edges to } v|
\]
where $|\Sigma(v)|$ is the number of matter qudits associated with vertex $v$, and the incident edges are those with source or target equal to $v$ in the oriented graph.
\end{definition}

\begin{definition}[Plaquette Stabilizer Weight]
\label{def:plaquette_stabilizer_weight}
\lean{GaugingLDPC.plaquetteStabilizerWeight}
\leanok
\uses{def:gauged__stabilizers_(_vertex_and__plaquette__terms)}

The \emph{support weight of the plaquette stabilizer} $\mathfrak{B}_p$ equals the plaquette boundary weight:
\[
    \mathrm{plaquetteStabilizerWeight}(G, p) = \mathrm{plaquetteBoundaryWeight}(w, G, p)
\]
\end{definition}

\begin{definition}[Decorated Stabilizer Total Weight]
\label{def:decorated_stabilizer_total_weight}
\lean{GaugingLDPC.decoratedStabilizerTotalWeight}
\leanok
\uses{def:decorated__stabilizer_(_gauged__stabilizer_of__original__code)}

The \emph{total weight of a decorated stabilizer} $\mathfrak{S}$ is the sum of the matter support and the edge support:
\[
    \mathrm{decoratedStabilizerTotalWeight}(\mathrm{matterSupport}, \mathrm{edgeSupport}) = \mathrm{matterSupport} + \mathrm{edgeSupport}
\]
where the matter support comes from the original stabilizer and the edge support comes from the path $\alpha$ solving $\partial_1 \alpha = \chi$.
\end{definition}

\begin{theorem}[Incident Edges Equals Degree]
\label{thm:incident_edges_card_eq_degree}
\lean{GaugingLDPC.incidentEdges_card_eq_degree}
\leanok
\uses{def:gauged__stabilizers_(_vertex_and__plaquette__terms)}

For a gauged cell complex $G$ and a vertex $v$, if there is an equivalence between the set of edges incident to $v$ (i.e., edges $e$ with $\mathrm{source}(e) = v$ or $\mathrm{target}(e) = v$) and the neighbor finset of $v$ in the underlying simple graph, then:
\[
    |\mathrm{incidentEdges}(w, G, v)| = \deg_G(v)
\]
where $\deg_G(v)$ denotes the degree of $v$ in the simple graph associated to $G$.
\end{theorem}

\begin{proof}
\leanok
\uses{def:gauged__stabilizers_(_vertex_and__plaquette__terms)}

By the given equivalence $h_{\mathrm{Equiv}}$, the cardinality of the subtype of edges incident to $v$ equals the cardinality of the neighbor finset. Unfolding the definitions of incident edges and simple graph degree, and using that the cardinality of a filter equals the cardinality of the corresponding subtype, we convert both sides to show they are equal. The proof concludes by applying the cardinality congruence from the equivalence and simplifying.
\end{proof}

\begin{lemma}[Gauged Code is Sparse (Part 1)]
\label{lem:gauged__code_is__sparse_and__distance__preserving}
\lean{GaugingLDPC.GaugedCodeIsSparse}
\leanok
\uses{def:cheeger__constant_(_isoperimetric__constant), def:decorated__stabilizer_(_gauged__stabilizer_of__original__code), def:gauged__stabilizers_(_vertex_and__plaquette__terms), def:gauging__graph__criteria, lem:weight__non__decrease__under__stabilizer__equivalence}

If the gauging graph $\mathcal{G}$ satisfies all four criteria (Def~9) and the original code is LDPC, then all stabilizer generators have $O(1)$ weight:

\begin{enumerate}
    \item $\mathfrak{A}_v$: $|\Sigma(v)| + \deg(v) = O(1)$
    \begin{itemize}
        \item $|\Sigma(v)| = O(1)$ by the LDPC property of the original code
        \item $\deg(v) \leq \mathrm{degreeBound} = O(1)$ by Criterion 1
    \end{itemize}
    
    \item $\mathfrak{B}_p$: $|\partial p| \leq \mathrm{cycleWeightBound} = O(1)$ by Criterion 2
    
    \item $\mathfrak{S}$: matter support + edge support $= O(1)$
    \begin{itemize}
        \item Matter support $= O(1)$ by the LDPC property
        \item Edge support $\leq \mathrm{pathWeightBound} = O(1)$ by Criterion 3
    \end{itemize}
\end{enumerate}

Formally, for a valid gauging graph $VG$:
\begin{align*}
    &\forall v \in V,\ \mathrm{vertexStabilizerWeight}(G, \sigma, v) \leq \mathrm{matterBound} + VG.\mathrm{degreeBound} \\
    &\forall p \in P,\ \mathrm{plaquetteStabilizerWeight}(G, p) \leq VG.\mathrm{cycleWeightBound} \\
    &\forall S \in \mathrm{stabilizers},\ \forall \chi \in S.\mathrm{chargeConfigs},\ \exists \alpha : E \to_0 \mathbb{Z}/w\mathbb{Z},\\
    &\qquad \mathrm{IsNeutralizingPath}(w, G, \chi, \alpha) \land \mathrm{chainWeight}(\alpha) \leq VG.\mathrm{pathWeightBound}
\end{align*}
\end{lemma}

\begin{proof}
\leanok
\uses{def:gauging__graph__criteria, lem:weight__non__decrease__under__stabilizer__equivalence}

We prove the three parts separately.

\textbf{Part 1} ($\mathfrak{A}_v$ has $O(1)$ weight): Let $v \in V$. We have $|\Sigma(v)| \leq \mathrm{matterBound}$ by the LDPC property. The incident edge bound gives $|\mathrm{incidentEdges}(v)| \leq \deg(v)$. By Criterion 1 (bounded degree), $\deg(v) \leq VG.\mathrm{degreeBound}$. Combining these by linear arithmetic gives the desired bound.

\textbf{Part 2} ($\mathfrak{B}_p$ has $O(1)$ weight): Let $p \in P$. By Criterion 2 (sparse cycles), we have $\mathrm{plaquetteWeight}(p) \leq VG.\mathrm{cycleWeightBound}$.

\textbf{Part 3} ($\mathfrak{S}$ has $O(1)$ edge weight): Let $S \in \mathrm{stabilizers}$ and $\chi \in S.\mathrm{chargeConfigs}$. By Criterion 3 (constant path weight), there exists a neutralizing path $\alpha$ with $\mathrm{chainWeight}(\alpha) \leq VG.\mathrm{pathWeightBound}$.
\end{proof}

\begin{theorem}[Distance Preserved via Lemma 6]
\label{thm:distance_preserved_via_lem6}
\lean{GaugingLDPC.distance_preserved_via_Lem6}
\leanok
\uses{def:cheeger__constant_(_isoperimetric__constant), lem:weight__non__decrease__under__stabilizer__equivalence}

This theorem explicitly uses Lemma 6 to establish that distance is preserved. The connection is:
\begin{enumerate}
    \item Lemma 6 shows: For expander graphs with $h(\mathcal{G}) \geq 1$, multiplying by $\prod_{v \in U} \mathfrak{A}_v$ results in $|\mathrm{Supp}(O')| \geq |\mathrm{Supp}(O)|$.
    \item Therefore: All operators in the equivalence class of a decorated logical operator have weight $\geq$ the original logical operator weight $\geq d_{\mathrm{original}}$.
\end{enumerate}

Formally, for an expander graph $G$, a small subset $U$ of vertices, original vertex support $V_O$, and original edge support $E_O$ with $U \subseteq V_O$ and $E_O$ disjoint from $\partial U$:
\[
    |V_O \setminus U| + |E_O \cup \partial U| \geq |V_O| + |E_O|
\]
\end{theorem}

\begin{proof}
\leanok
\uses{lem:weight__non__decrease__under__stabilizer__equivalence}

This follows directly from Lemma 6's \texttt{weight\_non\_decrease\_under\_stabilizer\_equiv}.
\end{proof}

\begin{theorem}[Distance Preserved: Boundary at Least Size]
\label{thm:distance_preserved_boundary_ge_size}
\lean{GaugingLDPC.distance_preserved_boundary_ge_size}
\leanok
\uses{def:cheeger__constant_(_isoperimetric__constant), lem:weight__non__decrease__under__stabilizer__equivalence}

For an expander graph $G$ and a small subset $U$ of vertices, the net support change is non-negative:
\[
    \mathrm{netSupportChange}(G, U) \geq 0
\]
This is a direct application of Lemma 6's \texttt{support\_change\_nonneg}.
\end{theorem}

\begin{proof}
\leanok
\uses{lem:weight__non__decrease__under__stabilizer__equivalence}

This is a direct application of \texttt{support\_change\_nonneg} from Lemma 6.
\end{proof}

\begin{theorem}[Weight Non-Decrease via Lemma 6]
\label{thm:weight_non_decrease_via_lem6}
\lean{GaugingLDPC.weight_non_decrease_via_Lem6}
\leanok
\uses{def:cheeger__constant_(_isoperimetric__constant), lem:weight__non__decrease__under__stabilizer__equivalence}

For any operator $O$ with vertex support $V_O$ and edge support $E_O$, where $U \subseteq V_O$ is the subset being ``traded'' for edge support:

The new operator $O' = (\prod_{v \in U} \mathfrak{A}_v) \cdot O$ has:
\begin{itemize}
    \item Vertex support $V_O \setminus U$
    \item Edge support $E_O \cup \partial U$
\end{itemize}

By Lemma 6's \texttt{boundary\_ge\_size\_for\_expander}: $|\partial U| \geq |U|$.

Therefore: $|V_{O'}| + |E_{O'}| = (|V_O| - |U|) + (|E_O| + |\partial U|) \geq |V_O| + |E_O|$.

Formally, for an expander graph $G$ and small subset $U$:
\[
    |\partial U| \geq |U|
\]
\end{theorem}

\begin{proof}
\leanok
\uses{lem:weight__non__decrease__under__stabilizer__equivalence}

This follows directly from \texttt{boundary\_ge\_size\_for\_expander} in Lemma 6.
\end{proof}

\begin{theorem}[Weight Change Under Stabilizer Equivalence]
\label{thm:weight_change_under_stabilizer_equiv}
\lean{GaugingLDPC.weight_change_under_stabilizer_equiv}
\leanok
\uses{def:cheeger__constant_(_isoperimetric__constant), lem:weight__non__decrease__under__stabilizer__equivalence}

When multiplying an operator by $\prod_{v \in U} \mathfrak{A}_v$:
\begin{itemize}
    \item Matter support decreases by at most $|U|$
    \item Edge support increases by at least $|\partial U|$
\end{itemize}

For an expander graph with $h(\mathcal{G}) \geq 1$, the Cheeger bound gives $|\partial U| \geq |U|$, so total weight does not decrease.

Formally, given:
\begin{itemize}
    \item An expander graph $G$ and small subset $U$
    \item Original weight, matter decrease, and edge increase with $\mathrm{matterDecrease} \leq |U|$ and $\mathrm{edgeIncrease} \geq |\partial U|$
\end{itemize}

Then:
\[
    \mathrm{originalWeight} - \mathrm{matterDecrease} + \mathrm{edgeIncrease} \geq \mathrm{originalWeight}
\]
\end{theorem}

\begin{proof}
\leanok
\uses{lem:weight__non__decrease__under__stabilizer__equivalence}

By the Cheeger bound (\texttt{boundary\_ge\_size\_for\_expander}), we have $|\partial U| \geq |U|$. Then:
\[
    \mathrm{edgeIncrease} \geq |\partial U| \geq |U| \geq \mathrm{matterDecrease}
\]
The result follows by linear arithmetic.
\end{proof}

\begin{theorem}[Gauged Code Distance Preserved (Part 2)]
\label{thm:gauged_code_distance_preserved}
\lean{GaugingLDPC.GaugedCodeDistancePreserved}
\leanok
\uses{def:cheeger__constant_(_isoperimetric__constant), def:decorated__stabilizer_(_gauged__stabilizer_of__original__code), def:gauging__graph__criteria, lem:weight__non__decrease__under__stabilizer__equivalence}

For a gauging graph satisfying Criterion 4 ($h(\mathcal{G}) \geq 1$), the distance of the gauged code satisfies $d_{\mathrm{gauged}} \geq d_{\mathrm{original}}$.

\textbf{Theorem}: Let $L$ be any logical operator in the original code with weight $w_L \geq d_{\mathrm{original}}$. Let $D = \mathfrak{D}(L)$ be the decorated operator with weight $w_D = w_L + (\text{decoration edge weight})$. For any operator $O$ in the equivalence class of $D$ obtained by multiplying by $\prod_{v \in U} \mathfrak{A}_v$ (for any small subset $U$), we have $|\mathrm{Supp}(O)| \geq d_{\mathrm{original}}$.

Formally, for any small subset $U$, matter decrease $\leq |U|$, and edge increase $\geq |\partial U|$:
\[
    (\mathrm{logicalWeight} + \mathrm{decorationWeight}) - \mathrm{matterDecrease} + \mathrm{edgeIncrease} \geq d_{\mathrm{original}}
\]
\end{theorem}

\begin{proof}
\leanok
\uses{def:gauging__graph__criteria, lem:weight__non__decrease__under__stabilizer__equivalence}

Let $U$, $\mathrm{matterDecrease}$, and $\mathrm{edgeIncrease}$ be given with the stated bounds. 

First, the decorated weight satisfies $\mathrm{logicalWeight} + \mathrm{decorationWeight} \geq d_{\mathrm{original}}$ since $\mathrm{logicalWeight} \geq d_{\mathrm{original}}$ and decoration weight is non-negative.

By \texttt{weight\_change\_under\_stabilizer\_equiv} applied to the simple graph with Criterion 4 (expansion property), the weight after stabilizer multiplication is at least the decorated weight.

The result follows by linear arithmetic combining these bounds.
\end{proof}

\begin{corollary}[Gauged Distance at Least Original Distance]
\label{cor:gauged_distance_ge_original}
\lean{GaugingLDPC.gaugedDistance_ge_originalDistance}
\leanok
\uses{def:cheeger__constant_(_isoperimetric__constant), def:decorated__stabilizer_(_gauged__stabilizer_of__original__code), def:gauging__graph__criteria, lem:weight__non__decrease__under__stabilizer__equivalence}

The gauged code distance is at least the original code distance.

This combines decoration and stabilizer equivalence to show that every operator in the equivalence class of any decorated logical operator has weight $\geq d_{\mathrm{original}}$, hence:
\[
    d_{\mathrm{gauged}} = \min_{L} \min_{O \sim_g \mathfrak{D}(L)} |\mathrm{Supp}(O)| \geq d_{\mathrm{original}}
\]

The key insight is that for any small subset $U$ used in stabilizer equivalence, the weight change is non-negative (by Lemma 6 and Criterion 4), so all operators in the equivalence class have weight $\geq$ the original logical operator weight $\geq d_{\mathrm{original}}$.
\end{corollary}

\begin{proof}
\leanok
\uses{lem:weight__non__decrease__under__stabilizer__equivalence}

Given the witness consisting of $\mathrm{logicalWeight}$, $\mathrm{decorationWeight}$, $U$, $\mathrm{matterDecrease}$, $\mathrm{edgeIncrease}$ satisfying the required properties, we apply \texttt{GaugedCodeDistancePreserved} to conclude that $d_{\mathrm{gauged}} \geq d_{\mathrm{original}}$ by linear arithmetic.
\end{proof}

\begin{theorem}[Main Theorem: Gauged Code is Sparse and Distance-Preserving]
\label{thm:gauged_code_sparse_and_distance_preserving}
\lean{GaugingLDPC.GaugedCodeIsSparseAndDistancePreserving}
\leanok
\uses{def:cheeger__constant_(_isoperimetric__constant), def:decorated__stabilizer_(_gauged__stabilizer_of__original__code), def:gauged__stabilizers_(_vertex_and__plaquette__terms), def:gauging__graph__criteria, lem:weight__non__decrease__under__stabilizer__equivalence}

If the gauging graph $\mathcal{G}$ satisfies all four criteria in Def~9, then:
\begin{enumerate}
    \item \textbf{Sparse}: All stabilizer generators ($\mathfrak{A}_v$, $\mathfrak{B}_p$, $\mathfrak{S}$) have weight $O(1)$.
    \item \textbf{Distance-preserving}: $d_{\mathrm{gauged}} \geq d_{\mathrm{original}}$.
\end{enumerate}

This theorem combines Parts 1 and 2 into a single statement.
\end{theorem}

\begin{proof}
\leanok
\uses{def:gauging__graph__criteria, lem:weight__non__decrease__under__stabilizer__equivalence}

We prove both parts:

\textbf{Part 1} (Sparsity): This follows directly from \texttt{GaugedCodeIsSparse}.

\textbf{Part 2} (Distance preservation): Let $\mathrm{logicalWeight} \geq d_{\mathrm{original}}$, $\mathrm{decorationWeight}$, small subset $U$, $\mathrm{matterDecrease} \leq |U|$, and $\mathrm{edgeIncrease} \geq |\partial U|$ be given. This follows directly from \texttt{GaugedCodeDistancePreserved} applied with these parameters.
\end{proof}

%--- Def_10: Equivalence Relations in the Gauged Code ---
\begin{definition}[Gauged Operator]
\label{def:gauged_operator}
\lean{GaugingLDPC.GaugedOperator}
\leanok

A \emph{gauged operator} on the gauged system is an endomorphism of the gauged system state. Formally, for a prime $w$ and types $V$, $E$, $M$ representing vertices, edges, and matter degrees of freedom, a gauged operator is a function
\[
O : \mathsf{GaugedSystemState}(w, V, E, M) \to \mathsf{GaugedSystemState}(w, V, E, M).
\]
\end{definition}

\begin{definition}[Operator Natural Power]
\label{def:operator_pow_nat}
\lean{GaugingLDPC.operatorPowNat}
\leanok
\uses{def:gauged_operator}

For an operator $O$ on the gauged system, the \emph{natural number power} $O^n$ for $n \in \mathbb{N}$ is defined recursively by:
\begin{align*}
O^0 &= \mathrm{id}, \\
O^{n+1} &= O \circ O^n.
\end{align*}
\end{definition}

\begin{lemma}[Operator Power Zero]
\label{lem:operator_pow_nat_zero}
\lean{GaugingLDPC.operatorPowNat_zero}
\leanok
\uses{def:operator_pow_nat}

For any gauged operator $O$, we have $O^0 = \mathrm{id}$.
\end{lemma}

\begin{proof}
\leanok
\uses{def:operator_pow_nat}
This holds by definition of the natural power.
\end{proof}

\begin{lemma}[Operator Power One]
\label{lem:operator_pow_nat_one}
\lean{GaugingLDPC.operatorPowNat_one}
\leanok
\uses{def:operator_pow_nat}

For any gauged operator $O$, we have $O^1 = O$.
\end{lemma}

\begin{proof}
\leanok
\uses{def:operator_pow_nat}
By simplification using the definition, $O^1 = O \circ O^0 = O \circ \mathrm{id} = O$.
\end{proof}

\begin{lemma}[Operator Power Addition]
\label{lem:operator_pow_nat_add}
\lean{GaugingLDPC.operatorPowNat_add}
\leanok
\uses{def:operator_pow_nat}

For any gauged operator $O$ and natural numbers $m, n \in \mathbb{N}$,
\[
O^{m+n} = O^m \circ O^n.
\]
\end{lemma}

\begin{proof}
\leanok
\uses{def:operator_pow_nat}
We proceed by induction on $m$.

\textbf{Base case} ($m = 0$): By simplification using the definition, $O^{0+n} = O^n = \mathrm{id} \circ O^n = O^0 \circ O^n$.

\textbf{Inductive step}: Assume $O^{m+n} = O^m \circ O^n$. Then using the successor property and the inductive hypothesis,
\[
O^{(m+1)+n} = O^{(m+n)+1} = O \circ O^{m+n} = O \circ (O^m \circ O^n) = (O \circ O^m) \circ O^n = O^{m+1} \circ O^n,
\]
where the last step uses associativity of function composition.
\end{proof}

\begin{definition}[Operator Product]
\label{def:operator_product}
\lean{GaugingLDPC.operatorProduct}
\leanok
\uses{def:gauged_operator}

Given a family of gauged operators $\{O_s\}_{s \in S}$ indexed by a finite type $S$, the \emph{operator product} is defined as the fold composition over the list enumeration of $S$:
\[
\prod_{s \in S} O_s = \mathrm{foldl}(\circ, \mathrm{id}, [O_{s_1}, O_{s_2}, \ldots, O_{s_n}]),
\]
where $[s_1, \ldots, s_n]$ is the list representation of the finite set $S$.
\end{definition}

\begin{definition}[Decorated Stabilizer Product]
\label{def:decorated_stabilizer_product}
\lean{GaugingLDPC.decoratedStabilizerProduct}
\leanok
\uses{def:operator_product, def:operator_pow_nat, def:decorated_stabilizer_step}

Given a family of symmetrized stabilizers $\{\mathbb{S}_s\}_{s \in S}$ and integer exponents $\{n_s\}_{s \in S}$, the \emph{decorated stabilizer product} is
\[
\prod_{s \in S} (\tilde{\mathbb{S}}_s)^{|n_s|},
\]
where $\tilde{\mathbb{S}}_s$ denotes the decorated stabilizer corresponding to $\mathbb{S}_s$, and $|n_s|$ is the absolute value of the exponent.
\end{definition}

\begin{definition}[Vertex Stabilizer Product]
\label{def:vertex_stabilizer_product}
\lean{GaugingLDPC.vertexStabilizerProduct}
\leanok
\uses{def:operator_product, def:operator_pow_nat, def:decorated_stabilizer_step}

Given integer exponents $\{m_v\}_{v \in V}$, the \emph{vertex stabilizer product} is
\[
\prod_{v \in V} (\mathfrak{A}_v)^{|m_v|},
\]
where $\mathfrak{A}_v$ denotes the vertex stabilizer at vertex $v$.
\end{definition}

\begin{definition}[Flux Stabilizer Product]
\label{def:flux_stabilizer_product}
\lean{GaugingLDPC.fluxStabilizerProduct}
\leanok
\uses{def:operator_product, def:operator_pow_nat, def:decorated_stabilizer_step}

Given integer exponents $\{k_p\}_{p \in P}$, the \emph{flux stabilizer product} is
\[
\prod_{p \in P} (\mathfrak{B}_p)^{|k_p|},
\]
where $\mathfrak{B}_p$ denotes the plaquette (flux) stabilizer at plaquette $p$.
\end{definition}

\begin{definition}[Decorated Stabilizer Step Relation]
\label{def:decorated_stabilizer_step}
\lean{GaugingLDPC.DecoratedStabilizerStep}
\leanok
\uses{def:gauged_operator, def:decorated_stabilizer_step}

The \emph{decorated stabilizer step relation} is the generating relation for decorated stabilizer equivalence. Two operators $O$ and $O'$ are related by a single step if there exists an index $s \in S$ such that either
\[
O' = O \circ \tilde{\mathbb{S}}_s \quad \text{or} \quad O = O' \circ \tilde{\mathbb{S}}_s,
\]
where $\tilde{\mathbb{S}}_s$ is the decorated stabilizer for the symmetrized stabilizer indexed by $s$.
\end{definition}

\begin{definition}[Decorated Stabilizer Equivalence $\sim_{\mathfrak{s}}$]
\label{def:equivalence__relations_in_the__gauged__code}
\lean{GaugingLDPC.DecoratedStabilizerEquiv}
\leanok
\uses{def:decorated_stabilizer_step}

Two operators $O$ and $O'$ are \emph{decorated stabilizer equivalent}, written $O \sim_{\mathfrak{s}} O'$, if they are related by the equivalence closure of the decorated stabilizer step relation. This means there exists a finite chain
\[
O = O_0 \to O_1 \to \cdots \to O_n = O'
\]
where each step $O_i \to O_{i+1}$ applies or removes a single decorated stabilizer.

Equivalently, $O \sim_{\mathfrak{s}} O'$ if and only if
\[
O' = O \cdot \prod_{s \in S} (\tilde{\mathbb{S}}_s)^{n_s}
\]
for some integers $n_s$.
\end{definition}

\begin{theorem}[Reflexivity of Decorated Stabilizer Equivalence]
\label{thm:decorated_stabilizer_equiv_refl}
\lean{GaugingLDPC.decoratedStabilizerEquiv_refl}
\leanok
\uses{def:equivalence__relations_in_the__gauged__code}

For any gauged operator $O$, we have $O \sim_{\mathfrak{s}} O$.
\end{theorem}

\begin{proof}
\leanok
\uses{def:equivalence__relations_in_the__gauged__code}
This follows immediately from the reflexivity property of the equivalence closure construction.
\end{proof}

\begin{theorem}[Symmetry of Decorated Stabilizer Equivalence]
\label{thm:decorated_stabilizer_equiv_symm}
\lean{GaugingLDPC.decoratedStabilizerEquiv_symm}
\leanok
\uses{def:equivalence__relations_in_the__gauged__code}

For any gauged operators $O$ and $O'$, if $O \sim_{\mathfrak{s}} O'$ then $O' \sim_{\mathfrak{s}} O$.
\end{theorem}

\begin{proof}
\leanok
\uses{def:equivalence__relations_in_the__gauged__code}
This follows immediately from the symmetry property of the equivalence closure construction.
\end{proof}

\begin{theorem}[Transitivity of Decorated Stabilizer Equivalence]
\label{thm:decorated_stabilizer_equiv_trans}
\lean{GaugingLDPC.decoratedStabilizerEquiv_trans}
\leanok
\uses{def:equivalence__relations_in_the__gauged__code}

For any gauged operators $O$, $O'$, and $O''$, if $O \sim_{\mathfrak{s}} O'$ and $O' \sim_{\mathfrak{s}} O''$, then $O \sim_{\mathfrak{s}} O''$.
\end{theorem}

\begin{proof}
\leanok
\uses{def:equivalence__relations_in_the__gauged__code}
This follows immediately from the transitivity property of the equivalence closure construction.
\end{proof}

\begin{definition}[Decorated Stabilizer Setoid]
\label{def:decorated_stabilizer_setoid}
\lean{GaugingLDPC.DecoratedStabilizerSetoid}
\leanok
\uses{def:equivalence__relations_in_the__gauged__code, thm:decorated_stabilizer_equiv_refl, thm:decorated_stabilizer_equiv_symm, thm:decorated_stabilizer_equiv_trans}

The \emph{decorated stabilizer setoid} is the setoid structure on gauged operators induced by decorated stabilizer equivalence $\sim_{\mathfrak{s}}$, with the equivalence relation and its proof of being an equivalence relation (reflexivity, symmetry, transitivity).
\end{definition}

\begin{lemma}[Decorated Stabilizer Induces Step]
\label{lem:decorated_stabilizer_induces_step}
\lean{GaugingLDPC.decoratedStabilizer_induces_step}
\leanok
\uses{def:equivalence__relations_in_the__gauged__code, def:decorated_stabilizer_step}

For any gauged operator $O$ and index $s \in S$,
\[
O \sim_{\mathfrak{s}} O \circ \tilde{\mathbb{S}}_s.
\]
\end{lemma}

\begin{proof}
\leanok
\uses{def:decorated_stabilizer_step}
By the definition of the step relation, the pair $(O, O \circ \tilde{\mathbb{S}}_s)$ satisfies the step condition with witness $s$ (taking the left disjunct with reflexivity). The equivalence closure then includes this pair.
\end{proof}

\begin{definition}[Vertex Stabilizer Step Relation]
\label{def:vertex_stabilizer_step}
\lean{GaugingLDPC.VertexStabilizerStep}
\leanok
\uses{def:gauged_operator, def:decorated_stabilizer_step}

The \emph{vertex stabilizer step relation} is the generating relation for vertex stabilizer equivalence. Two operators $O$ and $O'$ are related by a single step if there exists a vertex $v \in V$ such that either
\[
O' = O \circ \mathfrak{A}_v \quad \text{or} \quad O = O' \circ \mathfrak{A}_v.
\]
\end{definition}

\begin{definition}[Vertex Stabilizer Equivalence $\sim_{\mathfrak{A}}$]
\label{def:vertex_stabilizer_equiv}
\lean{GaugingLDPC.VertexStabilizerEquiv}
\leanok
\uses{def:vertex_stabilizer_step, def:decorated_stabilizer_step}

Two operators $O$ and $O'$ are \emph{vertex stabilizer equivalent}, written $O \sim_{\mathfrak{A}} O'$, if they are related by the equivalence closure of the vertex stabilizer step relation. Equivalently,
\[
O' = O \cdot \prod_{v \in V} (\mathfrak{A}_v)^{m_v}
\]
for some integers $m_v$.
\end{definition}

\begin{theorem}[Reflexivity of Vertex Stabilizer Equivalence]
\label{thm:vertex_stabilizer_equiv_refl}
\lean{GaugingLDPC.vertexStabilizerEquiv_refl}
\leanok
\uses{def:vertex_stabilizer_equiv}

For any gauged operator $O$, we have $O \sim_{\mathfrak{A}} O$.
\end{theorem}

\begin{proof}
\leanok
\uses{def:vertex_stabilizer_equiv}
This follows immediately from the reflexivity property of the equivalence closure.
\end{proof}

\begin{theorem}[Symmetry of Vertex Stabilizer Equivalence]
\label{thm:vertex_stabilizer_equiv_symm}
\lean{GaugingLDPC.vertexStabilizerEquiv_symm}
\leanok
\uses{def:vertex_stabilizer_equiv}

For any gauged operators $O$ and $O'$, if $O \sim_{\mathfrak{A}} O'$ then $O' \sim_{\mathfrak{A}} O$.
\end{theorem}

\begin{proof}
\leanok
\uses{def:vertex_stabilizer_equiv}
This follows immediately from the symmetry property of the equivalence closure.
\end{proof}

\begin{theorem}[Transitivity of Vertex Stabilizer Equivalence]
\label{thm:vertex_stabilizer_equiv_trans}
\lean{GaugingLDPC.vertexStabilizerEquiv_trans}
\leanok
\uses{def:vertex_stabilizer_equiv}

For any gauged operators $O$, $O'$, and $O''$, if $O \sim_{\mathfrak{A}} O'$ and $O' \sim_{\mathfrak{A}} O''$, then $O \sim_{\mathfrak{A}} O''$.
\end{theorem}

\begin{proof}
\leanok
\uses{def:vertex_stabilizer_equiv}
This follows immediately from the transitivity property of the equivalence closure.
\end{proof}

\begin{definition}[Vertex Stabilizer Setoid]
\label{def:vertex_stabilizer_setoid}
\lean{GaugingLDPC.VertexStabilizerSetoid}
\leanok
\uses{def:vertex_stabilizer_equiv, thm:vertex_stabilizer_equiv_refl, thm:vertex_stabilizer_equiv_symm, thm:vertex_stabilizer_equiv_trans}

The \emph{vertex stabilizer setoid} is the setoid structure on gauged operators induced by vertex stabilizer equivalence $\sim_{\mathfrak{A}}$.
\end{definition}

\begin{definition}[Flux Stabilizer Step Relation]
\label{def:flux_stabilizer_step}
\lean{GaugingLDPC.FluxStabilizerStep}
\leanok
\uses{def:gauged_operator, def:decorated_stabilizer_step}

The \emph{flux stabilizer step relation} is the generating relation for flux stabilizer equivalence. Two operators $O$ and $O'$ are related by a single step if there exists a plaquette $p \in P$ such that either
\[
O' = O \circ \mathfrak{B}_p \quad \text{or} \quad O = O' \circ \mathfrak{B}_p.
\]
\end{definition}

\begin{definition}[Flux Stabilizer Equivalence $\sim_{\mathfrak{B}}$]
\label{def:flux_stabilizer_equiv}
\lean{GaugingLDPC.FluxStabilizerEquiv}
\leanok
\uses{def:flux_stabilizer_step, def:decorated_stabilizer_step}

Two operators $O$ and $O'$ are \emph{flux stabilizer equivalent}, written $O \sim_{\mathfrak{B}} O'$, if they are related by the equivalence closure of the flux stabilizer step relation. Equivalently,
\[
O' = O \cdot \prod_{p \in P} (\mathfrak{B}_p)^{k_p}
\]
for some integers $k_p$.
\end{definition}

\begin{theorem}[Reflexivity of Flux Stabilizer Equivalence]
\label{thm:flux_stabilizer_equiv_refl}
\lean{GaugingLDPC.fluxStabilizerEquiv_refl}
\leanok
\uses{def:flux_stabilizer_equiv}

For any gauged operator $O$, we have $O \sim_{\mathfrak{B}} O$.
\end{theorem}

\begin{proof}
\leanok
\uses{def:flux_stabilizer_equiv}
This follows immediately from the reflexivity property of the equivalence closure.
\end{proof}

\begin{theorem}[Symmetry of Flux Stabilizer Equivalence]
\label{thm:flux_stabilizer_equiv_symm}
\lean{GaugingLDPC.fluxStabilizerEquiv_symm}
\leanok
\uses{def:flux_stabilizer_equiv}

For any gauged operators $O$ and $O'$, if $O \sim_{\mathfrak{B}} O'$ then $O' \sim_{\mathfrak{B}} O$.
\end{theorem}

\begin{proof}
\leanok
\uses{def:flux_stabilizer_equiv}
This follows immediately from the symmetry property of the equivalence closure.
\end{proof}

\begin{theorem}[Transitivity of Flux Stabilizer Equivalence]
\label{thm:flux_stabilizer_equiv_trans}
\lean{GaugingLDPC.fluxStabilizerEquiv_trans}
\leanok
\uses{def:flux_stabilizer_equiv}

For any gauged operators $O$, $O'$, and $O''$, if $O \sim_{\mathfrak{B}} O'$ and $O' \sim_{\mathfrak{B}} O''$, then $O \sim_{\mathfrak{B}} O''$.
\end{theorem}

\begin{proof}
\leanok
\uses{def:flux_stabilizer_equiv}
This follows immediately from the transitivity property of the equivalence closure.
\end{proof}

\begin{definition}[Flux Stabilizer Setoid]
\label{def:flux_stabilizer_setoid}
\lean{GaugingLDPC.FluxStabilizerSetoid}
\leanok
\uses{def:flux_stabilizer_equiv, thm:flux_stabilizer_equiv_refl, thm:flux_stabilizer_equiv_symm, thm:flux_stabilizer_equiv_trans}

The \emph{flux stabilizer setoid} is the setoid structure on gauged operators induced by flux stabilizer equivalence $\sim_{\mathfrak{B}}$.
\end{definition}

\begin{definition}[Gauged Code Step Relation]
\label{def:gauged_code_step}
\lean{GaugingLDPC.GaugedCodeStep}
\leanok
\uses{def:decorated_stabilizer_step, def:vertex_stabilizer_step, def:flux_stabilizer_step}

The \emph{gauged code step relation} is the union of the three generating relations. Two operators $O$ and $O'$ are related by a single gauged code step if they are related by a decorated stabilizer step, a vertex stabilizer step, or a flux stabilizer step.
\end{definition}

\begin{definition}[Full Gauged Code Equivalence $\sim_g$]
\label{def:gauged_code_equiv}
\lean{GaugingLDPC.GaugedCodeEquiv}
\leanok
\uses{def:gauged_code_step, def:decorated_stabilizer_step}

Two operators $O$ and $O'$ are \emph{gauged code equivalent}, written $O \sim_g O'$, if they are related by the equivalence closure of the combined gauged code step relation. This means there exists a finite chain
\[
O = O_0 \sim O_1 \sim \cdots \sim O_n = O'
\]
where each step $O_i \sim O_{i+1}$ is one of $\sim_{\mathfrak{s}}$, $\sim_{\mathfrak{A}}$, or $\sim_{\mathfrak{B}}$.

This is the full gauged code equivalence capturing:
\[
O \sim_g O' \iff O \sim_{\mathfrak{s}} \circ \sim_{\mathfrak{A}} \circ \sim_{\mathfrak{B}} O'.
\]
\end{definition}

\begin{theorem}[Reflexivity of Gauged Code Equivalence]
\label{thm:gauged_code_equiv_refl}
\lean{GaugingLDPC.gaugedCodeEquiv_refl}
\leanok
\uses{def:gauged_code_equiv}

For any gauged operator $O$, we have $O \sim_g O$.
\end{theorem}

\begin{proof}
\leanok
\uses{def:gauged_code_equiv}
This follows immediately from the reflexivity property of the equivalence closure.
\end{proof}

\begin{theorem}[Symmetry of Gauged Code Equivalence]
\label{thm:gauged_code_equiv_symm}
\lean{GaugingLDPC.gaugedCodeEquiv_symm}
\leanok
\uses{def:gauged_code_equiv}

For any gauged operators $O$ and $O'$, if $O \sim_g O'$ then $O' \sim_g O$.
\end{theorem}

\begin{proof}
\leanok
\uses{def:gauged_code_equiv}
This follows immediately from the symmetry property of the equivalence closure.
\end{proof}

\begin{theorem}[Transitivity of Gauged Code Equivalence]
\label{thm:gauged_code_equiv_trans}
\lean{GaugingLDPC.gaugedCodeEquiv_trans}
\leanok
\uses{def:gauged_code_equiv}

For any gauged operators $O$, $O'$, and $O''$, if $O \sim_g O'$ and $O' \sim_g O''$, then $O \sim_g O''$.
\end{theorem}

\begin{proof}
\leanok
\uses{def:gauged_code_equiv}
This follows immediately from the transitivity property of the equivalence closure.
\end{proof}

\begin{definition}[Gauged Code Setoid]
\label{def:gauged_code_setoid}
\lean{GaugingLDPC.GaugedCodeSetoid}
\leanok
\uses{def:gauged_code_equiv, thm:gauged_code_equiv_refl, thm:gauged_code_equiv_symm, thm:gauged_code_equiv_trans}

The \emph{gauged code setoid} is the setoid structure on gauged operators induced by the full gauged code equivalence $\sim_g$.
\end{definition}

\begin{theorem}[Decorated Stabilizer Step Implies Gauged Code Step]
\label{thm:decorated_stabilizer_step_subset_gauged_code_step}
\lean{GaugingLDPC.decoratedStabilizerStep_subset_gaugedCodeStep}
\leanok
\uses{def:decorated_stabilizer_step, def:gauged_code_step}

For any operators $O$ and $O'$, if they are related by a decorated stabilizer step, then they are related by a gauged code step.
\end{theorem}

\begin{proof}
\leanok
\uses{def:decorated_stabilizer_step, def:gauged_code_step}
This follows directly from the definition, as the gauged code step is the disjunction of the three step relations, and the decorated stabilizer step is the first disjunct.
\end{proof}

\begin{theorem}[Vertex Stabilizer Step Implies Gauged Code Step]
\label{thm:vertex_stabilizer_step_subset_gauged_code_step}
\lean{GaugingLDPC.vertexStabilizerStep_subset_gaugedCodeStep}
\leanok
\uses{def:vertex_stabilizer_step, def:gauged_code_step}

For any operators $O$ and $O'$, if they are related by a vertex stabilizer step, then they are related by a gauged code step.
\end{theorem}

\begin{proof}
\leanok
\uses{def:vertex_stabilizer_step, def:gauged_code_step}
The vertex stabilizer step hypothesis $h$ is injected into the second disjunct of the gauged code step: $\mathsf{Or.inr}(\mathsf{Or.inl}(h))$.
\end{proof}

\begin{theorem}[Flux Stabilizer Step Implies Gauged Code Step]
\label{thm:flux_stabilizer_step_subset_gauged_code_step}
\lean{GaugingLDPC.fluxStabilizerStep_subset_gaugedCodeStep}
\leanok
\uses{def:flux_stabilizer_step, def:gauged_code_step}

For any operators $O$ and $O'$, if they are related by a flux stabilizer step, then they are related by a gauged code step.
\end{theorem}

\begin{proof}
\leanok
\uses{def:flux_stabilizer_step, def:gauged_code_step}
The flux stabilizer step hypothesis $h$ is injected into the third disjunct of the gauged code step: $\mathsf{Or.inr}(\mathsf{Or.inr}(h))$.
\end{proof}

\begin{theorem}[Decorated Stabilizer Equivalence Implies Gauged Code Equivalence]
\label{thm:decorated_stabilizer_equiv_subset_gauged_code_equiv}
\lean{GaugingLDPC.decoratedStabilizerEquiv_subset_gaugedCodeEquiv}
\leanok
\uses{def:equivalence__relations_in_the__gauged__code, def:gauged_code_equiv}

For any operators $O$ and $O'$, if $O \sim_{\mathfrak{s}} O'$ then $O \sim_g O'$.
\end{theorem}

\begin{proof}
\leanok
\uses{def:equivalence__relations_in_the__gauged__code, def:gauged_code_equiv, def:gauged_code_step}
Let $h$ be the hypothesis that $O \sim_{\mathfrak{s}} O'$. We proceed by induction on the equivalence closure structure of $h$:

\textbf{Case rel}: If $x$ and $y$ are related by the basic decorated stabilizer step relation $h_{xy}$, then $\mathsf{Or.inl}(h_{xy})$ shows they are related by a gauged code step, and hence by the equivalence closure.

\textbf{Case refl}: If $x = x$, this follows by reflexivity of the gauged code equivalence.

\textbf{Case symm}: If $x \sim_g y$ (by induction hypothesis), then $y \sim_g x$ by symmetry of the gauged code equivalence.

\textbf{Case trans}: If $x \sim_g y$ and $y \sim_g z$ (by induction hypotheses), then $x \sim_g z$ by transitivity of the gauged code equivalence.
\end{proof}

\begin{theorem}[Vertex Stabilizer Equivalence Implies Gauged Code Equivalence]
\label{thm:vertex_stabilizer_equiv_subset_gauged_code_equiv}
\lean{GaugingLDPC.vertexStabilizerEquiv_subset_gaugedCodeEquiv}
\leanok
\uses{def:vertex_stabilizer_equiv, def:gauged_code_equiv}

For any operators $O$ and $O'$, if $O \sim_{\mathfrak{A}} O'$ then $O \sim_g O'$.
\end{theorem}

\begin{proof}
\leanok
\uses{def:vertex_stabilizer_equiv, def:gauged_code_equiv, def:gauged_code_step}
Let $h$ be the hypothesis that $O \sim_{\mathfrak{A}} O'$. We proceed by induction on the equivalence closure structure of $h$:

\textbf{Case rel}: If $x$ and $y$ are related by the basic vertex stabilizer step relation $h_{xy}$, then $\mathsf{Or.inr}(\mathsf{Or.inl}(h_{xy}))$ shows they are related by a gauged code step, and hence by the equivalence closure.

\textbf{Case refl}: If $x = x$, this follows by reflexivity of the gauged code equivalence.

\textbf{Case symm}: If $x \sim_g y$ (by induction hypothesis), then $y \sim_g x$ by symmetry of the gauged code equivalence.

\textbf{Case trans}: If $x \sim_g y$ and $y \sim_g z$ (by induction hypotheses), then $x \sim_g z$ by transitivity of the gauged code equivalence.
\end{proof}

\begin{theorem}[Flux Stabilizer Equivalence Implies Gauged Code Equivalence]
\label{thm:flux_stabilizer_equiv_subset_gauged_code_equiv}
\lean{GaugingLDPC.fluxStabilizerEquiv_subset_gaugedCodeEquiv}
\leanok
\uses{def:flux_stabilizer_equiv, def:gauged_code_equiv}

For any operators $O$ and $O'$, if $O \sim_{\mathfrak{B}} O'$ then $O \sim_g O'$.
\end{theorem}

\begin{proof}
\leanok
\uses{def:flux_stabilizer_equiv, def:gauged_code_equiv, def:gauged_code_step}
Let $h$ be the hypothesis that $O \sim_{\mathfrak{B}} O'$. We proceed by induction on the equivalence closure structure of $h$:

\textbf{Case rel}: If $x$ and $y$ are related by the basic flux stabilizer step relation $h_{xy}$, then $\mathsf{Or.inr}(\mathsf{Or.inr}(h_{xy}))$ shows they are related by a gauged code step, and hence by the equivalence closure.

\textbf{Case refl}: If $x = x$, this follows by reflexivity of the gauged code equivalence.

\textbf{Case symm}: If $x \sim_g y$ (by induction hypothesis), then $y \sim_g x$ by symmetry of the gauged code equivalence.

\textbf{Case trans}: If $x \sim_g y$ and $y \sim_g z$ (by induction hypotheses), then $x \sim_g z$ by transitivity of the gauged code equivalence.
\end{proof}

\begin{lemma}[Vertex Stabilizer Creates Equivalence]
\label{lem:vertex_stabilizer_equiv}
\lean{GaugingLDPC.vertexStabilizer_equiv}
\leanok
\uses{def:vertex_stabilizer_equiv, def:decorated_stabilizer_step}

For any gauged operator $O$ and vertex $v \in V$,
\[
O \sim_{\mathfrak{A}} O \circ \mathfrak{A}_v.
\]
\end{lemma}

\begin{proof}
\leanok
\uses{def:vertex_stabilizer_step}
The pair $(O, O \circ \mathfrak{A}_v)$ satisfies the vertex stabilizer step condition with witness $v$ (taking the left disjunct with reflexivity). The equivalence closure then includes this pair.
\end{proof}

\begin{lemma}[Flux Stabilizer Creates Equivalence]
\label{lem:flux_stabilizer_equiv}
\lean{GaugingLDPC.fluxStabilizer_equiv}
\leanok
\uses{def:flux_stabilizer_equiv, def:decorated_stabilizer_step}

For any gauged operator $O$ and plaquette $p \in P$,
\[
O \sim_{\mathfrak{B}} O \circ \mathfrak{B}_p.
\]
\end{lemma}

\begin{proof}
\leanok
\uses{def:flux_stabilizer_step}
The pair $(O, O \circ \mathfrak{B}_p)$ satisfies the flux stabilizer step condition with witness $p$ (taking the left disjunct with reflexivity). The equivalence closure then includes this pair.
\end{proof}

\begin{lemma}[Vertex Stabilizer Equivalent to Identity]
\label{lem:vertex_stabilizer_equiv_id}
\lean{GaugingLDPC.vertexStabilizer_equiv_id}
\leanok
\uses{def:vertex_stabilizer_equiv, def:decorated_stabilizer_step, lem:vertex_stabilizer_equiv}

For any vertex $v \in V$,
\[
\mathrm{id} \sim_{\mathfrak{A}} \mathfrak{A}_v.
\]
\end{lemma}

\begin{proof}
\leanok
\uses{lem:vertex_stabilizer_equiv}
We first establish that $\mathrm{id} \sim_{\mathfrak{A}} \mathrm{id} \circ \mathfrak{A}_v$ by applying the vertex stabilizer equivalence lemma with $O = \mathrm{id}$ and vertex $v$. Then by simplification using the identity composition law ($\mathrm{id} \circ f = f$), we obtain $\mathrm{id} \sim_{\mathfrak{A}} \mathfrak{A}_v$.
\end{proof}

\begin{lemma}[Flux Stabilizer Equivalent to Identity]
\label{lem:flux_stabilizer_equiv_id}
\lean{GaugingLDPC.fluxStabilizer_equiv_id}
\leanok
\uses{def:flux_stabilizer_equiv, def:decorated_stabilizer_step, lem:flux_stabilizer_equiv}

For any plaquette $p \in P$,
\[
\mathrm{id} \sim_{\mathfrak{B}} \mathfrak{B}_p.
\]
\end{lemma}

\begin{proof}
\leanok
\uses{lem:flux_stabilizer_equiv}
We first establish that $\mathrm{id} \sim_{\mathfrak{B}} \mathrm{id} \circ \mathfrak{B}_p$ by applying the flux stabilizer equivalence lemma with $O = \mathrm{id}$ and plaquette $p$. Then by simplification using the identity composition law ($\mathrm{id} \circ f = f$), we obtain $\mathrm{id} \sim_{\mathfrak{B}} \mathfrak{B}_p$.
\end{proof}

\begin{lemma}[Gauged Code Equivalence from Vertex Stabilizer]
\label{lem:gauged_code_equiv_of_vertex_stabilizer}
\lean{GaugingLDPC.gaugedCodeEquiv_of_vertexStabilizer}
\leanok
\uses{def:gauged_code_equiv, thm:vertex_stabilizer_equiv_subset_gauged_code_equiv, lem:vertex_stabilizer_equiv}

For any gauged operator $O$ and vertex $v \in V$,
\[
O \sim_g O \circ \mathfrak{A}_v.
\]
\end{lemma}

\begin{proof}
\leanok
\uses{thm:vertex_stabilizer_equiv_subset_gauged_code_equiv, lem:vertex_stabilizer_equiv}
By the vertex stabilizer equivalence lemma, $O \sim_{\mathfrak{A}} O \circ \mathfrak{A}_v$. By the inclusion theorem for vertex stabilizer equivalence into gauged code equivalence, this implies $O \sim_g O \circ \mathfrak{A}_v$.
\end{proof}

\begin{lemma}[Gauged Code Equivalence from Flux Stabilizer]
\label{lem:gauged_code_equiv_of_flux_stabilizer}
\lean{GaugingLDPC.gaugedCodeEquiv_of_fluxStabilizer}
\leanok
\uses{def:gauged_code_equiv, thm:flux_stabilizer_equiv_subset_gauged_code_equiv, lem:flux_stabilizer_equiv}

For any gauged operator $O$ and plaquette $p \in P$,
\[
O \sim_g O \circ \mathfrak{B}_p.
\]
\end{lemma}

\begin{proof}
\leanok
\uses{thm:flux_stabilizer_equiv_subset_gauged_code_equiv, lem:flux_stabilizer_equiv}
By the flux stabilizer equivalence lemma, $O \sim_{\mathfrak{B}} O \circ \mathfrak{B}_p$. By the inclusion theorem for flux stabilizer equivalence into gauged code equivalence, this implies $O \sim_g O \circ \mathfrak{B}_p$.
\end{proof}

\begin{lemma}[Gauged Code Equivalence from Decorated Stabilizer]
\label{lem:gauged_code_equiv_of_decorated_stabilizer}
\lean{GaugingLDPC.gaugedCodeEquiv_of_decoratedStabilizer}
\leanok
\uses{def:gauged_code_equiv, thm:decorated_stabilizer_equiv_subset_gauged_code_equiv, lem:decorated_stabilizer_induces_step}

For any gauged operator $O$ and index $s \in S$,
\[
O \sim_g O \circ \tilde{\mathbb{S}}_s.
\]
\end{lemma}

\begin{proof}
\leanok
\uses{thm:decorated_stabilizer_equiv_subset_gauged_code_equiv, lem:decorated_stabilizer_induces_step}
By the decorated stabilizer induces step lemma, $O \sim_{\mathfrak{s}} O \circ \tilde{\mathbb{S}}_s$. By the inclusion theorem for decorated stabilizer equivalence into gauged code equivalence, this implies $O \sim_g O \circ \tilde{\mathbb{S}}_s$.
\end{proof}

%--- Thm_3: Distance Preservation Under Gauging ---
\begin{definition}[Original Logical Operator]
\label{def:original_logical_operator}
\lean{GaugingLDPC.OriginalLogicalOperator}
\leanok

A \textbf{logical operator} of the original code is represented by its matter support and the property of being non-trivial. Formally, it consists of:
\begin{itemize}
    \item A set of vertices $\mathrm{matterSupport} \subseteq V$ where the logical operator acts non-trivially
    \item A proof that $\mathrm{matterSupport} \neq \emptyset$ (logical operators are non-trivial)
\end{itemize}
\end{definition}

\begin{definition}[Weight of Original Logical Operator]
\label{def:original_logical_operator_weight}
\lean{GaugingLDPC.OriginalLogicalOperator.weight}
\leanok
\uses{def:original_logical_operator}

The \textbf{weight} of an original logical operator $L$ is defined as the cardinality of its matter support:
\[
\mathrm{weight}(L) := |\mathrm{matterSupport}(L)|
\]
\end{definition}

\begin{lemma}[Positive Weight of Logical Operators]
\label{lem:original_logical_operator_weight_pos}
\lean{GaugingLDPC.OriginalLogicalOperator.weight_pos}
\leanok
\uses{def:original_logical_operator, def:original_logical_operator_weight}

For any original logical operator $L$, the weight is strictly positive:
\[
0 < \mathrm{weight}(L)
\]
\end{lemma}

\begin{proof}
\leanok

This follows directly from the fact that $\mathrm{matterSupport}(L)$ is nonempty (by the definition of logical operators), so its cardinality is positive.
\end{proof}

\begin{definition}[Gauged Code Weights]
\label{def:gauged_code_weights}
\lean{GaugingLDPC.GaugedCodeWeights}
\leanok
\uses{def:original_logical_operator_weight}

The set of all weights of gauged operators coming from logical operators is defined as:
\[
\mathrm{GaugedCodeWeights} := \{ n \mid \exists \, \mathrm{logicalWeight} \in \mathrm{logicalWeights}, \exists \, \mathrm{equivWeight} \in \mathrm{equivClassMinWeights}(\mathrm{logicalWeight}), n = \mathrm{equivWeight} \}
\]
This represents the set $\{ |\mathrm{Supp}(O)| : L \text{ is logical}, O \sim_g \mathfrak{D}(L) \}$.
\end{definition}

\begin{definition}[Gauged Code Distance]
\label{def:gauged_code_distance}
\lean{GaugingLDPC.GaugedCodeDistance}
\leanok
\uses{def:gauged_code_weights}

The \textbf{gauged code distance} is defined as the infimum over all gauged operator weights:
\[
d_g := \inf(\mathrm{GaugedCodeWeights}) = \min_L \min_{O \sim_g \mathfrak{D}(L)} |\mathrm{Supp}(O)|
\]
\end{definition}

\begin{lemma}[Decoration Weight Bound]
\label{lem:decoration_weight_ge_original}
\lean{GaugingLDPC.decoration_weight_ge_original}
\leanok
\uses{def:decorated__stabilizer_(_gauged__stabilizer_of__original__code)}

Decoration adds support. For $\mathfrak{D}(L) = L \otimes \mathcal{Z}(\alpha)$ where $\alpha$ solves $\partial_1 \alpha = \chi$, since matter and gauge qudits are on disjoint spaces:
\[
|\mathrm{Supp}(\mathfrak{D}(L))| = |\mathrm{Supp}(L)| + |\mathrm{edge\_support}(\alpha)| \geq |\mathrm{Supp}(L)|
\]
Equivalently, for any $\mathrm{originalWeight}$ and $\mathrm{edgeSupport}$:
\[
\mathrm{originalWeight} + \mathrm{edgeSupport} \geq \mathrm{originalWeight}
\]
\end{lemma}

\begin{proof}
\leanok

By integer arithmetic: adding a non-negative term preserves the inequality.
\end{proof}

\begin{lemma}[Flux Equivalence Preserves Matter]
\label{lem:flux_equiv_preserves_matter}
\lean{GaugingLDPC.flux_equiv_preserves_matter}
\leanok
\uses{def:equivalence__relations_in_the__gauged__code}

Flux stabilizers $\mathfrak{B}_p = \prod_{e \in \partial p} \mathcal{Z}_e$ are pure edge operators that act only on gauge qudits. Therefore, matter support is preserved under flux equivalence $\sim_\mathfrak{B}$. For any matter weight and edge weights:
\[
\mathrm{matterWeight} + \mathrm{edgeWeight}_2 \geq \mathrm{matterWeight}
\]
\end{lemma}

\begin{proof}
\leanok

By integer arithmetic.
\end{proof}

\begin{lemma}[Vertex Equivalence Weight Non-Decreasing]
\label{lem:vertex_equiv_weight_nondecreasing}
\lean{GaugingLDPC.vertex_equiv_weight_nondecreasing}
\leanok
\uses{def:cheeger__constant_(_isoperimetric__constant), def:gauging__graph__criteria}

When applying the vertex stabilizer $\mathfrak{A}_v = \mathsf{T}_{\Sigma(v)} \prod_{e \ni v} \mathcal{X}_e$:
\begin{itemize}
    \item Matter support decreases by at most $|\{v\}| = 1$
    \item Edge support increases by $|\partial\{v\}| \geq 1$ (by the Cheeger bound)
\end{itemize}
Net change $\geq 0$.

For a set $U$ of vertices:
\begin{itemize}
    \item Matter lost $\leq |U|$
    \item Edges gained $= |\partial U| \geq |U|$ (by Cheeger $h(\mathcal{G}) \geq 1$)
\end{itemize}

For a simple graph $G$ that is an expander graph and any small subset $U \subseteq V$:
\[
|\mathrm{edgeBoundary}_G(U)| \geq |U|
\]
\end{lemma}

\begin{proof}
\leanok
\uses{lem:gauged__code_is__sparse_and__distance__preserving}

This follows directly from the expander graph property, which guarantees that the edge boundary of any small subset is at least as large as the subset itself.
\end{proof}

\begin{lemma}[Vertex Step Net Change Non-Negative]
\label{lem:vertex_step_net_change_nonneg}
\lean{GaugingLDPC.vertex_step_net_change_nonneg}
\leanok
\uses{def:cheeger__constant_(_isoperimetric__constant), def:gauging__graph__criteria, lem:weight__non__decrease__under__stabilizer__equivalence}

For an expander graph $G$ and any small subset $U \subseteq V$:
\[
\mathrm{netSupportChange}(G, U) \geq 0
\]
\end{lemma}

\begin{proof}
\leanok
\uses{lem:weight__non__decrease__under__stabilizer__equivalence}

This is a direct consequence of the weight non-decrease under stabilizer equivalence lemma.
\end{proof}

\begin{lemma}[Stabilizer Equivalence Preserves Bound]
\label{lem:stabilizer_equiv_preserves_bound}
\lean{GaugingLDPC.stabilizer_equiv_preserves_bound}
\leanok
\uses{lem:gauging_is_a__homomorphism_(up_to__flux__equivalence)}

By the gauging homomorphism property: $\mathfrak{D}(L)\mathfrak{D}(S) = \mathfrak{D}(LS)$ for stabilizers $S$.
Since $LS$ is also a logical operator with $|LS| \geq d$, the distance bound is preserved.

Formally: given distance $d$, a set of logical weights with $\forall w \in \mathrm{logicalWeights}, w \geq d$, and any $LS_{\mathrm{weight}} \in \mathrm{logicalWeights}$:
\[
LS_{\mathrm{weight}} \geq d
\]
\end{lemma}

\begin{proof}
\leanok

This follows directly from the assumption that all logical weights are at least $d$.
\end{proof}

\begin{lemma}[Equivalence Class Weight Lower Bound]
\label{lem:equiv_class_weight_ge_d}
\lean{GaugingLDPC.equiv_class_weight_ge_d}
\leanok
\uses{def:decorated__stabilizer_(_gauged__stabilizer_of__original__code), def:cheeger__constant_(_isoperimetric__constant), lem:vertex_equiv_weight_nondecreasing}

Every weight in an equivalence class is at least $d$.

\textbf{Proof structure}:
\begin{enumerate}
    \item Start with $L$ where $|L| \geq d$
    \item Decoration: $|\mathfrak{D}(L)| = |L| + \mathrm{edges} \geq |L| \geq d$
    \item Each equivalence step maintains the bound:
    \begin{itemize}
        \item Decorated stabilizer: maps to $\mathfrak{D}(LS)$, $|LS| \geq d$
        \item Vertex stabilizer: Cheeger ensures net change $\geq 0$
        \item Flux stabilizer: pure edge, matter preserved
    \end{itemize}
\end{enumerate}

Formally: given $d$, logical weight $\geq d$, decoration edges, and vertex steps net change $\geq 0$:
\[
\mathrm{logicalWeight} + \mathrm{decorationEdges} + \mathrm{vertexStepsNetChange} \geq d
\]
\end{lemma}

\begin{proof}
\leanok
\uses{lem:decoration_weight_ge_original, lem:vertex_step_net_change_nonneg}

We have $\mathrm{logicalWeight} + \mathrm{decorationEdges} \geq \mathrm{logicalWeight}$ since decoration edges are non-negative. Adding the non-negative vertex steps net change preserves this inequality. Since $\mathrm{logicalWeight} \geq d$, the result follows by integer arithmetic.
\end{proof}

\begin{theorem}[Distance Preservation Under Gauging]
\label{thm:distance__preservation__under__gauging}
\lean{GaugingLDPC.DistancePreservationUnderGauging}
\leanok
\uses{def:cheeger__constant_(_isoperimetric__constant), def:decorated__stabilizer_(_gauged__stabilizer_of__original__code), def:equivalence__relations_in_the__gauged__code, def:gauged__stabilizers_(_vertex_and__plaquette__terms), def:gauging__graph__criteria, lem:gauged__code_is__sparse_and__distance__preserving, lem:gauging_is_a__homomorphism_(up_to__flux__equivalence), lem:weight__non__decrease__under__stabilizer__equivalence}

For a gauging graph $\mathcal{G}$ with Cheeger constant $h(\mathcal{G}) \geq 1$ (an expander graph), the gauged code distance satisfies:
\[
d_g \geq d
\]
where $d$ is the distance of the original code and
\[
d_g := \min_L \min_{O \sim_g \mathfrak{D}(L)} |\mathrm{Supp}(O)|
\]

\textbf{Assumptions}:
\begin{itemize}
    \item A nonempty set of logical weights
    \item All logical weights are at least $d$
    \item Equivalence classes are nonempty (contain at least $\mathfrak{D}(L)$)
    \item Every weight in an equivalence class is $\geq$ the logical weight
\end{itemize}
\end{theorem}

\begin{proof}
\leanok
\uses{lem:equiv_class_weight_ge_d}

We unfold the definition of gauged code distance as $\inf(\mathrm{GaugedCodeWeights})$.

First, we show the set is nonempty: from the nonemptiness of logical weights, we obtain some $w$ in the set. From the nonemptiness of equivalence classes for $w$, we obtain some $ew \in \mathrm{equivClassMinWeights}(w)$. Then $ew \in \mathrm{GaugedCodeWeights}$.

We apply $\mathrm{le\_csInf}$ with the nonemptiness established above to reduce to showing $d \leq n$ for all $n \in \mathrm{GaugedCodeWeights}$.

Let $n \in \mathrm{GaugedCodeWeights}$. By definition, $n$ comes from some logical weight $\mathrm{logWeight}$ and equivalence weight $\mathrm{equivWeight}$ with $n = \mathrm{equivWeight}$.

By the equivalence weight bound hypothesis: $\mathrm{equivWeight} \geq \mathrm{logWeight}$.
By the distance hypothesis: $\mathrm{logWeight} \geq d$.

Therefore $n = \mathrm{equivWeight} \geq \mathrm{logWeight} \geq d$ by integer arithmetic.
\end{proof}

\begin{theorem}[Distance Preservation with Expander]
\label{thm:distance_preservation_with_expander}
\lean{GaugingLDPC.DistancePreservationWithExpander}
\leanok
\uses{def:cheeger__constant_(_isoperimetric__constant), def:original_logical_operator, def:original_logical_operator_weight}

Alternative formulation using expander graphs directly. For an expander graph $G$, distance $d$, and a nonempty set of logical operators where each has weight $\geq d$:
\[
\inf \{ w \mid \exists L \in \mathrm{logicals}, w \in \mathrm{equivClassWeights}(L) \} \geq d
\]
provided that:
\begin{itemize}
    \item Each equivalence class is nonempty
    \item Each weight in an equivalence class is $\geq L.\mathrm{weight}$
\end{itemize}
\end{theorem}

\begin{proof}
\leanok

First, we show the set is nonempty: from the nonemptiness of logicals, we obtain some $L$. From the nonemptiness of $\mathrm{equivClassWeights}(L)$, we obtain some $w$ in that set. Then $w$ is in the target set.

We apply $\mathrm{le\_csInf}$ with this nonemptiness and show $d \leq n$ for all $n$ in the set.

Let $n$ be in the set. By definition, there exists $L \in \mathrm{logicals}$ with $n \in \mathrm{equivClassWeights}(L)$.

By the equivalence bound: $n \geq L.\mathrm{weight}$.
By the distance hypothesis: $L.\mathrm{weight} \geq d$.

Therefore $n \geq d$ by integer arithmetic.
\end{proof}

\begin{lemma}[Valid Gauging Graph is Expander]
\label{lem:valid_gauging_is_expander}
\lean{GaugingLDPC.validGauging_is_expander}
\leanok
\uses{def:gauging__graph__criteria, def:cheeger__constant_(_isoperimetric__constant)}

A $\mathrm{ValidGaugingGraph}$ satisfies $h(\mathcal{G}) \geq 1$ via Criterion 4 (expansion property). This is exactly the expander property needed for distance preservation.

For a valid gauging graph $VG$, the underlying simple graph is an expander graph.
\end{lemma}

\begin{proof}
\leanok

This follows directly from the $\mathrm{criterion4\_expansion}$ field of $\mathrm{ValidGaugingGraph}$, which asserts that the gauging graph is an expander.
\end{proof}

\begin{theorem}[Distance Preservation with Valid Gauging Graph]
\label{thm:distance_preservation_with_valid_gauging_graph}
\lean{GaugingLDPC.DistancePreservationWithValidGaugingGraph}
\leanok
\uses{def:gauging__graph__criteria, lem:valid_gauging_is_expander, thm:distance_preservation_with_expander}

For a valid gauging graph satisfying all four criteria (including $h(\mathcal{G}) \geq 1$), distance is preserved: $d_g \geq d$.

Given a $\mathrm{ValidGaugingGraph}$, distance $d$, nonempty set of logicals with weights $\geq d$, nonempty equivalence classes, and equivalence weight bounds:
\[
\inf \{ w \mid \exists L \in \mathrm{logicals}, w \in \mathrm{equivClassWeights}(L) \} \geq d
\]
\end{theorem}

\begin{proof}
\leanok
\uses{thm:distance_preservation_with_expander, lem:valid_gauging_is_expander}

This follows directly from $\mathrm{DistancePreservationWithExpander}$ applied to the underlying simple graph of the gauged cell complex, using the expander property $VG.\mathrm{criterion4\_expansion}$ from the valid gauging graph.
\end{proof}

\begin{definition}[Gauged Operator From Logical]
\label{def:gauged_operator_from_logical}
\lean{GaugingLDPC.GaugedOperatorFromLogical}
\leanok
\uses{def:original_logical_operator, def:decorated__stabilizer_(_gauged__stabilizer_of__original__code)}

A \textbf{gauged operator obtained from a logical} $L$ tracks the weight contributions from each step of the gauging process:
\begin{itemize}
    \item $\mathrm{logicalWeight}$: Weight of the original logical $|L|$
    \item $\mathrm{decorationEdges}$: Edge support added by decoration $|\alpha|$
    \item $\mathrm{vertexNetChange}$: Net weight change from vertex equivalence steps
    \item $\mathrm{fluxEdgeChange}$: Edge change from flux equivalence (can only rearrange, not decrease)
\end{itemize}
\end{definition}

\begin{definition}[Total Weight of Gauged Operator]
\label{def:gauged_operator_total_weight}
\lean{GaugingLDPC.GaugedOperatorFromLogical.totalWeight}
\leanok
\uses{def:gauged_operator_from_logical}

The \textbf{total weight} of a gauged operator is:
\[
\mathrm{totalWeight} := \mathrm{logicalWeight} + \mathrm{decorationEdges} + \mathrm{vertexNetChange}^+ + \mathrm{fluxEdgeChange}^+
\]
where $x^+ = \max(x, 0)$ denotes the non-negative part.
\end{definition}

\begin{lemma}[Gauged Operator Weight Lower Bound]
\label{lem:gauged_operator_weight_ge_logical}
\lean{GaugingLDPC.gaugedOperator_weight_ge_logical}
\leanok
\uses{def:gauged_operator_from_logical, def:gauged_operator_total_weight, def:cheeger__constant_(_isoperimetric__constant)}

Given the expander property $h(\mathcal{G}) \geq 1$, every gauged operator has weight $\geq$ the original logical weight.

For a gauged operator with $\mathrm{vertexNetChange} \geq 0$ and $\mathrm{fluxEdgeChange} \geq 0$:
\[
\mathrm{totalWeight} \geq \mathrm{logicalWeight}
\]

\textbf{Justification}:
\begin{enumerate}
    \item Decoration adds edges: $\mathrm{logicalWeight} + \mathrm{decorationEdges} \geq \mathrm{logicalWeight}$
    \item Vertex steps: by Cheeger, each step has edges gained $\geq$ matter lost
    \item Flux steps: pure edge operators, don't decrease total weight
    \item Combined: $\mathrm{totalWeight} \geq \mathrm{logicalWeight}$
\end{enumerate}
\end{lemma}

\begin{proof}
\leanok

We unfold the definition of $\mathrm{totalWeight}$. Since $\mathrm{vertexNetChange}.\mathrm{toNat} \geq 0$ and $\mathrm{fluxEdgeChange}.\mathrm{toNat} \geq 0$, and $\mathrm{decorationEdges} \geq 0$, we have:
\[
\mathrm{totalWeight} = \mathrm{logicalWeight} + \mathrm{decorationEdges} + \mathrm{vertexNetChange}.\mathrm{toNat} + \mathrm{fluxEdgeChange}.\mathrm{toNat} \geq \mathrm{logicalWeight}
\]
by integer arithmetic.
\end{proof}

\begin{lemma}[Expander Vertex Steps Non-Negative]
\label{lem:expander_vertex_step_nonneg}
\lean{GaugingLDPC.expander_vertex_step_nonneg}
\leanok
\uses{def:cheeger__constant_(_isoperimetric__constant)}

For expander graphs, the cumulative weight change from a sequence of vertex equivalence steps is non-negative. Given a list of vertex subsets (each representing a vertex step) where each subset is ``small'':
\[
\sum_{\mathrm{step}} \left( |\partial U_{\mathrm{step}}| - |U_{\mathrm{step}}| \right) \geq 0
\]
Formally, folding over the steps with accumulator starting at 0:
\[
\mathrm{foldl}(\lambda \, \mathrm{acc} \, U. \, \mathrm{acc} + |\mathrm{edgeBoundary}(U)| - |U|, 0, \mathrm{steps}) \geq 0
\]
\end{lemma}

\begin{proof}
\leanok
\uses{lem:vertex_equiv_weight_nondecreasing}

We proceed by induction on the list of steps.

\textbf{Base case}: For the empty list, the fold returns the initial accumulator 0, which is $\geq 0$.

\textbf{Inductive step}: For a non-empty list $U :: \mathrm{rest}$, we first process $U$. Since $U$ is a small subset, by the Cheeger bound for expander graphs (Lemma~\ref{lem:vertex_equiv_weight_nondecreasing}), we have $|\mathrm{edgeBoundary}(U)| \geq |U|$. Therefore the step contribution $|\mathrm{edgeBoundary}(U)| - |U| \geq 0$.

The new accumulator is $\mathrm{acc} + |\mathrm{edgeBoundary}(U)| - |U| \geq \mathrm{acc} \geq 0$.

By the inductive hypothesis applied to $\mathrm{rest}$ with this non-negative accumulator, the final result is $\geq 0$.
\end{proof}

